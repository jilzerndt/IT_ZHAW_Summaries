# Specialty Prompt: Programming and Computer Science Courses

## Purpose
Optimized workflow for courses focused on programming, algorithms, data structures, software engineering, databases, web development, etc. where code and implementation are central.

## When to Use
- Courses with substantial coding components
- Algorithm and data structure courses
- Software engineering and design patterns
- Database and systems courses
- Web development and frameworks

---

## Enhanced Phase 1: Code-Heavy Content Extraction

```
Extract programming content from [SOURCE] and create LaTeX following the 
standard Phase 1 guidelines, with these PROGRAMMING EXTENSIONS:

## Code Block Standards

### All Code Must Use lstlisting:
```latex
\begin{examplecode}{[Descriptive Title]}\\
\begin{lstlisting}[language=[Python/Java/JavaScript/C/CPP/SQL/etc], style=base]
[your code here]
\end{lstlisting}

[Optional explanation below code]
\end{examplecode}
```

**Critical Rules:**
- ALWAYS specify `language=` parameter
- ALWAYS include `style=base`
- Use `ae`, `oe`, `ue` instead of `ä`, `ö`, `ü` (even in comments)
- Keep code in English only
- Preserve proper indentation (spaces, not tabs preferred)

### Language Specifications:
```latex
Python:     [language=Python, style=base]
Java:       [language=Java, style=base]
JavaScript: [language=JavaScript, style=base]
C:          [language=C, style=base]
C++:        [language=CPP, style=base]
SQL:        [language=SQL, style=base]
HTML:       [language=HTML, style=base]
CSS:        [language=CSS, style=base]
Bash:       [language=bash, style=base]
Pseudocode: [language=Python, style=base]  % Use Python for readability
```

### Code Snippet Types:

**1. Concept Definition with Code:**
```latex
\begin{code}{[Concept Name]}\\
\begin{lstlisting}[language=Python, style=base]
# Demonstrates the concept
def example():
    pass
\end{lstlisting}

Explanation of what this code demonstrates.
\end{code}
```

**2. Complete Example:**
```latex
\begin{examplecode}{[Example Purpose]}\\
\begin{lstlisting}[language=Java, style=base]
public class Example {
    public static void main(String[] args) {
        // Complete working example
    }
}
\end{lstlisting}

\textbf{Output:} [What this produces]

\textbf{Key points:}
\begin{itemize}
    \item [Important aspect 1]
    \item [Important aspect 2]
\end{itemize}
\end{examplecode}
```

**3. Code Comparison:**
```latex
\mult{2}
\begin{examplecode}{Approach A}\\
\begin{lstlisting}[language=Python, style=base]
# First approach
code here
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{Approach B}\\
\begin{lstlisting}[language=Python, style=base]
# Second approach
code here
\end{lstlisting}
\end{examplecode}
\multend

\begin{remark}
Compare: Approach A is [faster/cleaner/more readable], while B is 
[more flexible/safer/standard practice].
\end{remark}
```

**4. Code with Annotations:**
For complex code requiring explanations:
```latex
\begin{examplecode}{[Title]}\\
\begin{lstlisting}[language=Python, style=base]
def complex_function(data):
    # Step 1: Initialize
    result = []
    
    # Step 2: Process each item
    for item in data:
        processed = transform(item)  # Apply transformation
        result.append(processed)
    
    # Step 3: Return aggregated result
    return aggregate(result)
\end{lstlisting}

\textbf{Flow:}
\begin{enumerate}
    \item Initialize empty result container
    \item Transform each input item
    \item Aggregate and return final result
\end{enumerate}
\end{examplecode}
```

## Algorithm and Data Structure Blocks

### Algorithm Definitions:
```latex
\begin{definition}{[Algorithm Name]}\\
\textbf{Purpose:} [What it does]

\textbf{Input:} [Parameters and types]

\textbf{Output:} [Return value and type]

\textbf{Time Complexity:} $O([expression])$

\textbf{Space Complexity:} $O([expression])$
\end{definition}
```

### Data Structure Definitions:
```latex
\begin{concept}{[Data Structure Name]}\\
\textbf{Structure:} [How data is organized]

\textbf{Operations:}
\begin{itemize}
    \item Insert: $O([complexity])$ - [description]
    \item Delete: $O([complexity])$ - [description]
    \item Search: $O([complexity])$ - [description]
    \item Access: $O([complexity])$ - [description]
\end{itemize}

\textbf{Use cases:} [When to use this structure]

\textbf{Trade-offs:} [Advantages vs disadvantages]
\end{concept}
```

## Enhanced KR Blocks for Programming

### Implementation KRs:
```latex
\begin{KR}{Implementing [Algorithm/Data Structure]}\\
\textbf{Setup:}
\begin{enumerate}
    \item Define [class/function] structure
    \item Initialize [required variables/structures]
    \item Set up [base cases/edge conditions]
\end{enumerate}

\textbf{Core logic:}
\begin{enumerate}
    \item [Main algorithmic step 1]
    \item [Main algorithmic step 2]
    \item [Main algorithmic step 3]
\end{enumerate}

\textbf{Edge cases to handle:}
\begin{itemize}
    \item Empty input: [how to handle]
    \item Single element: [how to handle]
    \item [Other edge cases]
\end{itemize}

\textbf{Testing strategy:}
\begin{itemize}
    \item Test with [small input]
    \item Test with [edge case]
    \item Verify complexity with [large input]
\end{itemize}
\end{KR}
```

### Debugging KRs:
```latex
\begin{KR}{Debugging [Common Problem Type]}\\
\textbf{Symptoms:} [Error messages or unexpected behavior]

\textbf{Common causes:}
\begin{enumerate}
    \item [Cause 1]: Check [what to check]
    \item [Cause 2]: Verify [what to verify]
    \item [Cause 3]: Look for [what to look for]
\end{enumerate}

\textbf{Debug approach:}
\begin{enumerate}
    \item Print/log [intermediate values]
    \item Check [boundary conditions]
    \item Trace [execution flow]
    \item Test [isolated components]
\end{enumerate}
\end{KR}
```

### Design Pattern KRs:
```latex
\begin{KR}{Applying [Pattern Name]}\\
\textbf{When to use:} [Problem characteristics that indicate this pattern]

\textbf{Structure:}
\begin{itemize}
    \item [Component 1]: [Responsibility]
    \item [Component 2]: [Responsibility]
    \item [Component 3]: [Responsibility]
\end{itemize}

\textbf{Implementation steps:}
\begin{enumerate}
    \item Create [base interface/class]
    \item Implement [concrete classes]
    \item Set up [relationships/dependencies]
    \item Wire together [components]
\end{enumerate}

\textbf{Benefits:} [Why this pattern helps]

\textbf{Drawbacks:} [When not to use / costs]
\end{KR}
```

### API/Framework Usage KRs:
```latex
\begin{KR}{Using [Library/Framework Feature]}\\
\textbf{Import/Setup:}
\begin{lstlisting}[language=Python, style=base]
import [required modules]
# Configuration if needed
\end{lstlisting}

\textbf{Basic usage:}
\begin{lstlisting}[language=Python, style=base]
# Minimal working example
\end{lstlisting}

\textbf{Common patterns:}
\begin{itemize}
    \item [Pattern 1]: [When to use]
    \item [Pattern 2]: [When to use]
\end{itemize}

\textbf{Gotchas:}
\begin{itemize}
    \item [Common mistake 1]
    \item [Common mistake 2]
\end{itemize}
\end{KR}
```

## Example Structure for CS Courses

### Algorithm Example:
```latex
\begin{example2}{Binary Search Implementation}\\
\textbf{Task:} Implement binary search to find an element in a sorted array.

\textbf{Given:} Sorted array $arr$ of size $n$, target value $target$

\textbf{Return:} Index of $target$ if found, $-1$ otherwise

\tcblower

\textbf{Solution:}

\begin{lstlisting}[language=Python, style=base]
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1  # Search right half
        else:
            right = mid - 1  # Search left half
    
    return -1  # Not found
\end{lstlisting}

\textbf{Trace example:} $arr = [1, 3, 5, 7, 9]$, $target = 7$
\begin{enumerate}
    \item $left=0, right=4, mid=2$: $arr[2]=5 < 7$ $\rightarrow$ search right
    \item $left=3, right=4, mid=3$: $arr[3]=7$ $\rightarrow$ found at index 3
\end{enumerate}

\textbf{Complexity:} $O(\log n)$ time, $O(1)$ space

\important{Key insight:} Halving the search space each iteration gives 
logarithmic time. Only works on sorted arrays!
\end{example2}
```

### Data Structure Example:
```latex
\begin{example2}{Stack with Array Implementation}\\
\textbf{Task:} Implement a stack data structure with push, pop, and peek 
operations.

\tcblower

\textbf{Solution:}

\begin{lstlisting}[language=Java, style=base]
public class Stack {
    private int[] data;
    private int top;
    private static final int MAX_SIZE = 100;
    
    public Stack() {
        data = new int[MAX_SIZE];
        top = -1;
    }
    
    public void push(int value) {
        if (top >= MAX_SIZE - 1) {
            throw new RuntimeException("Stack overflow");
        }
        data[++top] = value;
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("Stack underflow");
        }
        return data[top--];
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new RuntimeException("Stack is empty");
        }
        return data[top];
    }
    
    public boolean isEmpty() {
        return top == -1;
    }
}
\end{lstlisting}

\textbf{Operations complexity:}
\begin{itemize}
    \item Push: $O(1)$
    \item Pop: $O(1)$
    \item Peek: $O(1)$
\end{itemize}

\important{Edge cases handled:} Overflow, underflow, empty stack checks
\end{example2}
```

### Design Pattern Example:
```latex
\begin{example2}{Singleton Pattern}\\
\textbf{Scenario:} Ensure only one instance of a database connection manager 
exists throughout the application.

\tcblower

\textbf{Solution:}

\begin{lstlisting}[language=Python, style=base]
class DatabaseManager:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.connection = cls._create_connection()
        return cls._instance
    
    @staticmethod
    def _create_connection():
        # Create and return database connection
        return "DB Connection Object"
    
    def query(self, sql):
        # Execute query using self.connection
        pass

# Usage
db1 = DatabaseManager()
db2 = DatabaseManager()
print(db1 is db2)  # Output: True (same instance)
\end{lstlisting}

\textbf{Key points:}
\begin{itemize}
    \item \_\_new\_\_ controls instance creation
    \item \_instance stores the singleton reference
    \item Subsequent calls return existing instance
\end{itemize}

\important{Use case:} Shared resources like database connections, loggers, 
configuration managers
\end{example2}
```

## Complexity Analysis Blocks

### Big-O Reference:
```latex
\begin{highlight}{Common Time Complexities}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Complexity} & \textbf{Name} & \textbf{Example} \\
\hline
$O(1)$ & Constant & Array access, hash lookup \\
$O(\log n)$ & Logarithmic & Binary search \\
$O(n)$ & Linear & Linear search, iteration \\
$O(n \log n)$ & Linearithmic & Merge sort, quick sort \\
$O(n^2)$ & Quadratic & Nested loops, bubble sort \\
$O(2^n)$ & Exponential & Recursive fibonacci \\
$O(n!)$ & Factorial & Permutations \\
\hline
\end{tabular}
\end{center}
\end{highlight}
```

### Analysis KR:
```latex
\begin{KR}{Analyzing Time Complexity}\\
\textbf{Step 1: Identify basic operations}
\begin{itemize}
    \item Count loops: nested = multiply complexities
    \item Identify recursion: use recurrence relations
    \item Note data structure operations (insert, search, etc.)
\end{itemize}

\textbf{Step 2: Count iterations}
\begin{itemize}
    \item For loops: number of iterations = complexity
    \item While loops: analyze when condition becomes false
    \item Recursive: depth $\times$ work per level
\end{itemize}

\textbf{Step 3: Combine complexities}
\begin{itemize}
    \item Sequential: $O(f(n)) + O(g(n)) = O(\max(f(n), g(n)))$
    \item Nested: $O(f(n)) \times O(g(n)) = O(f(n) \cdot g(n))$
\end{itemize}

\textbf{Step 4: Simplify}
\begin{itemize}
    \item Drop constants: $O(3n) = O(n)$
    \item Drop lower-order terms: $O(n^2 + n) = O(n^2)$
    \item Focus on worst-case unless specified
\end{itemize}
\end{KR}
```

## Database/SQL Content

### SQL Query Blocks:
```latex
\begin{examplecode}{JOIN Query Example}\\
\begin{lstlisting}[language=SQL, style=base]
SELECT c.name, o.order_date, o.total
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= '2024-01-01'
ORDER BY o.total DESC
LIMIT 10;
\end{lstlisting}

\textbf{Explanation:}
\begin{itemize}
    \item Joins customers with their orders
    \item Filters orders from 2024 onwards
    \item Returns top 10 by order value
\end{itemize}
\end{examplecode}
```

### Database Schema:
```latex
\begin{concept}{Database Schema}\\
\textbf{Tables:}

\texttt{customers} (customer\_id PK, name, email)

\texttt{orders} (order\_id PK, customer\_id FK, order\_date, total)

\texttt{order\_items} (item\_id PK, order\_id FK, product\_id FK, quantity)

\texttt{products} (product\_id PK, name, price)

\\
\includegraphics[width=0.9\linewidth]{schema_diagram.png}
\\
\end{concept}
```

## Web Development Content

### HTML/CSS Examples:
```latex
\mult{2}
\begin{examplecode}{HTML Structure}\\
\begin{lstlisting}[language=HTML, style=base]
<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Welcome</h1>
    </header>
    <main>
        <p>Content here</p>
    </main>
</body>
</html>
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{CSS Styling}\\
\begin{lstlisting}[language=CSS, style=base]
header {
    background-color: #333;
    color: white;
    padding: 20px;
}

main {
    max-width: 800px;
    margin: 0 auto;
}
\end{lstlisting}
\end{examplecode}
\multend
```

### REST API Example:
```latex
\begin{example2}{RESTful API Endpoints}\\
\textbf{Resource:} Users

\tcblower

\textbf{Endpoints:}

\begin{lstlisting}[language=bash, style=base]
GET    /api/users          # List all users
GET    /api/users/:id      # Get specific user
POST   /api/users          # Create new user
PUT    /api/users/:id      # Update user
DELETE /api/users/:id      # Delete user
\end{lstlisting}

\textbf{Example request:}
\begin{lstlisting}[language=JavaScript, style=base]
fetch('/api/users/123', {
    method: 'GET',
    headers: {
        'Authorization': 'Bearer token123',
        'Content-Type': 'application/json'
    }
})
.then(response => response.json())
.then(data => console.log(data));
\end{lstlisting}

\important{REST principles:} Use HTTP methods correctly, stateless design, 
resource-based URLs
\end{example2}
```

## Testing and Debugging

### Unit Test Example:
```latex
\begin{examplecode}{Unit Test Structure}\\
\begin{lstlisting}[language=Python, style=base]
import unittest

class TestBinarySearch(unittest.TestCase):
    def setUp(self):
        self.sorted_array = [1, 3, 5, 7, 9]
    
    def test_element_found(self):
        result = binary_search(self.sorted_array, 5)
        self.assertEqual(result, 2)
    
    def test_element_not_found(self):
        result = binary_search(self.sorted_array, 6)
        self.assertEqual(result, -1)
    
    def test_empty_array(self):
        result = binary_search([], 5)
        self.assertEqual(result, -1)
    
    def test_single_element(self):
        result = binary_search([5], 5)
        self.assertEqual(result, 0)

if __name__ == '__main__':
    unittest.main()
\end{lstlisting}

\textbf{Test coverage:}
\begin{itemize}
    \item Normal case (element found)
    \item Edge case (element not found)
    \item Boundary case (empty array)
    \item Special case (single element)
\end{itemize}
\end{examplecode}
```

## Visual Diagrams for CS

### Algorithm Flowchart:
```latex
\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    box/.style={rectangle, draw, minimum width=3cm, minimum height=0.8cm},
    decision/.style={diamond, draw, minimum width=2cm, minimum height=1cm},
    arrow/.style={->, thick}
]
\node[box] (start) {Start};
\node[decision, below of=start] (check) {Condition?};
\node[box, below left of=check] (yes) {Action A};
\node[box, below right of=check] (no) {Action B};
\node[box, below of=yes] (end) {End};

\draw[arrow] (start) -- (check);
\draw[arrow] (check) -- node[left] {Yes} (yes);
\draw[arrow] (check) -- node[right] {No} (no);
\draw[arrow] (yes) -- (end);
\draw[arrow] (no) |- (end);
\end{tikzpicture}
\end{center}
```

### Data Structure Diagram:
```latex
\begin{center}
\begin{tikzpicture}[
    node distance=0.5cm,
    array/.style={rectangle, draw, minimum width=0.8cm, minimum height=0.8cm}
]
% Array representation
\foreach \x in {0,1,2,3,4} {
    \node[array] (arr\x) at (\x,0) {\x};
}
\node[above of=arr0] {Array:};

% Linked list representation
\node[array] (node1) at (0,-2) {1};
\node[array] (node2) at (2,-2) {2};
\node[array] (node3) at (4,-2) {3};

\draw[->] (node1) -- (node2);
\draw[->] (node2) -- (node3);
\draw[->] (node3) -- ++(1,0) node[right] {null};

\node[above of=node1] {Linked List:};
\end{tikzpicture}
\end{center}
```

## Version Control / Git Content

```latex
\begin{KR}{Git Workflow}\\
\textbf{Basic workflow:}
\begin{enumerate}
    \item Check status: \texttt{git status}
    \item Stage changes: \texttt{git add <file>} or \texttt{git add .}
    \item Commit: \texttt{git commit -m "message"}
    \item Push: \texttt{git push origin <branch>}
\end{enumerate}

\textbf{Branching:}
\begin{lstlisting}[language=bash, style=base]
git checkout -b feature-branch  # Create and switch
git checkout main               # Switch back
git merge feature-branch        # Merge into current
\end{lstlisting}

\textbf{Common scenarios:}
\begin{itemize}
    \item Undo last commit: \texttt{git reset HEAD\textasciitilde1}
    \item Discard changes: \texttt{git checkout -- <file>}
    \item View history: \texttt{git log --oneline}
\end{itemize}
\end{KR}
```

## Configuration/Setup Blocks

```latex
\begin{remark2}{Environment Setup}\\
\textbf{Installation:}
\begin{lstlisting}[language=bash, style=base]
# Python virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt
\end{lstlisting}

\textbf{Configuration:}
\begin{lstlisting}[language=Python, style=base]
# config.py
DATABASE_URL = "postgresql://localhost/mydb"
SECRET_KEY = "your-secret-key"
DEBUG = True
\end{lstlisting}
\end{remark2}
```

---

## Complete Example: Algorithms Course Chapter

```latex
\section{Sorting Algorithms}

\subsection{Merge Sort}

\begin{definition}{Merge Sort}\\
\textbf{Strategy:} Divide-and-conquer algorithm that recursively splits array 
in half, sorts each half, then merges them.

\textbf{Time Complexity:} $O(n \log n)$ in all cases

\textbf{Space Complexity:} $O(n)$ (requires auxiliary array)

\textbf{Stability:} Stable (preserves relative order of equal elements)
\end{definition}

\begin{KR}{Implementing Merge Sort}\\
\textbf{Structure:}
\begin{enumerate}
    \item \textbf{Base case:} If array length $\leq 1$, return (already sorted)
    \item \textbf{Divide:} Split array into two halves
    \item \textbf{Conquer:} Recursively sort each half
    \item \textbf{Combine:} Merge the sorted halves
\end{enumerate}

\textbf{Merge procedure:}
\begin{enumerate}
    \item Create temporary arrays for left and right halves
    \item Compare elements from both, add smaller to result
    \item Copy remaining elements from non-empty array
\end{enumerate}
\end{KR}

\begin{examplecode}{Merge Sort Implementation}\\
\begin{lstlisting}[language=Python, style=base]
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # Conquer and combine
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    # Compare and merge
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Add remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
\end{lstlisting}
\end{examplecode}

\begin{example2}{Merge Sort Trace}\\
\textbf{Input:} $[38, 27, 43, 3, 9, 82, 10]$

\tcblower

\textbf{Recursion tree:}
\begin{center}
\begin{tikzpicture}[
    level distance=1.2cm,
    level 1/.style={sibling distance=6cm},
    level 2/.style={sibling distance=3cm},
    level 3/.style={sibling distance=1.5cm}
]
\node {[38,27,43,3,9,82,10]}
    child {node {[38,27,43,3]}
        child {node {[38,27]}
            child {node {[38]}}
            child {node {[27]}}
        }
        child {node {[43,3]}
            child {node {[43]}}
            child {node {[3]}}
        }
    }
    child {node {[9,82,10]}
        child {node {[9,82]}
            child {node {[9]}}
            child {node {[82]}}
        }
        child {node {[10]}}
    };
\end{tikzpicture}
\end{center}

\textbf{Merging back up:}
\begin{enumerate}
    \item $[27, 38]$ and $[3, 43]$ $\rightarrow$ $[3, 27, 38, 43]$
    \item $[9, 82]$ and $[10]$ $\rightarrow$ $[9, 10, 82]$
    \item $[3, 27, 38, 43]$ and $[9, 10, 82]$ $\rightarrow$ $[3, 9, 10, 27, 38, 43, 82]$
\end{enumerate}

\important{Key insight:} Merging sorted arrays is $O(n)$, done $\log n$ times 
$\rightarrow$ total $O(n \log n)$
\end{example2}

\begin{highlight}{Sorting Algorithm Comparison}
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Algorithm} & \textbf{Best} & \textbf{Avg} & \textbf{Worst} & \textbf{Space} \\
\hline
Merge Sort & $O(n \log n)$ & $O(n \log n)$ & $O(n \log n)$ & $O(n)$ \\
Quick Sort & $O(n \log n)$ & $O(n \log n)$ & $O(n^2)$ & $O(\log n)$ \\
Heap Sort & $O(n \log n)$ & $O(n \log n)$ & $O(n \log n)$ & $O(1)$ \\
Bubble Sort & $O(n)$ & $O(n^2)$ & $O(n^2)$ & $O(1)$ \\
\hline
\end{tabular}
\end{center}
\end{highlight}
```

---

## Time Optimization for Programming Courses

**Strategies:**
1. Template common code patterns (class structures, test setups)
2. Use consistent naming conventions across examples
3. Build library of reusable algorithm/data structure diagrams
4. Extract API documentation efficiently (KRs for common operations)

**Expected time per chapter:**
- Light programming (20-30% code): Use standard workflow
- Medium programming (50% code): Similar to standard workflow
- Heavy programming (70%+ code): Potentially faster than math due to less complex LaTeX notation

**Advantages over manual:**
- No manual indentation fixing
- Consistent code formatting
- Automatic language detection
- Easy to update/modify code blocks
```
