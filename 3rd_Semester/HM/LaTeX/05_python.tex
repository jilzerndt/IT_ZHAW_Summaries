
\section{Python Implementationen}

\subsection{Hilfsfunktionen}

\subsection{Numerische Lösung von Nullstellenproblemen}

\begin{examplecode}{Fehlerabschätzung durch Vorzeichenwechsel}
\begin{lstlisting}[language=Python, style=basesmol]
def error_estimate(f, x, eps=1e-5):
    fx_left = f(x - eps)
    fx_right = f(x + eps)
    
    if fx_left * fx_right < 0:
        return eps  # Nullstelle liegt in (x-eps, x+eps)
    return None

    #Returns: Fehlerschranke eps wenn Vorzeichenwechsel, sonst None
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{Verschiedene Abbruchkriterien prüfen} Konvergenzkriterien
\begin{lstlisting}[language=Python, style=basesmol]
def convergence_criteria(x_new, x_old, f_new, f_old, tol=1e-6):
    # Absoluter Fehler im Funktionswert
    if abs(f_new) < tol:
        return True, "Funktionswert < tol"
        
    # Relative Aenderung der x-Werte
    if abs(x_new - x_old) < tol * (1 + abs(x_new)):
        return True, "Relative Aenderung < tol"
        
    # Relative Aenderung der Funktionswerte
    if abs(f_new - f_old) < tol * (1 + abs(f_new)):
        return True, "Funktionsaenderung < tol"
        
    # Divergenzcheck
    if abs(f_new) > 2 * abs(f_old):
        return False, "Divergenz detektiert"
        
    return False, "Noch nicht konvergiert"

    #Returns: (konvergiert?, grund)
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{Fixpunktiteration}
\begin{lstlisting}[language=Python, style=basesmol]
def fixed_point_it(f, x0, tol=1e-6, max_it=100):
    x = x0
    for i in range(max_it):
        x_new = f(x)
        if abs(x_new - x) < tol:
            return x_new, i+1
        x = x_new
    raise ValueError("Keine Konvergenz")

# Optimierte Version mit Fehlerschaetzung
def fixed_point_it_opt(f, x0, tol=1e-6, max_it=100):
    x = x0
    alpha = None  # Schaetzung fuer Lipschitz-Konstante
    for i in range(max_iter):
        x_new = f(x)
        dx = abs(x_new - x)
        # Lipschitz-Konstante schaetzen
        if i > 0 and dx > 0:
            alpha_new = dx / dx_old
            if alpha is None or alpha_new > alpha:
                alpha = alpha_new
        # A-posteriori Fehlerabschaetzung
        if alpha is not None and alpha < 1:
            error = alpha * dx / (1 - alpha)
            if error < tol:
                return x_new, i+1
        x = x_new
        dx_old = dx
    raise ValueError("Keine Konvergenz")
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{Newton-Verfahren}
\begin{lstlisting}[language=Python, style=basesmol]
def newton(f, df, x0, tol=1e-6, max_iter=100):
    x = x0
    for i in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return x, i+1
        dfx = df(x)
        if dfx == 0:
            raise ValueError("Ableitung Null")
        x = x - fx/dfx
    raise ValueError("Keine Konvergenz")

# Optimierte Version mit Fehlerkontrolle
def newton_safe(f, df, x0, tol=1e-6, max_it=100):
    x = x0
    fx = f(x)
    for i in range(max_it):
        dfx = df(x)
        if dfx == 0:
            raise ValueError("Ableitung Null")
        dx = fx/dfx
        x_new = x - dx
        fx_new = f(x_new)
        # Verschiedene Konvergenzkriterien
        if abs(fx_new) < tol:  # Funktionswert
            return x_new, i+1
        if abs(dx) < tol * (1 + abs(x)):  # Relative Aenderung
            return x_new, i+1
        if abs(fx_new) >= abs(fx):  # Divergenzcheck
            raise ValueError("Divergenz detektiert")
        x, fx = x_new, fx_new
    raise ValueError("Keine Konvergenz")
\end{lstlisting}
\end{examplecode}



\begin{examplecode}{Sekantenverfahren}
\begin{lstlisting}[language=Python, style=basesmol]
# Einfache Version
def secant(f, x0, x1, tol=1e-6, max_iter=100):
    fx0 = f(x0)
    fx1 = f(x1)
    
    for i in range(max_iter):
        if abs(fx1) < tol:
            return x1, i+1
            
        if fx1 == fx0:
            raise ValueError("Division durch Null")
            
        x2 = x1 - fx1 * (x1 - x0)/(fx1 - fx0)
        x0, x1 = x1, x2
        fx0, fx1 = fx1, f(x2)
        
    raise ValueError("Keine Konvergenz")

# Optimierte Version mit Fehlerkontrolle
def secant_safe(f, x0, x1, tol=1e-6, max_iter=100):
    fx0 = f(x0)
    fx1 = f(x1)
    
    if abs(fx0) < abs(fx1):  # Stelle mit kleinerem f-Wert als x1
        x0, x1 = x1, x0
        fx0, fx1 = fx1, fx0
    
    for i in range(max_iter):
        if abs(fx1) < tol:
            return x1, i+1
            
        if fx1 == fx0:
            raise ValueError("Division durch Null")
            
        # Sekanten-Schritt
        d = fx1 * (x1 - x0)/(fx1 - fx0)
        x2 = x1 - d
        
        # Konvergenzpruefungen
        if abs(d) < tol * (1 + abs(x1)):  # Relative Aenderung
            return x2, i+1
            
        fx2 = f(x2)
        if abs(fx2) >= abs(fx1):  # Divergenzcheck
            if i == 0:
                raise ValueError("Schlechte Startwerte")
            return x1, i+1
            
        x0, x1 = x1, x2
        fx0, fx1 = fx1, fx2
        
    raise ValueError("Keine Konvergenz")
\end{lstlisting}
\end{examplecode}




\begin{examplecode}{Nullstellensuche mit Fehlerabschätzung} \\
    Praktische Implementierung
\begin{lstlisting}[language=Python, style=basesmol]
def root_finder_with_error(f, x0, tol=1e-6, max_iter=100):
    x_old = x0
    f_old = f(x_old)
    
    for i in range(max_iter):
        # Iterationsschritt (hier Newton als Beispiel)
        x_new = x_old - f_old/derivative(f, x_old)
        f_new = f(x_new)
        
        # Pruefe Konvergenzkriterien
        converged, reason = convergence_criteria(
            x_new, x_old, f_new, f_old, tol)
            
        if converged:
            # Schaetze finalen Fehler
            error = error_estimate(f, x_new, tol)
            return {
                'root': x_new,
                'iterations': i+1,
                'error_bound': error,
                'convergence_reason': reason
            }
            
        x_old, f_old = x_new, f_new
        
    raise ValueError(f"Keine Konvergenz nach {max_iter} Iterationen")

    # Returns: Dictionary mit Ergebnissen

# Beispielnutzung
def example_function(x):
    return x**2 - 2

result = root_finder_with_error(example_function, 1.0)
print(f"Nullstelle: {result['root']:.10f}")
print(f"Iterationen: {result['iterations']}")
print(f"Fehlerschranke: {result['error_bound']:.10f}")
print(f"Konvergenzgrund: {result['convergence_reason']}")

# Ausgabe etwa:
# Nullstelle: 1.4142135624
# Iterationen: 5
# Fehlerschranke: 1e-06
# Konvergenzgrund: Funktionswert < tol

\end{lstlisting}
\end{examplecode}

\subsection{Numerische Lösung von Gleichungssystemen}

\begin{examplecode}{Gauss-Elimination mit Pivotisierung}
\begin{lstlisting}[language=Python, style=basesmol]
def gauss_elimination(A, b):
    n = len(A)
    # Erweiterte Matrix erstellen
    M = [[A[i][j] for j in range(n)] + [b[i]] for i in range(n)]

    # Vorwaertselimination
    for i in range(n):
        pivot = M[i][i]
        if abs(pivot) < 1e-10:
            continue
        for j in range(i+1, n):
            factor = M[j][i] / pivot
            for k in range(i, n+1):
                M[j][k] -= factor * M[i][k]

    # Rueckwaertssubstitution
    x = [0] * n
    for i in range(n-1, -1, -1):
        if abs(M[i][i]) < 1e-10:
            x[i] = 1  # Freie Variable
            continue
        sum_val = sum(M[i][j] * x[j] for j in range(i+1, n))
        x[i] = (M[i][n] - sum_val) / M[i][i]
    
    return x
\end{lstlisting}    
\end{examplecode}





\begin{examplecode}{LR-Zerlegung Implementation}
\begin{lstlisting}[language=Python, style=basesmol]
def lr_decomposition(A):
    n = len(A)
    # Kopiere A um Original nicht zu veraendern
    R = [[A[i][j] for j in range(n)] for i in range(n)]
    L = [[1.0 if i == j else 0.0 for j in range(n)] for i in range(n)]
    P = [[1.0 if i == j else 0.0 for j in range(n)] for i in range(n)]
    
    for k in range(n-1):
        # Pivotisierung
        pivot = k
        for i in range(k+1, n):
            if abs(R[i][k]) > abs(R[pivot][k]):
                pivot = i
        if abs(R[pivot][k]) < 1e-10:  # Numerische Null
            raise ValueError("Matrix ist (fast) singulaer")
        # Zeilenvertauschung falls noetig
        if pivot != k:
            R[k], R[pivot] = R[pivot], R[k]
            # L und P anpassen fuer Zeilen < k
            for j in range(k):
                L[k][j], L[pivot][j] = L[pivot][j], L[k][j]
            P[k], P[pivot] = P[pivot], P[k]

        # Elimination
        for i in range(k+1, n):
            factor = R[i][k] / R[k][k]
            L[i][k] = factor
            for j in range(k, n):
                R[i][j] -= factor * R[k][j]
               
    return P, L, R
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{QR-Zerlegung Implementation}
\begin{lstlisting}[language=Python, style=basesmol]
def qr_decomposition(A):
    m = len(A)
    n = len(A[0])
    # Kopiere A nach R (deep copy)
    R = [[A[i][j] for j in range(n)] for i in range(m)]
    # Initialisiere Q als Einheitsmatrix
    Q = [[1.0 if i == j else 0.0 for j in range(m)] 
         for i in range(m)]
    
    def vector_norm(v): # Norm eines Vektors
        return (sum(x*x for x in v)) ** 0.5
    
    def matrix_mult(A, B): # Matrixmultiplikation
        m, n = len(A), len(B[0])
        p = len(B)
        C = [[0.0] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                C[i][j] = sum(A[i][k] * B[k][j] 
                             for k in range(p))

        return C
    
    def householder_reflection(x):
        n = len(x)
        v = [xi for xi in x]  # Kopiere x

        # Berechne Norm des Teilvektors
        sigma = sum(v[i]*v[i] for i in range(1, n))
        if sigma == 0 and x[0] >= 0:
            beta = 0
        elif sigma == 0 and x[0] < 0:
            beta = -2
        else:
            mu = (x[0]*x[0] + sigma)**0.5
            if x[0] <= 0:
                v[0] = x[0] - mu
            else:
                v[0] = -sigma/(x[0] + mu)

            beta = 2*v[0]*v[0]/(sigma + v[0]*v[0])

            # Normiere v
            temp = v[0]
            for i in range(n):
                v[i] /= temp

        return v, beta
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{QR-Zerlegung Implementation (Fortsetzung)}
\begin{lstlisting}[language=Python, style=basesmol]
    # Hauptschleife der QR-Zerlegung
    for k in range(n):
        # Extrahiere k-te Spalte ab k-ter Zeile
        x = [R[i][k] for i in range(k, m)]
        if len(x) > 1:  # wenn noch Untermatrix existiert
            # Berechne Householder-Transformation
            v, beta = householder_reflection(x)
            # Wende Householder auf R an
            for j in range(k, n):
                # Berechne w = beta * (v^T * R_j)
                w = beta * sum(v[i-k]*R[i][j] 
                             for i in range(k, m))
                # Update R
                for i in range(k, m):
                    R[i][j] -= v[i-k] * w
            # Update Q
            for j in range(m):
                w = beta * sum(v[i-k]*Q[j][i+k] 
                             for i in range(len(v)))
                for i in range(len(v)):
                    Q[j][k+i] -= v[i] * w
    # Transponiere Q am Ende
    Q = [[Q[j][i] for j in range(m)] for i in range(m)]
    
    return Q, R # Q (orthogonal) und R (obere Dreiecksmatrix)

# Beispiel fuer Verwendung
def solve_qr(A, b): # Loest Ax = b mittels QR-Zerlegung
    Q, R = qr_decomposition(A)
    # Berechne Q^T * b
    y = [sum(Q[i][j] * b[j] 
             for j in range(len(b))) 
         for i in range(len(b))]
    # Rueckwaertseinsetzen
    n = len(R)
    x = [0] * n
    for i in range(n-1, -1, -1):
        s = sum(R[i][j] * x[j] for j in range(i+1, n))
        if abs(R[i][i]) < 1e-10:
            raise ValueError("Matrix (fast) singulaer")
        x[i] = (y[i] - s) / R[i][i]
    return x
\end{lstlisting}
\end{examplecode}

\subsection{Eigenwerte und Eigenvektoren}