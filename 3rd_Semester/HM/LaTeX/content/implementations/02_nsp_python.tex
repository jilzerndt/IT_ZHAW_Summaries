\subsection{Nullstellenprobleme}

\begin{examplecode}{Hilfsfunktionen und Vorbedingungen}
\begin{lstlisting}[language=Python, style=basesmol]
import sympy as sp
import numpy as np
import math

# Vorbedingungen, muss je nach dem angepasst werden
x0 = 1 # Startwert
tolerance = 1e-6 # Toleranz
max_iterations = 100 # Maximale Anzahl an Iterationen

# Funktion definieren
x = sp.symbols('x')
f = 0.5 * 2**x # Funktion
f_der = sp.diff(f, x) # Ableitung der Funktion

# Numerische Ableitung der Funktion 
def numerical_derivative(f, x, epsilon=1e-6):
    return (f(x + epsilon) - f(x - epsilon)) / (2 * epsilon)

# Intervall I = [a, b] festlegen
a, b = 0, 1
I = [a, b]
# Funktionswerte an den Intervallgrenzen
f_I = [f.subs(x, a).evalf(), f.subs(x, b).evalf()] 
f_derivative_I = [f_der.subs(x, a).evalf(), f_der.subs(x, b).evalf()]
\end{examplecode}

\subsubsection{Fixpunktiteration}

\begin{examplecode}{Hilfsfunktionen}
\begin{lstlisting}[language=Python, style=basesmol]
# Lipschitz-Konstante schätzen
def lipschitz(f, a, b):
    return max(abs(val) for val in f_derivative_I)

# Banach'scher Fixpunktsatz überprüfen (F(I) in I)
def banach_fixpoint_theorem(f, a, b):
    if all(a <= val <= b for val in f_I) and (0 < lipschitz(f, a, b) < 1):
        return True

# A-Priori Fehlerabschätzung 
# Maximale Anzahl an Iterationen für gewünschte Genauigkeit (Toleranz)
def a_priori_error_estimate(x0, tolerance):
    return math.log(tolerance / (lipschitz(f, a, b) * abs(x0 - x0))) / math.log(lipschitz(f, a, b))

#A-Posteriori Fehlerabschätzung
def a_posteriori_error_estimate(x, x_next):
    return lipschitz(f, a, b) / (1 - lipschitz(f, a, b)) * abs(x_next - x)
\end{lstlisting}

\textcolor{pink}{tbd} %TODO: Implementierung der Fixpunktiteration
\end{examplecode}

 %TODO: fix and add fehlerabschätzung
\begin{examplecode}{fixed\_point\_iteration} Fixpunktiteration 
\begin{lstlisting}[language=Python, style=basesmol]
def fixed_point_iteration(f, x0, tolerance, max_iterations):
    x = x0 // Startwert
    iterations = 0

    for i in range(max_iterations):
        x_next = f(x)
        error = abs(x_next - x)

        if error < tolerance:
            return x_next, i + 1, error
        x = x_next
    raise ValueError("No convergence")
\end{examplecode}

\subsubsection{Newton-Verfahren}

\begin{examplecode}{newton} Newton-Verfahren mit einer Funktion
\begin{lstlisting}[language=Python, style=basesmol]
def newton(f, x0, tolerance, max_iterations):
    x = x0
    f_der = numerical_derivative(f)  # Numerische Ableitung
    
    for i in range(max_iterations):
        if f_der(x) == 0 or np.isnan(f_der(x)):
            raise ValueError("derivative zero or NaN")
        x_next = x - f(x) / f_der(x)

        if abs(x_next - x) < tolerance:
            return x_next, i + 1
        x = x_next

    return x
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{secant} Sekantenverfahren
\begin{lstlisting}[language=Python, style=basesmol]

    
\end{examplecode}

\subsubsection{Fehlerabschätzung und Konvergenzverhalten}

\begin{examplecode}{error\_estimate} Fehlerabschätzung durch Vorzeichenwechsel
\begin{lstlisting}[language=Python, style=basesmol]
def error_estimate(f, x, eps=1e-5):
    fx_left = f(x - eps)
    fx_right = f(x + eps)
    
    if np.sign(fx_left) != np.sign(fx_right):
        return eps  # Nullstelle liegt in (x-eps, x+eps)
    return None
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{root\_finder\_with\_error}
    Nullstellensuche mit Fehlerabschaetzung
\begin{lstlisting}[language=Python, style=basesmol]
def root_finder_with_error(f, x0, tol=1e-6, max_iter=100):
    x_old = x0
    f_old = f(x_old)
    
    for i in range(max_iter):
        # Iterationsschritt (hier Newton als Beispiel)
        x_new = x_old - f_old/derivative(f, x_old)
        f_new = f(x_new)
        
        # Pruefe Konvergenzkriterien
        converged, reason = convergence_check(
            x_new, x_old, f_new, f_old, tol)
            
        if converged:
            # Schaetze finalen Fehler
            error = error_estimate(f, x_new, tol)
            return {
                'root': x_new,
                'iterations': i+1,
                'error_bound': error,
                'convergence_reason': reason
            }
            
        x_old, f_old = x_new, f_new
        
    raise ValueError(f"Keine Konvergenz nach {max_iter} Iterationen")
\end{lstlisting}
\end{examplecode}