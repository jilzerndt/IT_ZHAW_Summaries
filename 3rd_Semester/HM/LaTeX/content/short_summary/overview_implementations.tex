\section{Übersicht der Implementierungen}

\subsection{Basics}

\begin{KR}{matrix\_vector\_basics.py}
    Grundlegende Matrix- und Vektoroperationen
    \begin{itemize}
        \item \texttt{matrix\_multiply(A, B)} - Multipliziert zwei Matrizen
        \item \texttt{matrix\_subtract(A, B)} - Subtrahiert zwei Matrizen
        \item \texttt{matrix\_add(A, B)} - Addiert zwei Matrizen
        \item \texttt{matrix\_transpose(A)} - Transponiert eine Matrix
        \item \texttt{norm\_vector(v, p=2)} - Berechnet p-Norm eines Vektors
        \item \texttt{norm\_matrix(A, p=2)} - Berechnet Matrixnorm
        \item \texttt{normalize\_vector(v)} - Normalisiert einen Vektor
        \item \texttt{is\_symmetric(A)} - Prüft ob Matrix symmetrisch ist
        \item \texttt{condition\_number(A, p=2)} - Berechnet Konditionszahl
        \item \texttt{plot\_matrix\_heatmap(A, title)} - Visualisiert Matrix als Heatmap
    \end{itemize}
\end{KR}

\begin{KR}{rechnerarithmetik.py}
    Funktionen für Computerarithmetik und Fehleranalyse
    \begin{itemize}
        \item \texttt{is\_close(a, b)} - Prüft Gleichheit mit Toleranz
        \item \texttt{get\_machine\_epsilon()} - Berechnet Maschinengenauigkeit
        \item \texttt{relative\_error(true, approx)} - Berechnet relativen Fehler
        \item \texttt{absolute\_error(true, approx)} - Berechnet absoluten Fehler
        \item \texttt{analyze\_float\_representation(x)} - Analysiert Gleitkommadarstellung
        \item \texttt{plot\_rounding\_errors(f, x\_range)} - Visualisiert Rundungsfehler
    \end{itemize}
\end{KR}

\begin{KR}{plot\_functions.py}
    Plotting-Funktionen für numerische Methoden
    \begin{itemize}
        \item \texttt{plot\_function\_1d(f, x\_range)} - Plot einer 1D-Funktion
        \item \texttt{plot\_convergence(errors)} - Visualisiert Konvergenzverhalten
        \item \texttt{plot\_function\_2d(f, x\_range, y\_range)} - 3D-Plot einer 2D-Funktion
        \item \texttt{plot\_contour(f, x\_range, y\_range)} - Erstellt Konturplot
    \end{itemize}
\end{KR}

\subsection{NSP (Nullstellenprobleme)}

\begin{KR}{newton.py}
    Newton-Verfahren und Varianten
    \begin{itemize}
        \item \texttt{newton\_method(f, df, x0)} - Standardverfahren
        \item \texttt{simplified\_newton(f, df, x0)} - Vereinfachtes Newton-Verfahren
        \item \texttt{damped\_newton(f, df, x0)} - Gedämpftes Newton-Verfahren
        \item \texttt{analyze\_convergence\_order(x\_hist, x\_star)} - Konvergenzanalyse
        \item \texttt{visualize\_newton\_steps(f, df, x0)} - Visualisierung der Iterationen
        \item \texttt{plot\_basins\_of\_attraction(f, df)} - Visualisierung der Einzugsbereiche
    \end{itemize}
\end{KR}

\begin{KR}{secant.py}
    Sekantenverfahren und Varianten
    \begin{itemize}
        \item \texttt{secant\_method(f, x0, x1)} - Standardverfahren
        \item \texttt{regula\_falsi(f, a, b)} - Regula-Falsi-Methode
        \item \texttt{modified\_secant(f, x0)} - Modifiziertes Sekantenverfahren
        \item \texttt{visualize\_secant\_steps(f, x0, x1)} - Visualisierung
        \item \texttt{analyze\_convergence(x\_hist, x\_star)} - Konvergenzanalyse
    \end{itemize}
\end{KR}

\begin{KR}{fixpunktiteration.py}
    Fixpunktiteration und Konvergenzanalyse
    \begin{itemize}
        \item \texttt{fixed\_point\_iteration(g, x0)} - Fixpunktiteration
        \item \texttt{estimate\_lipschitz\_constant(g, x)} - Schätzt Lipschitz-Konstante
        \item \texttt{verify\_banach\_conditions(g, a, b)} - Prüft Banach-Bedingungen
        \item \texttt{fixed\_point\_iteration\_with\_error(g, x0)} - Mit Fehlerabschätzung
        \item \texttt{analyze\_convergence(g, x0, x\_star)} - Konvergenzanalyse
        \item \texttt{plot\_iteration\_process(g, x0)} - Visualisierung
    \end{itemize}
\end{KR}

\begin{KR}{nsp\_fehlerabschatzung.py}
    Fehlerabschätzung für Nullstellenverfahren
    \begin{itemize}
        \item \texttt{verify\_bracket(f, x, epsilon)} - Prüft Einschließung
        \item \texttt{estimate\_error\_bound(f, df, x)} - Schätzt Fehlerschranke
        \item \texttt{compute\_residual(f, x)} - Berechnet Residuum
        \item \texttt{verify\_convergence\_conditions(f, df, x)} - Prüft Konvergenzbedingungen
        \item \texttt{estimate\_working\_precision(f, x)} - Schätzt Arbeitsgenauigkeit
        \item \texttt{track\_error\_convergence(f, df, x0)} - Verfolgt Fehlerentwicklung
    \end{itemize}
\end{KR}

\subsection{LGS (Lineare Gleichungssysteme)}

\begin{KR}{gauss.py}
    Gauß-Eliminationsverfahren
    \begin{itemize}
        \item \texttt{forward\_elimination(A, b)} - Vorwärtselimination
        \item \texttt{back\_substitution(U, y)} - Rückwärtssubstitution
        \item \texttt{gauss\_elimination(A, b)} - Komplettes Gauß-Verfahren
        \item \texttt{compute\_residual(A, x, b)} - Berechnet Residuum
        \item \texttt{estimate\_error(A, x, b)} - Fehlerabschätzung
        \item \texttt{determine\_matrix\_rank(A)} - Bestimmt Matrixrang
        \item \texttt{analyze\_pivoting\_strategies()} - Vergleicht Pivotisierungsstrategien
    \end{itemize}
\end{KR}

\begin{KR}{lr\_comp.py}
    LR-Zerlegung (LU-Zerlegung)
    \begin{itemize}
        \item \texttt{lr\_decomposition(A)} - LR-Zerlegung
        \item \texttt{forward\_substitution(L, b)} - Vorwärtssubstitution
        \item \texttt{back\_substitution(R, y)} - Rückwärtssubstitution
        \item \texttt{solve\_lr(L, R, b)} - Löst System mit LR-Zerlegung
        \item \texttt{compute\_determinant(R)} - Berechnet Determinante
        \item \texttt{invert\_matrix(A)} - Berechnet Inverse
    \end{itemize}
\end{KR}

\begin{KR}{qr\_comp.py}
    QR-Zerlegung und Anwendungen
    \begin{itemize}
        \item \texttt{householder\_vector(x)} - Berechnet Householder-Vektor
        \item \texttt{apply\_householder(A, v, beta)} - Wendet Householder-Transformation an
        \item \texttt{qr\_decomposition(A)} - QR-Zerlegung
        \item \texttt{solve\_qr(A, b)} - Löst System mit QR-Zerlegung
        \item \texttt{least\_squares\_qr(A, b)} - Löst Ausgleichsproblem
    \end{itemize}
\end{KR}

\begin{KR}{iterative.py}
    Iterative Lösungsverfahren
    \begin{itemize}
        \item \texttt{decompose\_matrix(A)} - Zerlegt Matrix (D, L, U)
        \item \texttt{jacobi\_iteration(A, b, x0)} - Jacobi-Verfahren
        \item \texttt{gauss\_seidel\_iteration(A, b, x0)} - Gauß-Seidel-Verfahren
        \item \texttt{sor\_iteration(A, b, x0, omega)} - SOR-Verfahren
        \item \texttt{estimate\_spectral\_radius(A)} - Schätzt Spektralradius
        \item \texttt{check\_convergence\_conditions(A)} - Prüft Konvergenzbedingungen
    \end{itemize}
\end{KR}

\begin{KR}{pivotisierung.py}
    Pivotisierungsstrategien
    \begin{itemize}
        \item \texttt{find\_pivot\_element(A, k, n)} - Findet Pivotelement 
        \item \texttt{swap\_rows(A, b, i, j)} - Tauscht Zeilen
        \item \texttt{swap\_columns(A, i, j)} - Tauscht Spalten
        \item \texttt{PivotingManager} - Klasse zur Verwaltung der Pivotisierung
            \begin{itemize}
                \item \texttt{set\_scaling(A)} - Setzt Skalierungsfaktoren
                \item \texttt{find\_pivot(A, k)} - Findet Pivotelement
                \item \texttt{apply\_pivot(A, b, k)} - Wendet Pivotisierung an
                \item \texttt{get\_permutations()} - Liefert Permutationen
            \end{itemize}
    \end{itemize}
\end{KR}

\begin{KR}{konvergenzcheck.py}
    Konvergenzüberprüfung für iterative Methoden
    \begin{itemize}
        \item \texttt{ConvergenceCriterion} - Enumeration der Konvergenzkriterien
        \item \texttt{ConvergenceChecker} - Prüft Konvergenzkriterien
        \item \texttt{ConvergenceMonitor} - Überwacht Konvergenzverhalten
        \item \texttt{run\_iterative\_method()} - Führt iterative Methode aus
    \end{itemize}
\end{KR}

\subsection{EW\_EV (Eigenwerte \& Eigenvektoren)}

\begin{KR}{ew\_matrix.py}
    Matrixoperationen für Eigenwertberechnung
    \begin{itemize}
        \item \texttt{identity\_matrix(n)} - Erstellt Einheitsmatrix
        \item \texttt{scalar\_matrix(n, scalar)} - Erstellt Skalarmatrix
        \item \texttt{is\_symmetric(A)} - Prüft Symmetrie
        \item \texttt{is\_positive\_definite(A)} - Prüft positive Definitheit
        \item \texttt{determinant(A)} - Berechnet Determinante
        \item \texttt{trace(A)} - Berechnet Spur
        \item \texttt{characteristic\_polynomial(A, lambda)} - Charakteristisches Polynom
        \item \texttt{gerschgorin\_circles(A)} - Berechnet Gerschgorin-Kreise
    \end{itemize}
\end{KR}

\begin{KR}{complex\_numbers.py}
    Komplexe Zahlen für Eigenwertberechnungen
    \begin{itemize}
        \item \texttt{Complex} - Klasse für komplexe Zahlen
            \begin{itemize}
                \item Grundoperationen (+, -, *, /)
                \item \texttt{conjugate()} - Konjugiert komplexe Zahl
                \item \texttt{abs()} - Berechnet Betrag
                \item \texttt{arg()} - Berechnet Argument
                \item \texttt{to\_polar()} - Konvertiert in Polarform
            \end{itemize}
        \item \texttt{roots\_of\_unity(n)} - Berechnet Einheitswurzeln
        \item \texttt{solve\_quadratic(a, b, c)} - Löst quadratische Gleichung
        \item \texttt{matrix\_eigenvalues(A)} - Schätzt Eigenwerte
    \end{itemize}
\end{KR}

\begin{KR}{iterations.py}
    Iterative Methoden für Eigenwertberechnung
    \begin{itemize}
        \item \texttt{power\_iteration\_with\_deflation()} - Potenzmethode mit Deflation
        \item \texttt{inverse\_iteration\_with\_shifts()} - Inverse Iteration
        \item \texttt{qr\_algorithm\_basic()} - QR-Algorithmus (Basis)
        \item \texttt{qr\_algorithm\_with\_shifts()} - QR mit Wilkinson-Shifts
        \item \texttt{simultaneous\_iteration()} - Simultane Iteration
    \end{itemize}
\end{KR}