\section{Design Patterns}

\section*{8 Vorlesung 08}
\subsection*{8.1 Allgemeiner Aufbau u Zweck von Design Pattern (DP)}
\begin{itemize}
  \item bewährte Lösungen f wiederkehrende Probleme schnell finden
  \item effiziente Kommunikation
  \item immer tradeoff zw. Flexibilität u Kompatibilität
  \item Programm wird nicht besser mit DP
\end{itemize}

\subsection*{8.1.1 Adapter}
Ermöglicht die Zusammenarbeit von Objekten mit inkompatiblen Schnittstellen. (Überall wo Dienste angesprochen werden, die austauschbar sein sollten)

\subsection*{8.1.2 Simple Factory}
(eigene Klasse) erstellt Objekte, die aufwändig zu erzeugen sind

\subsection*{8.1.3 Singleton}
Stellt sicher, dass eine Klasse nur eine Instanz hat und einen globalen Zugriffspunkt darauf bereitstellt.

\subsection*{8.1.4 Dependency Injection}
Ermöglicht es, einem abhängigen Objekt die benötigten Abhängigkeiten bereitzustellen. (Ersatz f Facotry Pattern)

\subsection*{8.1.5 Proxy}
Bietet einen Platzhalter (mit demselben Interface) für ein anderes Objekt, um den Zugriff darauf zu kontrollieren. Proxy Objekt leitet alle Methodenaufrufe zum richtigen Objekt weiter

\begin{itemize}
  \item Remote Proxy: Stellvertreter für ein Objekt in einem anderen Adressraum und übernimmt die Kommunikation mit diesem.
  \item Virtual Proxy: Verzögert das Erzeugen des richtigen Objekts bis zum ersten Mal, dass es benutzt wird.
  \item Protection Proxy: Kontrolliert den Zugriff auf das richtige Objekt.
\end{itemize}

\subsection*{8.1.6 Chain of Responsibility}
Ermöglicht es einem Objekt, eine Anfrage entlang einer Kette potenzieller Handler zu senden, bis einer die Anfrage behandelt. (wenn unklar im vorraus welcher Handler zuständig sein wird)

\section*{9 Vorlesung 09}
\subsection*{9.1 Decorator}
\subsection*{9.1.1 Problem}
Ein Objekt (nicht eine ganze Klasse) soll mit zusätzlichen Verantwortlichkeiten versehen werden.

\subsection*{9.1.2 Solution}
Ein Decorator, der dieselbe Schnittstelle hat wie das ursprüngliche Objekt, wird vor dieses geschaltet. Der Decorator kann nun jeden Methodenaufruf entweder selber bearbeiten, ihn an das ursprüngliche Objekt weiterleiten oder eine Mischung aus beidem machen.

\subsection*{9.2 Observer}
\subsection*{9.2.1 Problem}
Ein Objekt soll ein anderes Objekt benachrichtigen, ohne dass es den genauen Typ des Empfängers kennt.

\subsection*{9.2.2 Solution}
Ein Interface wird definiert, das nur dazu dient, ein Objekt über eine Änderung zu informieren. Dieses Interface wird vom «Observer» implementiert. Das\\
«Observable» Objekt benachrichtigt alle registrierten «Observer» über eine Änderung.

\subsection*{9.3 Strategy}
\subsection*{9.3.1 Problem}
Ein Algorithmus soll einfach austauschbar sein.

\subsection*{9.3.2 Solution}
Den Algorithmus in eine eigene Klasse verschieben, die nur eine Methode mit diesem Algorithmus hat.\\
Ein Interface für diese Klasse definieren, das von alternativen Algorithmen implementiert werden muss

\subsection*{9.4 Composite}
\subsection*{9.4.1 Problem}
Eine Menge von Objekten haben dasselbe Interface und müssen für viele Verantwortlichkeiten als Gesamtheit betrachtet werden.

\subsection*{9.4.2 Solution}
Sie definieren ein Composite, das ebenfalls dasselbe Interface implementiert und Methoden an die darin enthaltenen Objekte weiterleitet

\subsection*{9.5 State}
\subsection*{9.5.1 Problem}
Das Verhalten eines Objekts ist abhängig von seinem inneren Zustand.

\subsection*{9.5.2 Solution}
Das Objekt hat ein darin enthaltenes Zustandsobjekt.\\
Alle Methoden, deren Verhalten vom Zustand abhängig sind, werden über das Zustandsobjekt geführt.

\subsection*{9.6 Visitor}
\subsection*{9.6.1 Problem}
Eine Klassenhierarchie soll um (weniger wichtige) Verantwortlichkeiten erweitert werden, ohne dass viele neue Methoden hinzukommen.

\subsection*{9.6.2 Solution}
Die Klassenhierarchie wird mit einer Visitor-Infrastruktur erweitert. Alle weiteren neuen Verantwortlichkeiten werden dann mit spezifischen VisitorKlassen realisiert.

\subsection*{9.7 Facade}
\subsection*{9.7.1 Problem}
Sie setzen ein ziemlich kompliziertes Subsystem mit vielen Klassen ein. Wie können Sie seine Verwendung so vereinfachen, dass alle Team-Mitglieder es korrekt und einfach verwenden können?

\subsection*{9.7.2 Solution}
Eine Facade (Fassade) Klasse wird definiert, welche eine vereinfachte Schnittstelle zum Subsystem anbietet und die meisten Anwendungen abdeckt.

\subsection*{9.8 Abstract Factory}
\subsection*{9.8.1 Problem}
Sie müssen verschiedene, aber verwandte Objekte erstellen, ohne ihre konkreten Klassen anzugeben. Wie können Sie die Erstellung der Objektfamilien zentralisieren und von ihrer konkreten Implementierung abstrahieren?

\subsection*{9.8.2 Solution}
Das Abstract Factory Muster definiert eine Schnittstelle zur Erstellung von Familien verwandter oder abhängiger Objekte, ohne ihre konkreten Klassen zu benennen. Es bietet Methoden, um Objekte der verschiedenen Produktfamilien\\
zu erstellen, und ermöglicht es, ganze Produktfamilien konsistent zu verwenden.

\subsection*{9.9 Factory Method}
\subsection*{9.9.1 Problem}
Es gibt eine Oberklasse, aber die genauen Unterklassen sollen durch eine spezielle Logik zur Laufzeit bestimmt werden. Wie können Sie die Instanziierung dieser Klassen so gestalten, dass sie flexibel und erweiterbar bleibt?

\subsection*{9.9.2 Solution}
Das Factory Method Muster definiert eine Schnittstelle zur Erstellung eines Objekts, lässt aber die Unterklassen entscheiden, welche Klasse instanziiert wird. Dadurch wird die Erstellung der Objekte auf Unterklassen delegiert, wodurch die Klasse flexibler und erweiterbar wird.

\subsection*{9.10 Command}
\subsection*{9.10.1 Problem}
Sie müssen eine Anforderung in Form eines Objekts kapseln, um parameterisierte Clients, Warteschlangen oder Log-Requests sowie Operationen rückgängig machen zu können. Wie können Sie dies strukturieren?

\subsection*{9.10.2 Solution}
Das Command Muster kapselt eine Anforderung als Objekt, wodurch Sie Parameter für Clients, Warteschlangen oder Log-Requests einfügen und Operationen rückgängig machen können. Es besteht aus einem Kommando-Objekt, das eine bestimmte Aktion mit ihren Parametern, Empfänger und eventuell einer Methode zur Rückgängigmachung enthält.

\subsection*{9.11 Template Method}
\subsection*{9.11.1 Problem}
In einer Methode einer Oberklasse gibt es einige Schritte, die in Unterklassen unterschiedlich implementiert werden sollen, während die Struktur der Methode erhalten bleiben muss. Wie können Sie die Schritte anpassbar machen?

\subsection*{9.11.2 Solution}
Das Template Method Muster definiert das Skelett eines Algorithmus in einer Methode, wobei einige Schritte von Unterklassen implementiert werden. Es ermöglicht Unterklassen, bestimmte Schritte des Algorithmus zu überschreiben, ohne die Struktur des Algorithmus zu verändern.
