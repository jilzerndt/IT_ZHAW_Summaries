\section{Implementation, Refactoring und Testing}

\section*{10 Vorlesung 10}
\subsection*{10.1 Quellcode aus Design Artefakten ableiten}
\subsection*{10.1.1 Umsetzungs-Reihenfolge: Variante Bottom-Up}
Kurze Erklärung: Implementierung beginnt mit Basisbausteinen, die schrittweise zu größeren Teilen kombiniert werden.\\
Vorgehen: Start mit Basisfunktionalitäten, dann schrittweise Erweiterung und Integration.\\
Eigenschaften: Gründlich, bietet solide Basis, gut für sich ändernde Anforderungen.

\subsection*{10.1.2 Umsetzungs-Reihenfolge: Variante Agile}
Kurze Erklärung: Flexible, inkrementelle Entwicklung in kurzen Iterationen. Vorgehen: Kontinuierliche Lieferung funktionsfähiger Teile in Sprints, Anpassung an sich ändernde Anforderungen.\\
Eigenschaften: Hohe Flexibilität, schnelles Feedback, geeignet für sich ändernde Anforderungen.

\subsection*{10.2 Codier-Richtlinien}
\section*{Abmachung für:}
\begin{itemize}
  \item Fehlerbehandlung
  \item Codierrichtlinien (Gross/Kleinschreibung, Einrücken, Klammernsetzung, Prüf programme)
  \item Namensgebung f. Klasse, Attribute, Methoden, Variablen
\end{itemize}

\subsection*{10.3 Implementierungs- / Umsetzungsstrategie}
\section*{Code-Driven Development}
\begin{itemize}
  \item Zuerst die Klasse implementieren
\end{itemize}

\section*{TDD: Test-Driven Development}
\begin{itemize}
  \item Zuerst Tests für Klassen/Komponenten schreiben, dann den Code entwickeln
\end{itemize}

\section*{BDD: Behavior-Driven Development}
\begin{itemize}
  \item Tests aus Benutzersicht beschreiben
  \item Zum Beispiel durch die Business Analysten mit Hilfe von Gherkin
\end{itemize}

\subsection*{10.4 Laufzeit Optimierung, Optimierungsregeln}
\begin{itemize}
  \item Optimiere nicht sofort, sondern analysiere zuerst, wo Zeit tatsächlich verbraucht wird.
  \item Verwende Performance-Monitoring-Tools, um Zeitfresser zu identifizieren.
  \item Besonders kritisch sind Datenbankzugriffe pro Objekt über eine Liste.
  \item Überprüfe und optimiere Algorithmen, z.B. Collections.sort() in Java 7.
  \item Bedenke, dass moderne Compiler bereits viel Optimierung leisten.
  \item Ziehe Berechnungen aus Schleifen heraus, da die Java VM und Just-In-Time-Compilation diese optimieren.
\end{itemize}

\subsection*{10.5 Refactoring}
Definition: Strukturierte Methode zum Umstrukturieren vorhandenen Codes, ohne das externe Verhalten zu ändern. Ziele:

\begin{itemize}
  \item Verbesserung der internen Struktur durch viele kleine Schritte.
  \item Trennung vom eigentlichen Entwicklungsprozess.
  \item Verbesserung des Low-Level-Designs und der Programmierpraktiken.
\end{itemize}

\section*{Methoden zur Code-Verbesserung:}
\begin{itemize}
  \item DRY: Vermeidung von dupliziertem Code.
  \item Klare Namensgebung für erhöhte Lesbarkeit.
  \item Aufteilung langer Methoden in kleinere, klar definierte Teile.
  \item Strukturierung von Algorithmen in Initialisierung, Berechnung und Ergebnisverarbeitung.
  \item Verbesserung der Sichtbarkeit und Testbarkeit.
\end{itemize}

Code Smells:

\begin{itemize}
  \item Duplizierter Code
  \item Lange Methoden
  \item Klassen mit vielen Instanzvariablen oder viel Code
  \item Auffällig ähnliche Unterklassen
  \item Fehlen von Interfaces oder hohe Kopplung zwischen Klassen
\end{itemize}

\section*{Unterstützung durch:}
\begin{itemize}
  \item Automatisierte Tests zur Sicherstellung der Funktionsfähigkeit nach Refactoring.
  \item Moderne Entwicklungsumgebungen, die abhängige Arbeitsschritte automatisieren.
\end{itemize}

\section*{Refactoring Patterns:}
\begin{itemize}
  \item Umbenennung von Methoden, Klassen und Variablen für klarere Bezeichnungen.
  \item Verschieben von Methoden in Super- oder Subklassen.
  \item Extrahieren von Teilfunktionen in separate Methoden oder Konstanten.
  \item Einführung erklärender Variablen zur Verbesserung der Lesbarkeit.
\end{itemize}

\subsection*{10.6 Testing}
\subsection*{10.6.1 Grundlegende Testarten}
\begin{itemize}
  \item Funktionaler Test (Black-Box Verfahren): Überprüft die Funktionalität des Systems, ohne den internen Code zu kennen.
  \item Nicht funktionaler Test (Lasttest etc.): Testet nicht-funktionale Anforderungen wie Leistung, Skalierbarkeit, usw.
  \item Strukturbezogener Test (White-Box Verfahren): Überprüft die interne Struktur des Codes, um sicherzustellen, dass alle Pfade abgedeckt sind.
  \item Änderungsbezogener Test (Regressionstest etc.): Überprüft, ob durch Änderungen im Code keine neuen Fehler eingeführt wurden.
  \item Integrationstest
  \item Systemtest
  \item Abnahmetest
  \item Regressionstest
\end{itemize}

\subsection*{10.6.2 Wichtige Begriffe}
\begin{itemize}
  \item Testling, Testobjekt: Objekt, das getestet wird
  \item Fehler: Fehler, den der Entwickler macht
  \item Fehlerwirkung, Bug: Jedes Verhalten, das von den Spezifikationen abweicht
  \item Testfall: Satz von Testdaten zur vollständigen Ausführung eines Tests
  \item Testtreiber: Programm, das den Test startet und ausführt
\end{itemize}

\subsection*{10.6.3 Merkmale}
Was wird getestet?

\begin{itemize}
  \item Einheit / Klasse (Unit-Test)
  \item Zusammenarbeit mehrerer Klassen
  \item Gesamte Applikationslogik (ohne UI)
  \item Gesamte Anwendung (über UI)
\end{itemize}

Wie wird getestet?

\begin{itemize}
  \item Dynamisch: Testfall wird ausgeführt (Black-Box / White-Box Test)
  \item Statisch: Quelltext wird analysiert (Walkthrough, Review, Inspektion)
\end{itemize}

\section*{Wann wird der Test geschrieben?}
\begin{itemize}
  \item Vor dem Implementieren (Test-Driven Development, TDD)
  \item Nach dem Implementieren
\end{itemize}

\section*{Wer testet?}
\begin{itemize}
  \item Entwickler
  \item Tester, Qualitätssicherungsabteilung
  \item Kunde, Endbenutzer
\end{itemize}