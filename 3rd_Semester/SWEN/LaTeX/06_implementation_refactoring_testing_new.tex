\section{Implementation, Refactoring und Testing}

\subsection{Von Design zu Code}

\begin{concept}{Implementierungsstrategien}\\
\textbf{1. Bottom-Up Entwicklung:}
\begin{itemize}
    \item Implementierung beginnt mit Basisbausteinen
    \item Schrittweise Integration zu größeren Komponenten
    \item \textbf{Vorteile:} Gründlich, solide Basis
    \item \textbf{Nachteile:} Spätes Feedback
\end{itemize}

\textbf{2. Agile Entwicklung:}
\begin{itemize}
    \item Inkrementelle Entwicklung in Sprints
    \item Kontinuierliche Integration und Auslieferung
    \item \textbf{Vorteile:} Flexibilität, schnelles Feedback
    \item \textbf{Nachteile:} Mögliche Restrukturierung nötig
\end{itemize}
\end{concept}

\begin{definition}{Entwicklungsansätze}\\
\textbf{Code-Driven Development (CDD):}
\begin{itemize}
    \item Direkte Implementierung der Klassen
    \item Nachträgliches Testing
\end{itemize}

\textbf{Test-Driven Development (TDD):}
\begin{itemize}
    \item Tests vor Implementation
    \item Red-Green-Refactor Zyklus
\end{itemize}

\textbf{Behavior-Driven Development (BDD):}
\begin{itemize}
    \item Testbeschreibung aus Anwendersicht
    \item Gherkin-Syntax für Szenarios
\end{itemize}
\end{definition}

\begin{KR}{Clean Code}\\
\textbf{1. Code-Guidelines:}
\begin{itemize}
    \item Einheitliche Formatierung
    \item Klare Namenskonventionen
    \item Dokumentationsrichtlinien
\end{itemize}

\textbf{2. Fehlerbehandlung:}
\begin{itemize}
    \item Exceptions statt Fehlercodes
    \item Sinnvolle Error Messages
    \item Logging-Strategie
\end{itemize}

\textbf{3. Namensgebung:}
\begin{itemize}
    \item Aussagekräftige Namen
    \item Konsistente Begriffe
    \item Domain-Driven Naming
\end{itemize}
\end{KR}

\begin{concept}{Laufzeit-Optimierung}\\
\textbf{Grundregeln:}
\begin{itemize}
    \item Zuerst messen, dann optimieren
    \item Performance-Profile nutzen
    \item Bottlenecks identifizieren
\end{itemize}

\textbf{Häufige Probleme:}
\begin{itemize}
    \item Datenbank-Zugriffe
    \item Ineffiziente Algorithmen
    \item Speicherlecks
\end{itemize}
\end{concept}

\subsection{Refactoring}

\begin{definition}{Refactoring Grundlagen}\\
Strukturierte Verbesserung des Codes ohne Änderung des externen Verhaltens:
\begin{itemize}
    \item Kleine, kontrollierte Schritte
    \item Erhaltung der Funktionalität
    \item Verbesserung der Codequalität
\end{itemize}
\end{definition}

\begin{KR}{Refactoring Durchführung}\\
\textbf{1. Code Smells identifizieren:}
\begin{itemize}
    \item Duplizierter Code
    \item Lange Methoden
    \item Große Klassen
    \item Hohe Kopplung
\end{itemize}

\textbf{2. Refactoring durchführen:}
\begin{itemize}
    \item Tests sicherstellen
    \item Änderungen vornehmen
    \item Tests ausführen
\end{itemize}

\textbf{3. Patterns anwenden:}
\begin{itemize}
    \item Extract Method
    \item Move Method
    \item Rename
    \item Introduce Variable
\end{itemize}
\end{KR}

\begin{example}{Extract Method Refactoring}\\
\textbf{Vorher:}
\begin{lstlisting}[language=Java, style=base]
void printOwing() {
    printBanner();
    
    // calculate outstanding
    double outstanding = 0.0;
    for (Order order : orders) {
        outstanding += order.getAmount();
    }
    
    // print details
    System.out.println("name: " + name);
    System.out.println("amount: " + outstanding);
}
\end{lstlisting}

\textbf{Nachher:}
\begin{lstlisting}[language=Java, style=base]
void printOwing() {
    printBanner();
    double outstanding = calculateOutstanding();
    printDetails(outstanding);
}

double calculateOutstanding() {
    double result = 0.0;
    for (Order order : orders) {
        result += order.getAmount();
    }
    return result;
}

void printDetails(double outstanding) {
    System.out.println("name: " + name);
    System.out.println("amount: " + outstanding);
}
\end{lstlisting}
\end{example}

\subsection{Testing}

\begin{definition}{Testarten}\\
\textbf{Nach Sicht:}
\begin{itemize}
    \item \textbf{Black-Box:} Funktionaler Test ohne Codekenntnis
    \item \textbf{White-Box:} Strukturbezogener Test mit Codekenntnis
\end{itemize}

\textbf{Nach Umfang:}
\begin{itemize}
    \item \textbf{Unit-Tests:} Einzelne Komponenten
    \item \textbf{Integrationstests:} Zusammenspiel
    \item \textbf{Systemtests:} Gesamtsystem
    \item \textbf{Akzeptanztests:} Kundenanforderungen
\end{itemize}
\end{definition}

\begin{KR}{Testentwicklung}\\
\textbf{1. Testfall definieren:}
\begin{itemize}
    \item Vorbedingungen festlegen
    \item Testdaten vorbereiten
    \item Erwartetes Ergebnis definieren
\end{itemize}

\textbf{2. Test implementieren:}
\begin{itemize}
    \item Setup vorbereiten
    \item Testlogik schreiben
    \item Assertions definieren
\end{itemize}

\textbf{3. Test ausführen:}
\begin{itemize}
    \item Automatisiert ausführen
    \item Ergebnisse prüfen
    \item Dokumentation erstellen
\end{itemize}
\end{KR}

\begin{example}{Unit Test}\\
\textbf{Zu testende Klasse:}
\begin{lstlisting}[language=Java, style=base]
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
\end{lstlisting}

\textbf{Test:}
\begin{lstlisting}[language=Java, style=base]
@Test
public class CalculatorTest {
    private Calculator calc;
    
    @Before
    public void setup() {
        calc = new Calculator();
    }
    
    @Test
    public void testAdd() {
        assertEquals(4, calc.add(2, 2));
        assertEquals(0, calc.add(-2, 2));
        assertEquals(-4, calc.add(-2, -2));
    }
}
\end{lstlisting}
\end{example}

\begin{example}{BDD Test}\\
\textbf{Feature File:}
\begin{lstlisting}[style=basesmol]
Feature: Calculator Addition
  Scenario: Add two positive numbers
    Given I have a calculator
    When I add 2 and 2
    Then the result should be 4
    
  Scenario: Add positive and negative numbers
    Given I have a calculator
    When I add -2 and 2
    Then the result should be 0
\end{lstlisting}

\textbf{Step Definitions:}
\begin{lstlisting}[language=Java, style=base]
public class CalculatorSteps {
    private Calculator calc;
    private int result;
    
    @Given("I have a calculator")
    public void createCalculator() {
        calc = new Calculator();
    }
    
    @When("I add {int} and {int}")
    public void addNumbers(int a, int b) {
        result = calc.add(a, b);
    }
    
    @Then("the result should be {int}")
    public void checkResult(int expected) {
        assertEquals(expected, result);
    }
}
\end{lstlisting}
\end{example}
