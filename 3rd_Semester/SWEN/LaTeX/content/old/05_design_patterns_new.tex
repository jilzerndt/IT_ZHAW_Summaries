\section{Design Patterns}

\begin{concept}{Grundlagen Design Patterns}\\
Bewährte Lösungsmuster für wiederkehrende Probleme:
\begin{itemize}
    \item Beschleunigen Entwicklung durch vorgefertigte Lösungen
    \item Verbessern Kommunikation im Team
    \item Bieten Balance zwischen Flexibilität und Komplexität
    \item \textbf{Wichtig:} Design Patterns sind kein Selbstzweck
\end{itemize}
\end{concept}

\subsection{Grundlegende Design Patterns}

\begin{definition}{Adapter Pattern}\\
\textbf{Problem:} Inkompatible Schnittstellen
\begin{itemize}
    \item Objekte mit unterschiedlichen Interfaces sollen zusammenarbeiten
    \item Externe Dienste sollen austauschbar sein
\end{itemize}
\textbf{Lösung:} Adapter-Klasse als Vermittler
\end{definition}

\begin{definition}{Simple Factory Pattern}\\
\textbf{Problem:} Komplexe Objekterzeugung
\begin{itemize}
    \item Objekterzeugung erfordert viele Schritte
    \item Konfiguration bei Erzeugung notwendig
\end{itemize}
\textbf{Lösung:} Eigene Klasse für Objekterzeugung
\end{definition}

\begin{definition}{Singleton Pattern}\\
\textbf{Problem:} Genau eine Instanz benötigt
\begin{itemize}
    \item Globaler Zugriffspunkt notwendig
    \item Mehrfachinstanzierung verhindern
\end{itemize}
\textbf{Lösung:} Statische Instanz mit privater Erzeugung
\end{definition}

\begin{definition}{Dependency Injection Pattern}\\
\textbf{Problem:} Abhängigkeiten zu anderen Objekten
\begin{itemize}
    \item Lose Kopplung erwünscht
    \item Flexibilität bei Abhängigkeiten
\end{itemize}
\textbf{Lösung:} Abhängigkeiten werden von außen injiziert
\end{definition}

\begin{definition}{Proxy Pattern}\\
\textbf{Problem:} Zugriffskontrolle auf Objekte
\begin{itemize}
    \item Verzögertes Laden
    \item Zugriffsbeschränkungen
    \item Netzwerkkommunikation
\end{itemize}
\textbf{Lösung:} Stellvertreterobjekt mit gleichem Interface
\begin{itemize}
    \item \textbf{Remote Proxy:} Für entfernte Objekte
    \item \textbf{Virtual Proxy:} Für spätes Laden
    \item \textbf{Protection Proxy:} Für Zugriffsschutz
\end{itemize}
\end{definition}

\begin{definition}{Chain of Responsibility Pattern}\\
\textbf{Problem:} Unklare Zuständigkeit für Anfragen
\begin{itemize}
    \item Mehrere mögliche Handler
    \item Zuständigkeit erst zur Laufzeit klar
\end{itemize}
\textbf{Lösung:} Verkettete Handler-Objekte
\end{definition}

\subsection{Erweiterte Design Patterns}

\begin{definition}{Decorator Pattern}\\
\textbf{Problem:} Dynamische Erweiterung von Objekten
\begin{itemize}
    \item Zusätzliche Verantwortlichkeiten
    \item Nur für einzelne Objekte
\end{itemize}
\textbf{Lösung:} Wrapper-Objekt mit gleichem Interface
\end{definition}

\begin{definition}{Observer Pattern}\\
\textbf{Problem:} Abhängige Objekte aktualisieren
\begin{itemize}
    \item Lose Kopplung erwünscht
    \item Typ des Empfängers unbekannt
\end{itemize}
\textbf{Lösung:} Observer-Interface für Benachrichtigungen
\end{definition}

\begin{definition}{Strategy Pattern}\\
\textbf{Problem:} Austauschbare Algorithmen
\begin{itemize}
    \item Verschiedene Implementierungen
    \item Zur Laufzeit wechselbar
\end{itemize}
\textbf{Lösung:} Interface für Algorithmus-Klassen
\end{definition}

\begin{definition}{Composite Pattern}\\
\textbf{Problem:} Baumstrukturen verwalten
\begin{itemize}
    \item Einheitliche Behandlung
    \item Teil-Ganzes Hierarchie
\end{itemize}
\textbf{Lösung:} Gemeinsames Interface für Container und Inhalt
\end{definition}

\begin{KR}{Design Pattern Auswahl}\\
\textbf{Schritt 1: Problem analysieren}
\begin{itemize}
    \item Art des Problems identifizieren
    \item Anforderungen klar definieren
    \item Kontext verstehen
\end{itemize}

\textbf{Schritt 2: Pattern evaluieren}
\begin{itemize}
    \item Passende Patterns suchen
    \item Vor- und Nachteile abwägen
    \item Komplexität bewerten
\end{itemize}

\textbf{Schritt 3: Implementation planen}
\begin{itemize}
    \item Klassenstruktur entwerfen
    \item Schnittstellen definieren
    \item Anpassungen vornehmen
\end{itemize}
\end{KR}


