\section{Use Case Realization} 

\begin{concept}{Use Case Realization}\\
Die Umsetzung von Use Cases erfolgt durch:
\begin{itemize}
    \item Detaillierte Szenarien aus den Use Cases
    \item Systemantworten müssen realisiert werden
    \item UI statt System im SSD
    \item Systemoperationen sind die zu implementierenden Elemente
\end{itemize}
\end{concept}

\begin{theorem}{Use Case Realization Ziele}
\begin{itemize}
    \item Umsetzung der fachlichen Anforderungen in Code
    \item Einhaltung der Architekturvorgaben
    \item Implementierung der GRASP-Prinzipien
    \item Erstellung wartbaren und testbaren Codes
    \item Dokumentation der Design-Entscheidungen
\end{itemize}
\end{theorem}

\begin{definition}{Verantwortlichkeiten (Responsibilities)}
Im objektorientierten Design unterscheiden wir zwei Arten von Verantwortlichkeiten:

\textbf{Doing-Verantwortlichkeiten:}
\begin{itemize}
    \item Selbst etwas tun
    \item Aktionen anderer Objekte anstoßen
    \item Aktivitäten anderer Objekte kontrollieren
\end{itemize}

\textbf{Knowing-Verantwortlichkeiten:}
\begin{itemize}
    \item Private eingekapselte Daten kennen
    \item Verwandte Objekte kennen
    \item Dinge berechnen/ableiten können
\end{itemize}
\end{definition}

\begin{concept}{Architekturbezogene Aspekte}
Bei der Use Case Realization müssen folgende architektonische Aspekte beachtet werden:

\textbf{Schichtenarchitektur:}
\begin{itemize}
    \item Presentation Layer (UI)
    \item Application Layer (Use Cases)
    \item Domain Layer (Business Logic)
    \item Infrastructure Layer (Persistence, External Services)
\end{itemize}

\textbf{Abhängigkeitsregeln:}
\begin{itemize}
    \item Abhängigkeiten nur nach unten
    \item Interfaces für externe Services
    \item Dependency Injection für lose Kopplung
\end{itemize}

\textbf{Cross-Cutting Concerns:}
\begin{itemize}
    \item Logging
    \item Security
    \item Transaction Management
    \item Exception Handling
\end{itemize}
\end{concept}





\subsubsection{Vorgehen bei der Use Case Realization}

\begin{concept}{Einfluss der Analyse-Artefakte}
\begin{itemize}
    \item \textbf{Use Cases:}
    \begin{itemize}
        \item Standardszenario
        \item Erweiterungen
        \item Definiert Systemoperationen
    \end{itemize}
    \item \textbf{Systemverträge:}
    \begin{itemize}
        \item Definieren Vorbedingungen
        \item Definieren Nachbedingungen
        \item Legen Invarianten fest
    \end{itemize}
    \item \textbf{Domänenmodell:}
    \begin{itemize}
        \item Inspiriert Softwareklassen
        \item Definiert Attribute
        \item Zeigt Beziehungen auf
    \end{itemize}
\end{itemize}
\end{concept}

\begin{KR}{Vorgehen bei der Use Case Realization}\\
\textbf{1. Vorbereitung:}
\begin{itemize}
    \item Use Case auswählen und SSD ableiten
    \item Systemoperation identifizieren
    \item Operation Contract erstellen/prüfen
\end{itemize}

\textbf{2. Analyse:}
\begin{itemize}
    \item Aktuellen Code/Dokumentation analysieren
    \item DCD überprüfen/aktualisieren
    \item Vergleich mit Domänenmodell
    \item Neue Klassen gemäß Domänenmodell erstellen
\end{itemize}

\textbf{3. Realisierung:}
\begin{itemize}
    \item Controller Klasse bestimmen
    \item Zu verändernde Klassen festlegen
    \item Weg zu diesen Klassen festlegen:
    \begin{itemize}
        \item Parameter für Wege definieren
        \item Klassen bei Bedarf erstellen
        \item Verantwortlichkeiten zuweisen
        \item Verschiedene Varianten evaluieren
    \end{itemize}
    \item Veränderungen implementieren
    \item Review durchführen
\end{itemize}
\end{KR}

\begin{corollary}{Use Case Realization Dokumentation}\\
\textbf{1. Analysephase}
\begin{itemize}
    \item Use Case und Systemoperationen dokumentieren
    \item Domänenmodell-Ausschnitt zeigen
    \item Relevante Anforderungen auflisten
\end{itemize}

\textbf{2. Design}
\begin{itemize}
    \item Design Class Diagram erstellen
    \item Sequenzdiagramme für komplexe Abläufe
    \item GRASP-Prinzipien begründen
\end{itemize}

\textbf{3. Implementation}
\begin{itemize}
    \item Code-Struktur dokumentieren
    \item Wichtige Algorithmen erläutern
    \item Test-Strategie beschreiben
\end{itemize}
\end{corollary}

\subsection{Design und Implementation}

\begin{concept}{UML im Design-Prozess}
UML dient als:
\begin{itemize}
    \item Zwischenschritt bei wenig Erfahrung
    \item Kompakter Ersatz für Programmiercode
    \item Kommunikationsmittel (auch für Nicht-Techniker)
\end{itemize}

\textbf{Arten der Modellierung:}
\begin{itemize}
    \item \textbf{Statische Modelle:} Klassenstruktur
    \item \textbf{Dynamische Modelle:} Verhalten
\end{itemize}
\end{concept}

\begin{KR}{Design to Code}\\
\textbf{Aus Design-Klassen-Diagramm (DCD):}
\begin{itemize}
    \item Klassen und deren Attribute
    \item Methoden und deren Signaturen
    \item Beziehungen zwischen Klassen
\end{itemize}

\textbf{Aus Interaktionsdiagrammen: (SSD):}
\begin{itemize}
    \item Methodenaufrufe
    \item Parameter
    \item Sequenz der Aufrufe
\end{itemize}
\end{KR}

\begin{concept}{System Sequence Diagrams (SSD)}
    %todo ADD
\end{concept}

\begin{KR}{System Sequence Diagrams (SSD) erstellen}
    %todo ADD
\end{KR}


\begin{example2}{Interaction Diagrams in der Use Case Realization}\\
    %todo ADD a better one
\textbf{Sequenzdiagramm für enterItem():}

\begin{lstlisting}[language=Java, style=basesmol]
:Register -> :ProductCatalog: getDescription(itemId)
:ProductCatalog --> :Register: desc
:Register -> currentSale: makeLineItem(desc, quantity)
currentSale -> :SalesLineItem: create(desc, quantity)
currentSale -> lineItems: add(sl)
\end{lstlisting}

\textbf{Begründung der Interaktionen:}
\begin{itemize}
    \item Register als Controller empfängt Systemoperation
    \item ProductCatalog als Information Expert für Produkte
    \item Sale als Creator für SalesLineItem
    \item Sale als Container verwaltet seine LineItems
\end{itemize}
\end{example2}

\begin{concept}{Design Class Diagram (DCD)}
    %todo ADD
    
\end{concept}

\begin{KR}{Design Class Diagram (DCD) erstellen}
\textbf{1. Klassen identifizieren}
\begin{itemize}
    \item Aus Domänenmodell übernehmen
    \item Technische Klassen ergänzen
    \item Controller bestimmen
\end{itemize}

\textbf{2. Attribute definieren}
\begin{itemize}
    \item Datentypen festlegen
    \item Sichtbarkeiten bestimmen
    \item Validierungen vorsehen
\end{itemize}

\textbf{3. Methoden hinzufügen}
\begin{itemize}
    \item Systemoperationen verteilen
    \item GRASP-Prinzipien anwenden
    \item Signaturen definieren
\end{itemize}

\textbf{4. Beziehungen modellieren}
\begin{itemize}
    \item Assoziationen aus Domänenmodell
    \item Navigierbarkeit festlegen
    \item Abhängigkeiten minimieren
\end{itemize}
\end{KR}

\begin{example2}{Design Class Diagram}
    %todo ADD
\end{example2}

\columnbreak

\subsection{GRASP in der Use Case Realization}

\begin{KR}{GRASP Patterns in der Realization}
\textbf{Die 5 wichtigsten Prinzipien:}
\begin{itemize}
    \item \textbf{Information Expert:}
    \begin{itemize}
        \item Verantwortlichkeit dort, wo Information liegt
        \item Basis für Methodenzuweisung
    \end{itemize}
    \item \textbf{Creator:}
    \begin{itemize}
        \item Regeln für Objekterzeugung
        \item Container erzeugt Inhalt
    \end{itemize}
    \item \textbf{Controller:}
    \begin{itemize}
        \item Erste Systemanlaufstelle
        \item Koordiniert Systemoperationen
    \end{itemize}
    \item \textbf{Low Coupling:}
    \begin{itemize}
        \item Minimale Abhängigkeiten
        \item Entscheidungshilfe bei Alternativen
    \end{itemize}
    \item \textbf{High Cohesion:}
    \begin{itemize}
        \item Fokussierte Verantwortlichkeiten
        \item Zusammengehörige Funktionalität
    \end{itemize}
\end{itemize}
\end{KR}

%todo: Add example of complete use case realization with all steps

\begin{KR}{Testing und Refactoring}
\textbf{1. Funktionale Prüfung}
\begin{itemize}
    \item Use Case Szenarien durchspielen
    \item Randfälle testen
    \item Fehlersituationen prüfen
\end{itemize}

\textbf{2. Strukturelle Prüfung}
\begin{itemize}
    \item Architekturkonformität
    \item GRASP-Prinzipien
    \item Clean Code Regeln
\end{itemize}

\textbf{3. Qualitätsprüfung}
\begin{itemize}
    \item Testabdeckung
    \item Wartbarkeit
    \item Performance
\end{itemize}
\end{KR}

\subsubsection{Implementierung und Prüfung}

\begin{KR}{Typische Prüfungsaufgaben}\\
\textbf{1. Use Case Realization dokumentieren}
\begin{itemize}
    \item System Sequence Diagram erstellen
    \item Operation Contracts definieren
    \item Design Class Diagram zeichnen
    \item GRASP Prinzipien begründen
    \item Sequenzdiagramm für wichtige Operationen
\end{itemize}

\textbf{2. Implementation analysieren}
\begin{itemize}
    \item GRASP Verletzungen identifizieren
    \item Verbesserungen vorschlagen
    \item Alternative Designs diskutieren
\end{itemize}

\textbf{3. Architektur evaluieren}
\begin{itemize}
    \item Schichtenarchitektur prüfen
    \item Kopplung analysieren
    \item Kohäsion bewerten
\end{itemize}
\end{KR}




\begin{example2}{Vollständige Use Case Realization}\\
    %todo better example?
\textbf{Use Case:} Bestellung aufgeben

\textbf{1. Systemoperationen:}
\begin{itemize}
    \item createOrder()
    \item addItem(productId, quantity)
    \item removeItem(itemId)
    \item submitOrder()
\end{itemize}

\textbf{2. Design-Entscheidungen:}
\begin{itemize}
    \item OrderController als Fassade
    \item Order aggregiert OrderItems
    \item OrderService für Geschäftslogik
    \item Repository für Persistenz
\end{itemize}

\textbf{3. GRASP-Anwendung:}
\begin{itemize}
    \item Information Expert:
    \begin{itemize}
        \item Order berechnet Gesamtsumme
        \item OrderItem verwaltet Produktdaten
    \end{itemize}
    \item Creator:
    \begin{itemize}
        \item Order erstellt OrderItems
        \item OrderService erstellt Orders
    \end{itemize}
    \item Low Coupling:
    \begin{itemize}
        \item Repository-Interface für Persistenz
        \item Service-Interface für Geschäftslogik
    \end{itemize}
\end{itemize}

\textbf{4. Implementierung:}
\begin{lstlisting}[language=Java, style=basesmol]
public class OrderController {
    private OrderService orderService;
    private Order currentOrder;
    
    public void createOrder() {
        currentOrder = orderService.createOrder();
    }
    
    public void addItem(String productId, int quantity) {
        currentOrder.addItem(productId, quantity);
    }
    
    public void submitOrder() {
        orderService.submitOrder(currentOrder);
    }
}
\end{lstlisting}
\end{example2}



\begin{KR}{Typische Implementierungsfehler vermeiden}
\begin{itemize}
    \item \textbf{Architekturverletzungen:}
    \begin{itemize}
        \item Schichtentrennung beachten
        \item Abhängigkeiten richtig setzen
    \end{itemize}
    
    \item \textbf{GRASP-Verletzungen:}
    \begin{itemize}
        \item Information Expert beachten
        \item Creator Pattern richtig anwenden
        \item High Cohesion erhalten
    \end{itemize}
    
    \item \textbf{Testbarkeit:}
    \begin{itemize}
        \item Klassen isoliert testbar halten
        \item Abhängigkeiten mockbar gestalten
    \end{itemize}
\end{itemize}
\end{KR}