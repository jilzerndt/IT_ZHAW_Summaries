\section{Design Patterns}

\begin{concept}{Grundlagen Design Patterns}\\
Bewährte Lösungsmuster für wiederkehrende Probleme:
\begin{itemize}
    \item Beschleunigen Entwicklung durch vorgefertigte Lösungen
    \item Verbessern Kommunikation im Team
    \item Bieten Balance zwischen Flexibilität und Komplexität
    \item \textbf{Wichtig:} Design Patterns sind kein Selbstzweck
\end{itemize}
\end{concept}

\subsection{Grundlegende Design Patterns}

\begin{definition}{Adapter Pattern}\\
\textbf{Problem:} Inkompatible Schnittstellen
\begin{itemize}
    \item Objekte mit unterschiedlichen Interfaces sollen zusammenarbeiten
    \item Externe Dienste sollen austauschbar sein
\end{itemize}
\textbf{Lösung:} Adapter-Klasse als Vermittler
\end{definition}

\begin{definition}{Simple Factory Pattern}\\
\textbf{Problem:} Komplexe Objekterzeugung
\begin{itemize}
    \item Objekterzeugung erfordert viele Schritte
    \item Konfiguration bei Erzeugung notwendig
\end{itemize}
\textbf{Lösung:} Eigene Klasse für Objekterzeugung
\end{definition}

\begin{definition}{Singleton Pattern}\\
\textbf{Problem:} Genau eine Instanz benötigt
\begin{itemize}
    \item Globaler Zugriffspunkt notwendig
    \item Mehrfachinstanzierung verhindern
\end{itemize}
\textbf{Lösung:} Statische Instanz mit privater Erzeugung
\end{definition}

\begin{definition}{Dependency Injection Pattern}\\
\textbf{Problem:} Abhängigkeiten zu anderen Objekten
\begin{itemize}
    \item Lose Kopplung erwünscht
    \item Flexibilität bei Abhängigkeiten
\end{itemize}
\textbf{Lösung:} Abhängigkeiten werden von außen injiziert
\end{definition}

\begin{definition}{Proxy Pattern}\\
\textbf{Problem:} Zugriffskontrolle auf Objekte
\begin{itemize}
    \item Verzögertes Laden
    \item Zugriffsbeschränkungen
    \item Netzwerkkommunikation
\end{itemize}
\textbf{Lösung:} Stellvertreterobjekt mit gleichem Interface
\begin{itemize}
    \item \textbf{Remote Proxy:} Für entfernte Objekte
    \item \textbf{Virtual Proxy:} Für spätes Laden
    \item \textbf{Protection Proxy:} Für Zugriffsschutz
\end{itemize}
\end{definition}

\begin{definition}{Chain of Responsibility Pattern}\\
\textbf{Problem:} Unklare Zuständigkeit für Anfragen
\begin{itemize}
    \item Mehrere mögliche Handler
    \item Zuständigkeit erst zur Laufzeit klar
\end{itemize}
\textbf{Lösung:} Verkettete Handler-Objekte
\end{definition}

\subsection{Erweiterte Design Patterns}

\begin{definition}{Decorator Pattern}\\
\textbf{Problem:} Dynamische Erweiterung von Objekten
\begin{itemize}
    \item Zusätzliche Verantwortlichkeiten
    \item Nur für einzelne Objekte
\end{itemize}
\textbf{Lösung:} Wrapper-Objekt mit gleichem Interface
\end{definition}

\begin{definition}{Observer Pattern}\\
\textbf{Problem:} Abhängige Objekte aktualisieren
\begin{itemize}
    \item Lose Kopplung erwünscht
    \item Typ des Empfängers unbekannt
\end{itemize}
\textbf{Lösung:} Observer-Interface für Benachrichtigungen
\end{definition}

\begin{definition}{Strategy Pattern}\\
\textbf{Problem:} Austauschbare Algorithmen
\begin{itemize}
    \item Verschiedene Implementierungen
    \item Zur Laufzeit wechselbar
\end{itemize}
\textbf{Lösung:} Interface für Algorithmus-Klassen
\end{definition}

\begin{definition}{Composite Pattern}\\
\textbf{Problem:} Baumstrukturen verwalten
\begin{itemize}
    \item Einheitliche Behandlung
    \item Teil-Ganzes Hierarchie
\end{itemize}
\textbf{Lösung:} Gemeinsames Interface für Container und Inhalt
\end{definition}

\begin{KR}{Design Pattern Auswahl}\\
\textbf{Schritt 1: Problem analysieren}
\begin{itemize}
    \item Art des Problems identifizieren
    \item Anforderungen klar definieren
    \item Kontext verstehen
\end{itemize}

\textbf{Schritt 2: Pattern evaluieren}
\begin{itemize}
    \item Passende Patterns suchen
    \item Vor- und Nachteile abwägen
    \item Komplexität bewerten
\end{itemize}

\textbf{Schritt 3: Implementation planen}
\begin{itemize}
    \item Klassenstruktur entwerfen
    \item Schnittstellen definieren
    \item Anpassungen vornehmen
\end{itemize}
\end{KR}

\begin{KR}{Pattern-Analyse für Prüfung}\\
\textbf{Systematisches Vorgehen:}
\begin{enumerate}
    \item \textbf{Problem identifizieren}
    \begin{itemize}
        \item Was ist das Kernproblem?
        \item Welche Flexibilität wird benötigt?
        \item Welche Einschränkungen gibt es?
    \end{itemize}
    
    \item \textbf{Pattern auswählen}
    \begin{itemize}
        \item Welche Patterns lösen ähnliche Probleme?
        \item Wie unterscheiden sich die Patterns?
        \item Welche Trade-offs gibt es?
    \end{itemize}
    
    \item \textbf{Lösung skizzieren}
    \begin{itemize}
        \item Klassenstruktur beschreiben
        \item Beziehungen definieren
        \item Vor- und Nachteile nennen
    \end{itemize}
\end{enumerate}
\end{KR}

\begin{example2}{Prüfungsaufgabe: Pattern-Identifikation}
\textbf{Szenario:}
Ein Dokumentensystem soll verschiedene Dateitypen (.pdf, .doc, .txt) einheitlich 
behandeln. Jeder Dateityp benötigt eine spezielle Verarbeitung für Öffnen, 
Speichern und Drucken.

\textbf{Aufgabe:}
\begin{enumerate}
    \item Identifizieren Sie geeignete Design Patterns
    \item Begründen Sie Ihre Auswahl
    \item Skizzieren Sie die Struktur der Lösung
\end{enumerate}

\textbf{Musterlösung:}
\begin{itemize}
    \item \textbf{Mögliche Patterns:}
    \begin{itemize}
        \item Strategy (für Verarbeitungslogik)
        \item Factory (für Dokumenterstellung)
        \item Adapter (für einheitliche Schnittstelle)
    \end{itemize}
    
    \item \textbf{Begründung Strategy:}
    \begin{itemize}
        \item Unterschiedliche Algorithmen pro Dateityp
        \item Austauschbarkeit der Verarbeitung
        \item Erweiterbar für neue Dateitypen
    \end{itemize}
    
    \item \textbf{Struktur:}
    \begin{itemize}
        \item Interface DocumentProcessor
        \item Konkrete Prozessoren pro Dateityp
        \item Context-Klasse Document
    \end{itemize}
\end{itemize}
\end{example2}

\begin{example2}{Pattern-Vergleich: Adapter vs. Facade}
\textbf{Gegeben sind zwei Patterns. Vergleichen Sie diese:}

\textbf{Adapter:}
\begin{itemize}
    \item \textbf{Zweck:} Inkompatible Schnittstellen vereinen
    \item \textbf{Struktur:} Wrapper um einzelne Klasse
    \item \textbf{Anwendung:} Bei existierenden, inkompatiblen Klassen
\end{itemize}

\textbf{Facade:}
\begin{itemize}
    \item \textbf{Zweck:} Komplexes Subsystem vereinfachen
    \item \textbf{Struktur:} Neue Schnittstelle für mehrere Klassen
    \item \textbf{Anwendung:} Bei komplexen Subsystemen
\end{itemize}

\textbf{Kernunterschiede:}
\begin{itemize}
    \item Adapter ändert Interface, Facade vereinfacht
    \item Adapter für einzelne Klasse, Facade für Subsystem
    \item Adapter für Kompatibilität, Facade für Vereinfachung
\end{itemize}
\end{example2}

\begin{KR}{Pattern-Kombination}
\textbf{Schritte zur Kombination mehrerer Patterns:}
\begin{enumerate}
    \item \textbf{Abhängigkeiten analysieren}
    \begin{itemize}
        \item Welche Patterns ergänzen sich?
        \item Wo gibt es Überschneidungen?
        \item Welche Reihenfolge ist sinnvoll?
    \end{itemize}
    
    \item \textbf{Struktur entwerfen}
    \begin{itemize}
        \item Gemeinsame Schnittstellen identifizieren
        \item Verantwortlichkeiten zuordnen
        \item Komplexität im Auge behalten
    \end{itemize}
    
    \item \textbf{Integration planen}
    \begin{itemize}
        \item Übergänge zwischen Patterns definieren
        \item Konsistenz sicherstellen
        \item Testbarkeit gewährleisten
    \end{itemize}
\end{enumerate}
\end{KR}



