[Previous content remains unchanged until after initial pattern definitions]

\begin{KR}{Pattern-Analyse für Prüfung}
\textbf{Systematisches Vorgehen:}
\begin{enumerate}
    \item \textbf{Problem identifizieren}
    \begin{itemize}
        \item Was ist das Kernproblem?
        \item Welche Flexibilität wird benötigt?
        \item Welche Einschränkungen gibt es?
    \end{itemize}
    
    \item \textbf{Pattern auswählen}
    \begin{itemize}
        \item Welche Patterns lösen ähnliche Probleme?
        \item Wie unterscheiden sich die Patterns?
        \item Welche Trade-offs gibt es?
    \end{itemize}
    
    \item \textbf{Lösung skizzieren}
    \begin{itemize}
        \item Klassenstruktur beschreiben
        \item Beziehungen definieren
        \item Vor- und Nachteile nennen
    \end{itemize}
\end{enumerate}
\end{KR}

\begin{example}{Prüfungsaufgabe: Pattern-Identifikation}
\textbf{Szenario:}
Ein Dokumentensystem soll verschiedene Dateitypen (.pdf, .doc, .txt) einheitlich 
behandeln. Jeder Dateityp benötigt eine spezielle Verarbeitung für Öffnen, 
Speichern und Drucken.

\textbf{Aufgabe:}
\begin{enumerate}
    \item Identifizieren Sie geeignete Design Patterns
    \item Begründen Sie Ihre Auswahl
    \item Skizzieren Sie die Struktur der Lösung
\end{enumerate}

\textbf{Musterlösung:}
\begin{itemize}
    \item \textbf{Mögliche Patterns:}
    \begin{itemize}
        \item Strategy (für Verarbeitungslogik)
        \item Factory (für Dokumenterstellung)
        \item Adapter (für einheitliche Schnittstelle)
    \end{itemize}
    
    \item \textbf{Begründung Strategy:}
    \begin{itemize}
        \item Unterschiedliche Algorithmen pro Dateityp
        \item Austauschbarkeit der Verarbeitung
        \item Erweiterbar für neue Dateitypen
    \end{itemize}
    
    \item \textbf{Struktur:}
    \begin{itemize}
        \item Interface DocumentProcessor
        \item Konkrete Prozessoren pro Dateityp
        \item Context-Klasse Document
    \end{itemize}
\end{itemize}
\end{example}

\begin{example}{Pattern-Vergleich: Adapter vs. Facade}
\textbf{Gegeben sind zwei Patterns. Vergleichen Sie diese:}

\textbf{Adapter:}
\begin{itemize}
    \item \textbf{Zweck:} Inkompatible Schnittstellen vereinen
    \item \textbf{Struktur:} Wrapper um einzelne Klasse
    \item \textbf{Anwendung:} Bei existierenden, inkompatiblen Klassen
\end{itemize}

\textbf{Facade:}
\begin{itemize}
    \item \textbf{Zweck:} Komplexes Subsystem vereinfachen
    \item \textbf{Struktur:} Neue Schnittstelle für mehrere Klassen
    \item \textbf{Anwendung:} Bei komplexen Subsystemen
\end{itemize}

\textbf{Kernunterschiede:}
\begin{itemize}
    \item Adapter ändert Interface, Facade vereinfacht
    \item Adapter für einzelne Klasse, Facade für Subsystem
    \item Adapter für Kompatibilität, Facade für Vereinfachung
\end{itemize}
\end{example}

\begin{KR}{Pattern-Kombination}
\textbf{Schritte zur Kombination mehrerer Patterns:}
\begin{enumerate}
    \item \textbf{Abhängigkeiten analysieren}
    \begin{itemize}
        \item Welche Patterns ergänzen sich?
        \item Wo gibt es Überschneidungen?
        \item Welche Reihenfolge ist sinnvoll?
    \end{itemize}
    
    \item \textbf{Struktur entwerfen}
    \begin{itemize}
        \item Gemeinsame Schnittstellen identifizieren
        \item Verantwortlichkeiten zuordnen
        \item Komplexität im Auge behalten
    \end{itemize}
    
    \item \textbf{Integration planen}
    \begin{itemize}
        \item Übergänge zwischen Patterns definieren
        \item Konsistenz sicherstellen
        \item Testbarkeit gewährleisten
    \end{itemize}
\end{enumerate}
\end{KR}

\begin{examplecode}{Strategy Pattern Implementation}
\begin{lstlisting}[language=Java, style=basesmol]
public interface SortStrategy {
    void sort(List<String> data);
}

public class QuickSort implements SortStrategy {
    public void sort(List<String> data) {
        // Implementierung
    }
}

public class Context {
    private SortStrategy strategy;
    
    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void executeStrategy(List<String> data) {
        strategy.sort(data);
    }
}
\end{lstlisting}
\end{examplecode}

[Continue with previous pattern definitions...]