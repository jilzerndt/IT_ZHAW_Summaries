[Previous content until initial concepts remains unchanged]

\begin{example}{Prüfungsaufgabe: O/R-Mapping Analyse}
\textbf{Szenario:}
Ein Universitätssystem verwaltet Studenten, Kurse und Noten. Studenten können mehrere 
Kurse belegen, ein Kurs hat mehrere Studenten.

\textbf{Aufgabe:} 
Analysieren Sie die O/R-Mapping Herausforderungen dieser Domain.

\textbf{Lösung:}
\begin{itemize}
    \item \textbf{Beziehungen:}
    \begin{itemize}
        \item Many-to-Many zwischen Student und Kurs
        \item Zusätzliche Attribute in der Beziehung (Noten)
        \item Bidirektionale Navigation erforderlich
    \end{itemize}
    
    \item \textbf{Vererbung:}
    \begin{itemize}
        \item Person -> Student/Dozent
        \item Verschiedene Mapping-Strategien möglich
    \end{itemize}
    
    \item \textbf{Komplexe Daten:}
    \begin{itemize}
        \item Adressdaten als Wertobjekte
        \item Zeiträume für Kursbelegung
    \end{itemize}
\end{itemize}
\end{example}

\begin{KR}{Persistenzstrategie wählen}
\textbf{1. Anforderungen analysieren}
\begin{itemize}
    \item \textbf{Funktional:}
    \begin{itemize}
        \item Datenmodell-Komplexität
        \item Abfrageanforderungen
        \item Transaktionsverhalten
    \end{itemize}
    \item \textbf{Nicht-funktional:}
    \begin{itemize}
        \item Performance
        \item Skalierbarkeit
        \item Wartbarkeit
    \end{itemize}
\end{itemize}

\textbf{2. Technologien evaluieren}
\begin{itemize}
    \item \textbf{JDBC:}
    \begin{itemize}
        \item Direkte Kontrolle
        \item Hohe Performance
        \item Hoher Implementierungsaufwand
    \end{itemize}
    \item \textbf{JPA:}
    \begin{itemize}
        \item Standardisiert
        \item Produktiv
        \item Lernkurve
    \end{itemize}
    \item \textbf{NoSQL:}
    \begin{itemize}
        \item Flexibles Schema
        \item Hohe Skalierbarkeit
        \item Spezielle Anwendungsfälle
    \end{itemize}
\end{itemize}
\end{KR}

\begin{example}{Prüfungsaufgabe: Design Pattern Vergleich}
\textbf{Aufgabe:}
Vergleichen Sie Active Record, DAO und Repository Pattern.

\textbf{Analysematrix:}
\begin{itemize}
    \item \textbf{Active Record:}
    \begin{itemize}
        \item \textbf{Vorteile:}
        \begin{itemize}
            \item Einfache Implementierung
            \item Schnell zu entwickeln
        \end{itemize}
        \item \textbf{Nachteile:}
        \begin{itemize}
            \item Keine Trennung der Belange
            \item Schlechte Testbarkeit
            \item Vermischung von Fachlogik und Persistenz
        \end{itemize}
    \end{itemize}
    
    \item \textbf{DAO:}
    \begin{itemize}
        \item \textbf{Vorteile:}
        \begin{itemize}
            \item Klare Trennung der Belange
            \item Gute Testbarkeit
            \item Austauschbare Implementierung
        \end{itemize}
        \item \textbf{Nachteile:}
        \begin{itemize}
            \item Mehr Initialaufwand
            \item Zusätzliche Abstraktionsebene
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Repository:}
    \begin{itemize}
        \item \textbf{Vorteile:}
        \begin{itemize}
            \item Domänenorientierte Schnittstelle
            \item Zentrale Abfragelogik
            \item DDD-konform
        \end{itemize}
        \item \textbf{Nachteile:}
        \begin{itemize}
            \item Komplexere Implementierung
            \item Höhere Lernkurve
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{example}

\begin{KR}{JPA Entity Design}
\textbf{1. Grundstruktur}
\begin{itemize}
    \item \textbf{Basisanforderungen:}
    \begin{itemize}
        \item Default Constructor
        \item Serializable (optional)
        \item Getter/Setter
    \end{itemize}
    \item \textbf{Identifikation:}
    \begin{itemize}
        \item Primary Key Strategie
        \item Natural vs. Surrogate Key
    \end{itemize}
\end{itemize}

\textbf{2. Beziehungen}
\begin{itemize}
    \item \textbf{Kardinalität:}
    \begin{itemize}
        \item OneToOne
        \item OneToMany/ManyToOne
        \item ManyToMany
    \end{itemize}
    \item \textbf{Richtung:}
    \begin{itemize}
        \item Unidirektional
        \item Bidirektional
    \end{itemize}
    \item \textbf{Lifecycle:}
    \begin{itemize}
        \item Cascade-Operationen
        \item Orphan Removal
    \end{itemize}
\end{itemize}

\textbf{3. Optimierungen}
\begin{itemize}
    \item \textbf{Lazy Loading:}
    \begin{itemize}
        \item Fetch-Strategien
        \item Join Fetching
    \end{itemize}
    \item \textbf{Caching:}
    \begin{itemize}
        \item First-Level Cache
        \item Second-Level Cache
    \end{itemize}
\end{itemize}
\end{KR}

[Previous content about Repository Pattern remains]