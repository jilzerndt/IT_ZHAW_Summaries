\section{Implementation, Refactoring und Testing}

\subsection{Von Design zu Code}

\begin{concept}{Implementierungsstrategien}\\
\textbf{1. Bottom-Up Entwicklung:}
\begin{itemize}
    \item Implementierung beginnt mit Basisbausteinen
    \item Schrittweise Integration zu größeren Komponenten
    \item \textbf{Vorteile:} Gründlich, solide Basis
    \item \textbf{Nachteile:} Spätes Feedback
\end{itemize}

\textbf{2. Agile Entwicklung:}
\begin{itemize}
    \item Inkrementelle Entwicklung in Sprints
    \item Kontinuierliche Integration und Auslieferung
    \item \textbf{Vorteile:} Flexibilität, schnelles Feedback
    \item \textbf{Nachteile:} Mögliche Restrukturierung nötig
\end{itemize}
\end{concept}

\begin{definition}{Entwicklungsansätze}\\
\textbf{Code-Driven Development (CDD):}
\begin{itemize}
    \item Direkte Implementierung der Klassen
    \item Nachträgliches Testing
\end{itemize}

\textbf{Test-Driven Development (TDD):}
\begin{itemize}
    \item Tests vor Implementation
    \item Red-Green-Refactor Zyklus
\end{itemize}

\textbf{Behavior-Driven Development (BDD):}
\begin{itemize}
    \item Testbeschreibung aus Anwendersicht
    \item Gherkin-Syntax für Szenarios
\end{itemize}
\end{definition}

\begin{KR}{Clean Code}\\
\textbf{1. Code-Guidelines:}
\begin{itemize}
    \item Einheitliche Formatierung
    \item Klare Namenskonventionen
    \item Dokumentationsrichtlinien
\end{itemize}

\textbf{2. Fehlerbehandlung:}
\begin{itemize}
    \item Exceptions statt Fehlercodes
    \item Sinnvolle Error Messages
    \item Logging-Strategie
\end{itemize}

\textbf{3. Namensgebung:}
\begin{itemize}
    \item Aussagekräftige Namen
    \item Konsistente Begriffe
    \item Domain-Driven Naming
\end{itemize}
\end{KR}

\begin{concept}{Laufzeit-Optimierung}\\
\textbf{Grundregeln:}
\begin{itemize}
    \item Zuerst messen, dann optimieren
    \item Performance-Profile nutzen
    \item Bottlenecks identifizieren
\end{itemize}

\textbf{Häufige Probleme:}
\begin{itemize}
    \item Datenbank-Zugriffe
    \item Ineffiziente Algorithmen
    \item Speicherlecks
\end{itemize}
\end{concept}

\subsection{Refactoring}

\begin{definition}{Refactoring Grundlagen}\\
Strukturierte Verbesserung des Codes ohne Änderung des externen Verhaltens:
\begin{itemize}
    \item Kleine, kontrollierte Schritte
    \item Erhaltung der Funktionalität
    \item Verbesserung der Codequalität
\end{itemize}
\end{definition}

\begin{KR}{Refactoring Durchführung}\\
\textbf{1. Code Smells identifizieren:}
\begin{itemize}
    \item Duplizierter Code
    \item Lange Methoden
    \item Große Klassen
    \item Hohe Kopplung
\end{itemize}

\textbf{2. Refactoring durchführen:}
\begin{itemize}
    \item Tests sicherstellen
    \item Änderungen vornehmen
    \item Tests ausführen
\end{itemize}

\textbf{3. Patterns anwenden:}
\begin{itemize}
    \item Extract Method
    \item Move Method
    \item Rename
    \item Introduce Variable
\end{itemize}
\end{KR}



\subsection{Testing}

\begin{definition}{Testarten}\\
\textbf{Nach Sicht:}
\begin{itemize}
    \item \textbf{Black-Box:} Funktionaler Test ohne Codekenntnis
    \item \textbf{White-Box:} Strukturbezogener Test mit Codekenntnis
\end{itemize}

\textbf{Nach Umfang:}
\begin{itemize}
    \item \textbf{Unit-Tests:} Einzelne Komponenten
    \item \textbf{Integrationstests:} Zusammenspiel
    \item \textbf{Systemtests:} Gesamtsystem
    \item \textbf{Akzeptanztests:} Kundenanforderungen
\end{itemize}
\end{definition}

\begin{KR}{Testentwicklung}\\
\textbf{1. Testfall definieren:}
\begin{itemize}
    \item Vorbedingungen festlegen
    \item Testdaten vorbereiten
    \item Erwartetes Ergebnis definieren
\end{itemize}

\textbf{2. Test implementieren:}
\begin{itemize}
    \item Setup vorbereiten
    \item Testlogik schreiben
    \item Assertions definieren
\end{itemize}

\textbf{3. Test ausführen:}
\begin{itemize}
    \item Automatisiert ausführen
    \item Ergebnisse prüfen
    \item Dokumentation erstellen
\end{itemize}
\end{KR}




\begin{example}{Prüfungsaufgabe: Entwicklungsansätze vergleichen}
\textbf{Szenario:}
Ein Team soll eine neue Webanwendung entwickeln. Diskutieren Sie die Vor- und Nachteile 
von TDD gegenüber CDD für dieses Projekt.

\textbf{Musterlösung:}
\begin{itemize}
    \item \textbf{TDD Vorteile:}
    \begin{itemize}
        \item Testbare Architektur von Anfang an
        \item Frühe Fehlererkennung
        \item Dokumentation durch Tests
        \item Sicherheit bei Refactoring
    \end{itemize}
    
    \item \textbf{TDD Nachteile:}
    \begin{itemize}
        \item Initial höherer Zeitaufwand
        \item Lernkurve für das Team
        \item Schwierig bei unklaren Anforderungen
    \end{itemize}
    
    \item \textbf{Empfehlung:}
    \begin{itemize}
        \item TDD für kritische Kernkomponenten
        \item CDD für Prototypen und UI
        \item Hybridansatz je nach Modulkritikalität
    \end{itemize}
\end{itemize}
\end{example}

\begin{KR}{Code Review Durchführung}
\textbf{1. Vorbereitung}
\begin{itemize}
    \item Code-Guidelines bereitstellen
    \item Checkliste erstellen
    \item Scope definieren
\end{itemize}

\textbf{2. Review durchführen}
\begin{itemize}
    \item Lesbarkeit prüfen
    \item Naming Conventions
    \item Architekturkonformität
    \item Testabdeckung
\end{itemize}

\textbf{3. Feedback geben}
\begin{itemize}
    \item Konstruktiv formulieren
    \item Priorisieren
    \item Lösungen vorschlagen
\end{itemize}
\end{KR}

\begin{example}{Typische Prüfungsaufgabe: Code Smells}
\textbf{Analysieren Sie folgenden Code auf Code Smells:}

\textbf{Problematischer Code:}
\begin{itemize}
    \item Klasse "UserManager" mit 1000 Zeilen
    \item Methode "processData" mit 200 Zeilen
    \item Variable "data" wird in 15 Methoden verwendet
    \item Duplizierte Validierungslogik in mehreren Klassen
\end{itemize}

\textbf{Identifizierte Smells:}
\begin{itemize}
    \item \textbf{God Class:} UserManager zu groß
    \item \textbf{Long Method:} processData zu komplex
    \item \textbf{Global Variable:} data zu weit verbreitet
    \item \textbf{Duplicate Code:} Validierungslogik
\end{itemize}

\textbf{Refactoring-Vorschläge:}
\begin{itemize}
    \item Aufteilen in spezialisierte Klassen
    \item Extract Method für processData
    \item Einführen einer Validierungsklasse
    \item Dependency Injection für data
\end{itemize}
\end{example}

[Previous content about Testing basics remains]

\begin{example}{Prüfungsaufgabe: Teststrategie}
\textbf{Szenario:}
Ein Onlineshop-System soll getestet werden. Entwickeln Sie eine Teststrategie.

\textbf{Lösung:}
\begin{itemize}
    \item \textbf{Unit Tests:}
    \begin{itemize}
        \item Warenkorb-Berechnungen
        \item Preis-Kalkulationen
        \item Validierungsfunktionen
    \end{itemize}
    
    \item \textbf{Integrationstests:}
    \begin{itemize}
        \item Bestellprozess
        \item Zahlungsabwicklung
        \item Lagerverwaltung
    \end{itemize}
    
    \item \textbf{System Tests:}
    \begin{itemize}
        \item Performance unter Last
        \item Sicherheitsaspekte
        \item Datenbankinteraktionen
    \end{itemize}
    
    \item \textbf{Akzeptanztests:}
    \begin{itemize}
        \item Benutzerszenarien
        \item Geschäftsprozesse
        \item Reporting
    \end{itemize}
\end{itemize}
\end{example}

\begin{KR}{Testabdeckung optimieren}
\textbf{1. Analyse der Testabdeckung}
\begin{itemize}
    \item Code Coverage messen
    \item Kritische Pfade identifizieren
    \item Lücken dokumentieren
\end{itemize}

\textbf{2. Priorisierung}
\begin{itemize}
    \item Geschäftskritische Funktionen
    \item Fehleranfällige Bereiche
    \item Komplexe Algorithmen
\end{itemize}

\textbf{3. Ergänzung der Tests}
\begin{itemize}
    \item Randfall-Tests
    \item Negativtests
    \item Performance-Tests
\end{itemize}

\textbf{4. Wartung}
\begin{itemize}
    \item Regelmäßige Überprüfung
    \item Anpassung an Änderungen
    \item Entfernung veralteter Tests
\end{itemize}
\end{KR}

\begin{example}{Prüfungsaufgabe: Testfälle entwerfen}
\textbf{Aufgabe:}
Entwickeln Sie Testfälle für eine Methode zur Validierung einer Email-Adresse.

\textbf{Testfälle:}
\begin{itemize}
    \item \textbf{Positive Tests:}
    \begin{itemize}
        \item Standard Email (user@domain.com)
        \item Subdomain (user@sub.domain.com)
        \item Mit Punkten (first.last@domain.com)
    \end{itemize}
    
    \item \textbf{Negative Tests:}
    \begin{itemize}
        \item Fehlende @ (userdomain.com)
        \item Mehrere @ (user@@domain.com)
        \item Ungültige Zeichen (user\#@domain.com)
    \end{itemize}
    
    \item \textbf{Randfälle:}
    \begin{itemize}
        \item Leerer String
        \item Nur Whitespace
        \item Sehr lange Adressen
    \end{itemize}
\end{itemize}
\end{example}