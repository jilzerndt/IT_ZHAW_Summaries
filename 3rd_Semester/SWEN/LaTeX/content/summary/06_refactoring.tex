\begin{example2}{Unit Testing Best Practices}
\textbf{FIRST Prinzipien:}
\begin{itemize}
   \item \textbf{Fast:} Tests müssen schnell ausführbar sein
   \item \textbf{Independent:} Tests dürfen nicht voneinander abhängen
   \item \textbf{Repeatable:} Gleiche Ergebnisse bei mehrfacher Ausführung
   \item \textbf{Self-validating:} Automatische Ergebnisüberprüfung
   \item \textbf{Timely:} Tests werden zeitnah geschrieben
\end{itemize}

\textbf{Beispiel Implementierung:}
\begin{lstlisting}[language=Java, style=basesmol]
public class OrderServiceTest {
   private OrderService orderService;
   private OrderRepository mockRepo;
   
   @Before
   public void setup() {
       mockRepo = mock(OrderRepository.class);
       orderService = new OrderService(mockRepo);
   }
   
   @Test
   public void shouldCalculateOrderTotal() {
       // Arrange
       Order order = new Order();
       order.addItem(new OrderItem("Book", 29.99, 2));
       order.addItem(new OrderItem("DVD", 19.99, 1));
       
       // Act
       BigDecimal total = orderService.calculateTotal(order);
       
       // Assert
       assertEquals(new BigDecimal("79.97"), total);
   }
   
   @Test(expected = ValidationException.class)
   public void shouldThrowExceptionForEmptyOrder() {
       // Arrange
       Order order = new Order();
       
       // Act & Assert
       orderService.calculateTotal(order);
   }
}
\end{lstlisting}
\end{example2}

\begin{KR}{Integration Testing}
\textbf{1. Teststrategie:}
\begin{itemize}
   \item Bottom-up Integration
   \item Top-down Integration
   \item Big Bang Integration
\end{itemize}

\textbf{2. Testumfang:}
\begin{itemize}
   \item Komponenteninteraktion
   \item Schnittstellentests
   \item Datenfluss
\end{itemize}

\textbf{3. Testaufbau:}
\begin{lstlisting}[language=Java, style=basesmol]
@SpringBootTest
public class OrderIntegrationTest {
   @Autowired
   private OrderService orderService;
   
   @Autowired
   private CustomerService customerService;
   
   @Test
   public void shouldProcessOrderEndToEnd() {
       // Setup test data
       Customer customer = customerService.createCustomer(
           "Test Customer", "test@example.com");
       
       Order order = new Order(customer);
       order.addItem(new OrderItem("Test Product", 29.99, 1));
       
       // Execute process
       OrderResult result = orderService.processOrder(order);
       
       // Verify results
       assertTrue(result.isSuccess());
       assertEquals("COMPLETED", result.getStatus());
       // Verify database state
       Order savedOrder = orderService.findOrder(result.getOrderId());
       assertEquals("COMPLETED", savedOrder.getStatus());
   }
}
\end{lstlisting}
\end{KR}

\begin{example2}{Refactoring Patterns}
\textbf{1. Extract Class:}
\begin{lstlisting}[language=Java, style=basesmol]
// Vorher
public class Order {
   private List<OrderItem> items;
   private BigDecimal total;
   private BigDecimal tax;
   private BigDecimal shipping;
   
   public BigDecimal calculateTotal() {
       total = items.stream()
           .map(OrderItem::getSubtotal)
           .reduce(BigDecimal.ZERO, BigDecimal::add);
       tax = total.multiply(TAX_RATE);
       shipping = calculateShipping();
       return total.add(tax).add(shipping);
   }
}

// Nachher
public class Order {
   private List<OrderItem> items;
   private PriceCalculator priceCalculator;
   
   public BigDecimal calculateTotal() {
       return priceCalculator.calculateTotal(items);
   }
}

public class PriceCalculator {
   public BigDecimal calculateTotal(List<OrderItem> items) {
       BigDecimal subtotal = calculateSubtotal(items);
       BigDecimal tax = calculateTax(subtotal);
       BigDecimal shipping = calculateShipping(items);
       return subtotal.add(tax).add(shipping);
   }
}
\end{lstlisting}
\end{example2}

\begin{KR}{System Testing}
\textbf{1. Funktionale Tests:}
\begin{itemize}
   \item End-to-End Szenarien
   \item Geschäftsprozesse
   \item Use Case Tests
\end{itemize}

\textbf{2. Nicht-funktionale Tests:}
\begin{itemize}
   \item Performance Tests
   \item Last Tests
   \item Sicherheitstests
   \item Usability Tests
\end{itemize}

\textbf{3. Dokumentation:}
\begin{itemize}
   \item Testfälle
   \item Testdaten
   \item Testergebnisse
   \item Fehlerberichte
\end{itemize}
\end{KR}

[continue with more content or specific focus area?]




\pagebreak
\section{Implementation, Refactoring und Testing old}

\subsection{Von Design zu Code}

\begin{concept}{Implementierungsstrategien}\\
\textbf{1. Bottom-Up Entwicklung:}
\begin{itemize}
    \item Implementierung beginnt mit Basisbausteinen
    \item Schrittweise Integration zu größeren Komponenten
    \item \textbf{Vorteile:} Gründlich, solide Basis
    \item \textbf{Nachteile:} Spätes Feedback
\end{itemize}

\textbf{2. Agile Entwicklung:}
\begin{itemize}
    \item Inkrementelle Entwicklung in Sprints
    \item Kontinuierliche Integration und Auslieferung
    \item \textbf{Vorteile:} Flexibilität, schnelles Feedback
    \item \textbf{Nachteile:} Mögliche Restrukturierung nötig
\end{itemize}
\end{concept}

\begin{definition}{Entwicklungsansätze}\\
\textbf{Code-Driven Development (CDD):}
\begin{itemize}
    \item Direkte Implementierung der Klassen
    \item Nachträgliches Testing
\end{itemize}

\textbf{Test-Driven Development (TDD):}
\begin{itemize}
    \item Tests vor Implementation
    \item Red-Green-Refactor Zyklus
\end{itemize}

\textbf{Behavior-Driven Development (BDD):}
\begin{itemize}
    \item Testbeschreibung aus Anwendersicht
    \item Gherkin-Syntax für Szenarios
\end{itemize}
\end{definition}

\begin{KR}{Clean Code}\\
\textbf{1. Code-Guidelines:}
\begin{itemize}
    \item Einheitliche Formatierung
    \item Klare Namenskonventionen
    \item Dokumentationsrichtlinien
\end{itemize}

\textbf{2. Fehlerbehandlung:}
\begin{itemize}
    \item Exceptions statt Fehlercodes
    \item Sinnvolle Error Messages
    \item Logging-Strategie
\end{itemize}

\textbf{3. Namensgebung:}
\begin{itemize}
    \item Aussagekräftige Namen
    \item Konsistente Begriffe
    \item Domain-Driven Naming
\end{itemize}
\end{KR}

\begin{concept}{Laufzeit-Optimierung}\\
\textbf{Grundregeln:}
\begin{itemize}
    \item Zuerst messen, dann optimieren
    \item Performance-Profile nutzen
    \item Bottlenecks identifizieren
\end{itemize}

\textbf{Häufige Probleme:}
\begin{itemize}
    \item Datenbank-Zugriffe
    \item Ineffiziente Algorithmen
    \item Speicherlecks
\end{itemize}
\end{concept}

\begin{example2}{Prüfungsaufgabe: Entwicklungsansätze vergleichen}
\textbf{Szenario:}
Ein Team soll eine neue Webanwendung entwickeln. Diskutieren Sie die Vor- und Nachteile 
von TDD gegenüber CDD für dieses Projekt.

\textbf{Musterlösung:}
\begin{itemize}
    \item \textbf{TDD Vorteile:}
    \begin{itemize}
        \item Testbare Architektur von Anfang an
        \item Frühe Fehlererkennung
        \item Dokumentation durch Tests
        \item Sicherheit bei Refactoring
    \end{itemize}
    
    \item \textbf{TDD Nachteile:}
    \begin{itemize}
        \item Initial höherer Zeitaufwand
        \item Lernkurve für das Team
        \item Schwierig bei unklaren Anforderungen
    \end{itemize}
    
    \item \textbf{Empfehlung:}
    \begin{itemize}
        \item TDD für kritische Kernkomponenten
        \item CDD für Prototypen und UI
        \item Hybridansatz je nach Modulkritikalität
    \end{itemize}
\end{itemize}
\end{example2}

\subsection{Refactoring}

\begin{definition}{Refactoring Grundlagen}\\
Strukturierte Verbesserung des Codes ohne Änderung des externen Verhaltens:
\begin{itemize}
    \item Kleine, kontrollierte Schritte
    \item Erhaltung der Funktionalität
    \item Verbesserung der Codequalität
\end{itemize}
\end{definition}

\begin{KR}{Refactoring Durchführung}\\
\textbf{1. Code Smells identifizieren:}
\begin{itemize}
    \item Duplizierter Code
    \item Lange Methoden
    \item Große Klassen
    \item Hohe Kopplung
\end{itemize}

\textbf{2. Refactoring durchführen:}
\begin{itemize}
    \item Tests sicherstellen
    \item Änderungen vornehmen
    \item Tests ausführen
\end{itemize}

\textbf{3. Patterns anwenden:}
\begin{itemize}
    \item Extract Method
    \item Move Method
    \item Rename
    \item Introduce Variable
\end{itemize}
\end{KR}

\begin{KR}{Code Review Durchführung}
\textbf{1. Vorbereitung}
\begin{itemize}
    \item Code-Guidelines bereitstellen
    \item Checkliste erstellen
    \item Scope definieren
\end{itemize}

\textbf{2. Review durchführen}
\begin{itemize}
    \item Lesbarkeit prüfen
    \item Naming Conventions
    \item Architekturkonformität
    \item Testabdeckung
\end{itemize}

\textbf{3. Feedback geben}
\begin{itemize}
    \item Konstruktiv formulieren
    \item Priorisieren
    \item Lösungen vorschlagen
\end{itemize}
\end{KR}

\begin{example2}{Typische Prüfungsaufgabe: Code Smells}
\textbf{Analysieren Sie folgenden Code auf Code Smells:}

\textbf{Problematischer Code:}
\begin{itemize}
    \item Klasse "UserManager" mit 1000 Zeilen
    \item Methode "processData" mit 200 Zeilen
    \item Variable "data" wird in 15 Methoden verwendet
    \item Duplizierte Validierungslogik in mehreren Klassen
\end{itemize}

\textbf{Identifizierte Smells:}
\begin{itemize}
    \item \textbf{God Class:} UserManager zu groß
    \item \textbf{Long Method:} processData zu komplex
    \item \textbf{Global Variable:} data zu weit verbreitet
    \item \textbf{Duplicate Code:} Validierungslogik
\end{itemize}

\textbf{Refactoring-Vorschläge:}
\begin{itemize}
    \item Aufteilen in spezialisierte Klassen
    \item Extract Method für processData
    \item Einführen einer Validierungsklasse
    \item Dependency Injection für data
\end{itemize}
\end{example2}



\subsection{Testing}

\begin{definition}{Testarten}\\
\textbf{Nach Sicht:}
\begin{itemize}
    \item \textbf{Black-Box:} Funktionaler Test ohne Codekenntnis
    \item \textbf{White-Box:} Strukturbezogener Test mit Codekenntnis
\end{itemize}

\textbf{Nach Umfang:}
\begin{itemize}
    \item \textbf{Unit-Tests:} Einzelne Komponenten
    \item \textbf{Integrationstests:} Zusammenspiel
    \item \textbf{Systemtests:} Gesamtsystem
    \item \textbf{Akzeptanztests:} Kundenanforderungen
\end{itemize}
\end{definition}

\begin{KR}{Testentwicklung}\\
\textbf{1. Testfall definieren:}
\begin{itemize}
    \item Vorbedingungen festlegen
    \item Testdaten vorbereiten
    \item Erwartetes Ergebnis definieren
\end{itemize}

\textbf{2. Test implementieren:}
\begin{itemize}
    \item Setup vorbereiten
    \item Testlogik schreiben
    \item Assertions definieren
\end{itemize}

\textbf{3. Test ausführen:}
\begin{itemize}
    \item Automatisiert ausführen
    \item Ergebnisse prüfen
    \item Dokumentation erstellen
\end{itemize}
\end{KR}

\begin{example2}{Prüfungsaufgabe: Teststrategie}
\textbf{Szenario:}
Ein Onlineshop-System soll getestet werden. Entwickeln Sie eine Teststrategie.

\textbf{Lösung:}
\begin{itemize}
    \item \textbf{Unit Tests:}
    \begin{itemize}
        \item Warenkorb-Berechnungen
        \item Preis-Kalkulationen
        \item Validierungsfunktionen
    \end{itemize}
    
    \item \textbf{Integrationstests:}
    \begin{itemize}
        \item Bestellprozess
        \item Zahlungsabwicklung
        \item Lagerverwaltung
    \end{itemize}
    
    \item \textbf{System Tests:}
    \begin{itemize}
        \item Performance unter Last
        \item Sicherheitsaspekte
        \item Datenbankinteraktionen
    \end{itemize}
    
    \item \textbf{Akzeptanztests:}
    \begin{itemize}
        \item Benutzerszenarien
        \item Geschäftsprozesse
        \item Reporting
    \end{itemize}
\end{itemize}
\end{example2}

\begin{KR}{Testabdeckung optimieren}
\textbf{1. Analyse der Testabdeckung}
\begin{itemize}
    \item Code Coverage messen
    \item Kritische Pfade identifizieren
    \item Lücken dokumentieren
\end{itemize}

\textbf{2. Priorisierung}
\begin{itemize}
    \item Geschäftskritische Funktionen
    \item Fehleranfällige Bereiche
    \item Komplexe Algorithmen
\end{itemize}

\textbf{3. Ergänzung der Tests}
\begin{itemize}
    \item Randfall-Tests
    \item Negativtests
    \item Performance-Tests
\end{itemize}

\textbf{4. Wartung}
\begin{itemize}
    \item Regelmäßige Überprüfung
    \item Anpassung an Änderungen
    \item Entfernung veralteter Tests
\end{itemize}
\end{KR}

\begin{example2}{Prüfungsaufgabe: Testfälle entwerfen}
\textbf{Aufgabe:}
Entwickeln Sie Testfälle für eine Methode zur Validierung einer Email-Adresse.

\textbf{Testfälle:}
\begin{itemize}
    \item \textbf{Positive Tests:}
    \begin{itemize}
        \item Standard Email (user@domain.com)
        \item Subdomain (user@sub.domain.com)
        \item Mit Punkten (first.last@domain.com)
    \end{itemize}
    
    \item \textbf{Negative Tests:}
    \begin{itemize}
        \item Fehlende @ (userdomain.com)
        \item Mehrere @ (user@@domain.com)
        \item Ungültige Zeichen (user\#@domain.com)
    \end{itemize}
    
    \item \textbf{Randfälle:}
    \begin{itemize}
        \item Leerer String
        \item Nur Whitespace
        \item Sehr lange Adressen
    \end{itemize}
\end{itemize}
\end{example2}