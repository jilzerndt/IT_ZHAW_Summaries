\section{Design Patterns}

\begin{concept}{Grundlagen Design Patterns}
Bewährte Lösungsmuster für wiederkehrende Probleme:
\begin{itemize}
    \item Beschleunigen Entwicklung durch vorgefertigte Lösungen
    \item Verbessern Kommunikation im Team
    \item Bieten Balance zwischen Flexibilität und Komplexität
    \item \textbf{Wichtig:} Design Patterns sind kein Selbstzweck
\end{itemize}
\end{concept}

\subsubsection{Strukturelle Patterns}

\begin{definition}{Adapter Pattern}\\
\textbf{Problem:} Inkompatible Schnittstellen integrieren
\begin{itemize}
    \item Objekte mit unterschiedlichen Interfaces sollen zusammenarbeiten
    \item Externe Dienste sollen austauschbar sein
\end{itemize}
\textbf{Lösung:} Adapter-Klasse als Vermittler
%todo: Add adapter pattern diagram
\end{definition}

\begin{definition}{Dependency Injection Pattern}\\
\textbf{Problem:} Abhängigkeiten zu anderen Objekten
\begin{itemize}
    \item Lose Kopplung erwünscht
    \item Flexibilität bei Abhängigkeiten
\end{itemize}
\textbf{Lösung:} Abhängigkeiten werden von außen injiziert
\end{definition}

\begin{definition}{Proxy Pattern}\\
\textbf{Problem:} Zugriffskontrolle auf Objekte
\begin{itemize}
    \item Verzögertes Laden
    \item Zugriffsbeschränkungen
    \item Netzwerkkommunikation
\end{itemize}
\textbf{Lösung:} Stellvertreterobjekt mit gleichem Interface
\begin{itemize}
    \item \textbf{Remote Proxy:} Für entfernte Objekte
    \item \textbf{Virtual Proxy:} Für spätes Laden
    \item \textbf{Protection Proxy:} Für Zugriffsschutz
\end{itemize}
\end{definition}

\begin{definition}{Decorator Pattern}\\
\textbf{Problem:} Dynamische Erweiterung von Objekten
\begin{itemize}
    \item Zusätzliche Verantwortlichkeiten
    \item Nur für einzelne Objekte
\end{itemize}
\textbf{Lösung:} Wrapper-Objekt mit gleichem Interface
\end{definition}

\begin{definition}{Composite Pattern}\\
\textbf{Problem:} Baumstrukturen verwalten
\begin{itemize}
    \item Einheitliche Behandlung
    \item Teil-Ganzes Hierarchie
\end{itemize}
\textbf{Lösung:} Gemeinsames Interface für Container und Inhalt
\end{definition}

\subsubsection{Verhaltensmuster}

\begin{definition}{Chain of Responsibility Pattern}\\
\textbf{Problem:} Unklare Zuständigkeit für Anfragen
\begin{itemize}
    \item Mehrere mögliche Handler
    \item Zuständigkeit erst zur Laufzeit klar
\end{itemize}
\textbf{Lösung:} Verkettete Handler-Objekte
\end{definition}

\begin{definition}{Observer Pattern}\\
\textbf{Problem:} Abhängige Objekte aktualisieren
\begin{itemize}
    \item Lose Kopplung erwünscht
    \item Typ des Empfängers unbekannt
\end{itemize}
\textbf{Lösung:} Observer-Interface für Benachrichtigungen
%todo: Add observer pattern diagram
\end{definition}

\begin{definition}{Strategy Pattern}\\
\textbf{Problem:} Austauschbare Algorithmen
\begin{itemize}
    \item Verschiedene Implementierungen
    \item Zur Laufzeit wechselbar
\end{itemize}
\textbf{Lösung:} Interface für Algorithmus-Klassen
\end{definition}

\begin{definition}{State Pattern}\\
\textbf{Problem:} Zustandsabhängiges Verhalten
\begin{itemize}
    \item Verhalten abhängig vom inneren Zustand
    \item Viele bedingte Anweisungen
\end{itemize}
\textbf{Lösung:} Eigene Klassen für verschiedene Zustände
\end{definition}

\subsubsection{Erzeugungsmuster}

\begin{definition}{Simple Factory Pattern}\\
\textbf{Problem:} Komplexe Objekterzeugung
\begin{itemize}
    \item Objekterzeugung erfordert viele Schritte
    \item Konfiguration bei Erzeugung notwendig
\end{itemize}
\textbf{Lösung:} Eigene Klasse für Objekterzeugung
\end{definition}

\begin{definition}{Factory Method Pattern}\\
\textbf{Problem:}
\begin{itemize}
   \item Erzeugung von Objekten soll flexibel sein
   \item Entscheidung über konkrete Klasse erst zur Laufzeit
   \item Basis für Frameworks/Libraries
\end{itemize}

\textbf{Lösung:}
\begin{itemize}
   \item Abstrakte Methode zur Objekterzeugung
   \item Subklassen bestimmen konkreten Typ
   \item Template Method Pattern für Algorithmus
\end{itemize}
\end{definition}

\begin{definition}{Command Pattern}\\
\textbf{Problem:}
\begin{itemize}
   \item Aktionen/Requests als Objekte kapseln
   \item Entkopplung von Sender und Empfänger
   \item Unterstützung für Undo/Redo
\end{itemize}

\textbf{Lösung:}
\begin{itemize}
   \item Command Interface mit execute() Methode
   \item Konkrete Commands für spezifische Aktionen
   \item Invoker ruft Commands auf
   \item Optional: Undo/Redo Funktionalität
\end{itemize}
\end{definition}

\begin{definition}{Template Method Pattern}\\
\textbf{Problem:}
\begin{itemize}
   \item Algorithmus-Struktur fest, aber Schritte variabel
   \item Code-Duplizierung vermeiden
   \item Erweiterbarkeit gewährleisten
\end{itemize}

\textbf{Lösung:}
\begin{itemize}
   \item Abstrakte Basisklasse definiert Algorithmus-Skelett
   \item Hook Methods für variable Schritte
   \item Konkrete Klassen implementieren Hook Methods
\end{itemize}
\end{definition}

\begin{definition}{Singleton Pattern}\\
\textbf{Problem:} Genau eine Instanz benötigt
\begin{itemize}
    \item Globaler Zugriffspunkt
    \item Mehrfachinstanzierung verhindern
\end{itemize}
\textbf{Lösung:} Statische Instanz mit privater Erzeugung
\end{definition}

\subsubsection{Anwendung und Implementation der Design Patterns}

\begin{KR}{Pattern-Analyse für Prüfung}\\
\textbf{Systematisches Vorgehen:}
\begin{enumerate}
    \item \textbf{Problem identifizieren und analysieren}
    \begin{itemize}
        \item Art des Problems identifizieren
        \item Anforderungen klar definieren
        \item Welche Flexibilität wird benötigt?
        \item Welche Einschränkungen gibt es?
        \item Kontext verstehen
    \end{itemize}
    
    \item \textbf{Pattern auswählen und evaluieren}
    \begin{itemize}
        \item Passende Patterns suchen
        \item Welche Patterns lösen ähnliche Probleme?
        \item Wie unterscheiden sich die Patterns?
        \item Welche Trade-offs gibt es? (Komplexität, Flexibilität)
    \end{itemize}
    
    \item \textbf{Lösung skizzieren}
    \begin{itemize}
        \item Klassenstruktur entwerfen
        \item Beziehungen/Schnittstellen definieren
        \item Vor- und Nachteile nennen
        \item Anpassungen für spezifisches Problem
    \end{itemize}
\end{enumerate}
\end{KR}

\begin{formula}{Pattern Vergleichstabelle}\\
\textbf{Creational Patterns:}
\begin{itemize}
   \item \textbf{Abstract Factory:} Familien verwandter Objekte
   \item \textbf{Factory Method:} Objekterzeugung durch Subklassen
   \item \textbf{Singleton:} Genau eine Instanz
   \item \textbf{Builder:} Komplexe Objektkonstruktion
   \item \textbf{Prototype:} Klonen existierender Objekte
\end{itemize}

\textbf{Structural Patterns:}
\begin{itemize}
   \item \textbf{Adapter:} Inkompatible Interfaces verbinden
   \item \textbf{Bridge:} Abstraktion von Implementation trennen
   \item \textbf{Composite:} Baumstrukturen einheitlich behandeln
   \item \textbf{Decorator:} Dynamisch Funktionalität erweitern
   \item \textbf{Facade:} Subsystem vereinfachen
   \item \textbf{Proxy:} Zugriffskontrolle auf Objekte
\end{itemize}

\textbf{Behavioral Patterns:}
\begin{itemize}
   \item \textbf{Chain of Responsibility:} Anfragen durch Handler-Kette
   \item \textbf{Command:} Requests als Objekte
   \item \textbf{Observer:} Abhängigkeiten bei Zustandsänderungen
   \item \textbf{Strategy:} Austauschbare Algorithmen
   \item \textbf{Template Method:} Skelett eines Algorithmus
   \item \textbf{State:} Zustandsabhängiges Verhalten
\end{itemize}
\end{formula}

\begin{example2}{Pattern-Vergleich: Adapter vs. Facade}
\textbf{Gegeben sind zwei Patterns. Vergleichen Sie diese:}

\textbf{Adapter:}
\begin{itemize}
    \item \textbf{Zweck:} Inkompatible Schnittstellen vereinen
    \item \textbf{Struktur:} Wrapper um einzelne Klasse
    \item \textbf{Anwendung:} Bei existierenden, inkompatiblen Klassen
\end{itemize}

\textbf{Facade:}
\begin{itemize}
    \item \textbf{Zweck:} Komplexes Subsystem vereinfachen
    \item \textbf{Struktur:} Neue Schnittstelle für mehrere Klassen
    \item \textbf{Anwendung:} Bei komplexen Subsystemen
\end{itemize}

\textbf{Kernunterschiede:}
\begin{itemize}
    \item Adapter ändert Interface, Facade vereinfacht
    \item Adapter für einzelne Klasse, Facade für Subsystem
    \item Adapter für Kompatibilität, Facade für Vereinfachung
\end{itemize}
\end{example2}



\begin{KR}{Pattern Implementierung}\\
\textbf{1. Analyse}
\begin{itemize}
   \item Pattern-Struktur verstehen
   \item Anpassungen identifizieren
   \item Schnittstellen definieren
\end{itemize}

\textbf{2. Design}
\begin{itemize}
   \item Klassenstruktur erstellen
   \item Beziehungen definieren
   \item Methodensignaturen festlegen
\end{itemize}

\textbf{3. Implementation}
\begin{itemize}
   \item Code-Struktur aufbauen
   \item Schnittstellen implementieren
   \item Tests erstellen
\end{itemize}

\textbf{4. Review}
\begin{itemize}
   \item Pattern-Konformität prüfen
   \item Komplexität bewerten
   \item Testabdeckung sicherstellen
\end{itemize}
\end{KR}

\begin{example2}{Prüfungsaufgabe: Pattern-Identifikation}
\textbf{Szenario:}
Ein Dokumentensystem soll verschiedene Dateitypen (.pdf, .doc, .txt) einheitlich 
behandeln. Jeder Dateityp benötigt eine spezielle Verarbeitung für Öffnen, 
Speichern und Drucken.

\textbf{Aufgabe:}
\begin{enumerate}
    \item Identifizieren Sie geeignete Design Patterns
    \item Begründen Sie Ihre Auswahl
    \item Skizzieren Sie die Struktur der Lösung
\end{enumerate}

\textbf{Musterlösung:}
\begin{itemize}
    \item \textbf{Mögliche Patterns:}
    \begin{itemize}
        \item Strategy (für Verarbeitungslogik)
        \item Factory (für Dokumenterstellung)
        \item Adapter (für einheitliche Schnittstelle)
    \end{itemize}
    
    \item \textbf{Begründung Strategy:}
    \begin{itemize}
        \item Unterschiedliche Algorithmen pro Dateityp
        \item Austauschbarkeit der Verarbeitung
        \item Erweiterbar für neue Dateitypen
    \end{itemize}
    
    \item \textbf{Struktur:}
    \begin{itemize}
        \item Interface DocumentProcessor
        \item Konkrete Prozessoren pro Dateityp
        \item Context-Klasse Document
    \end{itemize}
\end{itemize}
\end{example2}

\begin{KR}{Pattern Anti-Patterns}\\
\textbf{1. Überflüssige Pattern-Anwendung:}
\begin{itemize}
   \item Komplexität ohne Nutzen
   \item Pattern als Selbstzweck
   \item Übertriebene Abstraktion
\end{itemize}

\textbf{2. Falsche Pattern-Wahl:}
\begin{itemize}
   \item Pattern passt nicht zum Problem
   \item Bessere Alternativen ignoriert
   \item Performance-Probleme
\end{itemize}

\textbf{3. Schlechte Implementation:}
\begin{itemize}
   \item Pattern-Struktur nicht eingehalten
   \item Schlechte Namensgebung
   \item Inkonsistente Verwendung
\end{itemize}
\end{KR}



\begin{KR}{Pattern-Kombination}
\textbf{Schritte zur Kombination mehrerer Patterns:}
\begin{enumerate}
    \item \textbf{Abhängigkeiten analysieren}
    \begin{itemize}
        \item Welche Patterns ergänzen sich?
        \item Wo gibt es Überschneidungen?
        \item Welche Reihenfolge ist sinnvoll?
    \end{itemize}
    
    \item \textbf{Struktur entwerfen}
    \begin{itemize}
        \item Gemeinsame Schnittstellen identifizieren
        \item Verantwortlichkeiten zuordnen
        \item Komplexität im Auge behalten
    \end{itemize}
    
    \item \textbf{Integration planen}
    \begin{itemize}
        \item Übergänge zwischen Patterns definieren
        \item Konsistenz sicherstellen
        \item Testbarkeit gewährleisten
    \end{itemize}
\end{enumerate}
\end{KR}



\begin{example2}{Komplexe Pattern-Anwendung}\\
\textbf{Szenario:} Dokumentverarbeitungssystem

\textbf{Anforderungen:}
\begin{itemize}
   \item Verschiedene Dokumenttypen (PDF, DOC, TXT)
   \item Unterschiedliche Speicherorte (Lokal, Cloud)
   \item Verschiedene Verarbeitungsoperationen
   \item Erweiterbarkeit für neue Formate
\end{itemize}

\textbf{Pattern-Kombination:}
\begin{itemize}
   \item \textbf{Abstract Factory:} Dokumenterzeugung
   \item \textbf{Strategy:} Verarbeitungsalgorithmen
   \item \textbf{Adapter:} Speicheranbindung
   \item \textbf{Command:} Operationen
\end{itemize}

\textbf{Implementierung:}
\begin{lstlisting}[language=Java, style=basesmol]
// Abstract Factory
public interface DocumentFactory {
   Document createDocument();
   Storage createStorage();
}
// Strategy
public interface ProcessingStrategy {
   void process(Document doc);
}
// Command
public interface DocumentCommand {
   void execute();
   void undo();
}
// Adapter
public class CloudStorageAdapter implements Storage {
   private CloudService service;
   
   public void save(Document doc) {
       service.upload(doc.getBytes());
   }
}
\end{lstlisting}
\end{example2}



\begin{example2}{Exam-Style Pattern Recognition}\\
\textbf{Aufgabe:} Analysieren Sie den folgenden Code und identifizieren Sie verwendete Patterns:

\begin{lstlisting}[language=Java, style=basesmol]
public interface PaymentStrategy {
   void pay(int amount);
}

public class CreditCardPayment implements PaymentStrategy {
   private String cardNum;
   
   public void pay(int amount) {
       // Process credit card payment
   }
}

public class PayPalPayment implements PaymentStrategy {
   private String email;
   
   public void pay(int amount) {
       // Process PayPal payment
   }
}

public class ShoppingCart {
   private PaymentStrategy paymentMethod;
   
   public void setPaymentMethod(PaymentStrategy method) {
       this.paymentMethod = method;
   }
   
   public void checkout(int amount) {
       paymentMethod.pay(amount);
   }
}
\end{lstlisting}

\textbf{Lösung:}
\begin{itemize}
   \item Identifiziertes Pattern: Strategy
   \item Begründung:
   \begin{itemize}
       \item Interface für austauschbare Algorithmen
       \item Konkrete Strategien für verschiedene Zahlungsmethoden
       \item Kontext (ShoppingCart) verwendet Strategy-Interface
   \end{itemize}
   \item Vorteile:
   \begin{itemize}
       \item Neue Zahlungsmethoden einfach hinzufügbar
       \item Lose Kopplung zwischen Kontext und Algorithmus
       \item Zahlungsmethode zur Laufzeit änderbar
   \end{itemize}
\end{itemize}
\end{example2}