\subsection{Examples}











\begin{KR}{Stack Analysis in Nested Subroutine Calls} from exercise sheet 8\\
Steps to analyze stack content in nested subroutine calls:

\textbf{1. Track initial stack pointer value}: Note starting SP value
\begin{itemize}
  \item Stack grows downward in memory
\end{itemize}

\textbf{2. For each PUSH instruction}: Subtract 4 bytes per register
\begin{itemize}
  \item Write values in order specified
  \item Remember which subroutine saved what
\end{itemize}

\textbf{3. For subroutine calls (BL)}: LR gets set to return address
\begin{itemize}
  \item If LR needs to be saved (nested calls), it must be PUSHed
\end{itemize}

\textbf{4. Keep track through nested calls}:
\begin{itemize}
  \item Each nested level maintains its own stack frame
  \item Stack unwinds in reverse order when returning
\end{itemize}
\end{KR}

\begin{example2}{Simple Stack Analysis}\\
Consider this simple nested call sequence:

\begin{lstlisting}[language=armasm, style=basesmol]
main    ; SP = 0x20002000
        LDR     R0, =0x11111111
        LDR     R1, =0x22222222
        BL      funcA          ; Z1
        B       endless

funcA   PUSH    {R0, R1, LR}  ; Z2
        BL      funcB
        POP     {R0, R1, PC}

funcB   PUSH    {R4, LR}      ; Z3
        MOVS    R4, #42
        POP     {R4, PC}
\end{lstlisting}

Stack contents at Z1, Z2, Z3:

\begin{lstlisting}[style=basesmol]
Z1: Stack is empty, SP = 0x20002000

Z2: Stack from top (higher address):           
0x20001FF4: Return addr to main
0x20001FF0: 0x22222222 (R1)
0x20001FEC: 0x11111111 (R0)
SP = 0x20001FEC

Z3: Stack from top (higher address):
0x20001FE4: Return addr to funcA
0x20001FE0: R4 value
0x20001FF4: Return addr to main (from Z2)
0x20001FF0: 0x22222222 (R1 from Z2)
0x20001FEC: 0x11111111 (R0 from Z2)
SP = 0x20001FE0
\end{lstlisting}
\end{example2}