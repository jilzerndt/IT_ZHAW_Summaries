\section{Arithmetic Operations}

\begin{concept}{Processor Status Flags}\\
APSR (Application Program Status Register) contains important flags affected by arithmetic operations:
\begin{itemize}
  \item \textbf{N} (Negative): Set when result's MSB = 1, used for signed operations
  \item \textbf{Z} (Zero): Set when result = 0, used for both signed/unsigned
  \item \textbf{C} (Carry): Set when unsigned overflow occurs
  \item \textbf{V} (Overflow): Set when signed overflow occurs
\end{itemize}

Instructions ending with 'S' modify these flags:
\begin{itemize}
  \item ADDS, SUBS, MOVS, LSLS
\end{itemize}
\end{concept}

\begin{definition}{Basic Arithmetic Instructions}\\
Core arithmetic operations:
\begin{itemize}
  \item \textbf{ADD/ADDS}: Addition ($A + B$)
  \item \textbf{ADCS}: Addition with Carry ($A + B + c$)
  \item \textbf{ADR}: Address to Register ($PC + A$)
  \item \textbf{SUB/SUBS}: Subtraction ($A - B$)
  \item \textbf{SBCS}: Subtraction with carry/borrow ($A - B - !c$)
  \item \textbf{RSBS}: Reverse Subtract ($-1 \cdot A$)
  \item \textbf{MULS}: Multiplication ($A \cdot B$)
\end{itemize}
\end{definition}

\begin{definition}{Two's Complement}\\
For negative numbers:
\begin{itemize}
  \item Two's complement: $A = !A + 1$
  \item Used for representing signed numbers
  \item Enables using same hardware for addition and subtraction
\end{itemize}
\end{definition}

\begin{concept}{Carry and Overflow}\\
\textbf{Unsigned Operations:}
\begin{itemize}
  \item Addition: C = 1 indicates carry (result too large)
  \item Subtraction: C = 0 indicates borrow (result negative)
\end{itemize}

\textbf{Signed Operations:}
\begin{itemize}
  \item Addition: V = 1 if overflow with operands of same sign
  \item Subtraction: V = 1 if overflow with operands of opposite signs
\end{itemize}
\end{concept}

\begin{example2}{Multi-Word Addition}
Adding 96-bit values using ADCS:

\includegraphics[width=\linewidth]{images/2024_12_29_79e6b22f503fb7b4f718g-04}

\begin{lstlisting}[language=armasm, style=basesmol]
    ADDS R1, R1, R4    ; Add least significant words
    ADCS R2, R2, R5    ; Add middle words with carry
    ADCS R3, R3, R6    ; Add most significant words with carry
\end{lstlisting}
\end{example2}

\begin{example2}{Multi-Word Subtraction}
Subtracting 96-bit values using SBCS:

\includegraphics[width=\linewidth]{images/2024_12_29_79e6b22f503fb7b4f718g-04(1)}

\begin{lstlisting}[language=armasm, style=basesmol]
    SUBS R1, R1, R4    ; Subtract least significant words
    SBCS R2, R2, R5    ; Subtract middle words with borrow
    SBCS R3, R3, R6    ; Subtract most significant words with borrow
\end{lstlisting}
\end{example2}

\begin{example2}{Addition and Subtraction Examples}
Addition with carry (13d + 7d):
\begin{verbatim}
  1101  (13d)
  0111  (7d)
  ----
1 0100  (20d = 16d + 4d)
\end{verbatim}

Subtraction with borrow (6d - 14d):
\begin{verbatim}
  0110  (6d)
+ 0010  (TC of 14d)
  ----
  1000  (8d - 16d = -8d)
\end{verbatim}

\includegraphics[width=\linewidth]{images/2024_12_29_79e6b22f503fb7b4f718g-04(2)}
\end{example2}

\begin{KR}{Arithmetic Operations}\\
Steps for arithmetic operations:
\begin{enumerate}
  \item Determine if operation is signed or unsigned
  \item Choose appropriate instruction (with or without 'S')
  \item Consider potential carry/overflow conditions
  \item For multi-word operations:
    \begin{itemize}
      \item Start with least significant words
      \item Use carry-aware instructions for higher words
      \item Track flags through operation
    \end{itemize}
  \item Check relevant flags after operation
\end{enumerate}
\end{KR}

\begin{concept}{ALU Operation Fundamentals}\\
The Arithmetic Logic Unit (ALU) processes data:
\begin{itemize}
  \item 32-bit wide data processing unit
  \item Fixed point operations only (no floating point)
  \item Flag outputs indicate operation results
  \item Can perform both signed and unsigned operations
  \item Same hardware used for addition and subtraction
\end{itemize}
\end{concept}

\begin{formula}{Addition Operations}\\
Addition instructions and their uses:
\begin{itemize}
  \item \textbf{ADDS Rd, Rn, Rm}
    \begin{itemize}
      \item Rd = Rn + Rm
      \item Updates flags
      \item Only low registers
    \end{itemize}
  \item \textbf{ADD Rd, Rm}
    \begin{itemize}
      \item Rd = Rd + Rm
      \item No flag updates
      \item Can use high registers
    \end{itemize}
  \item \textbf{ADDS Rd, \#imm}
    \begin{itemize}
      \item Rd = Rd + immediate
      \item 8-bit immediate value only
    \end{itemize}
\end{itemize}

Example encodings:
\begin{lstlisting}[language=armasm, style=base]
    ; Different ADD variants
    ADDS    R1, R2, R3      ; R1 = R2 + R3, update flags
    ADD     R8, R9          ; R8 = R8 + R9, no flags
    ADDS    R1, #255        ; R1 = R1 + 255, update flags
\end{lstlisting}
\end{formula}

\begin{formula}{Subtraction Operations}\\
Subtraction instructions and their uses:
\begin{itemize}
  \item \textbf{SUBS Rd, Rn, Rm}
    \begin{itemize}
      \item Rd = Rn - Rm
      \item Updates flags
      \item Only low registers
    \end{itemize}
  \item \textbf{SUBS Rd, \#imm}
    \begin{itemize}
      \item Rd = Rd - immediate
      \item 8-bit immediate value
    \end{itemize}
  \item \textbf{RSBS Rd, Rn, \#0}
    \begin{itemize}
      \item Rd = -Rn (2's complement)
      \item Special case for negation
    \end{itemize}
\end{itemize}

Example encodings:
\begin{lstlisting}[language=armasm, style=base]
    ; Different SUB variants
    SUBS    R1, R2, R3      ; R1 = R2 - R3
    SUBS    R1, #100        ; R1 = R1 - 100
    RSBS    R1, R2, #0      ; R1 = -R2
\end{lstlisting}
\end{formula}

\begin{KR}{Overflow Detection}\\
Steps to detect overflow in arithmetic operations:

1. For unsigned arithmetic (using C flag):
\begin{itemize}
  \item Addition: Check C flag (C=1 means overflow)
  \item Subtraction: Check C flag (C=0 means underflow)
\end{itemize}

2. For signed arithmetic (using V flag):
\begin{itemize}
  \item Addition: Check V flag for same-sign operands
  \item Subtraction: Check V flag for opposite-sign operands
\end{itemize}

Example:
\begin{lstlisting}[language=armasm, style=base]
    ; Unsigned overflow detection
    ADDS    R0, R1          ; Perform addition
    BCS     overflow        ; Branch if carry set
    
    ; Signed overflow detection
    ADDS    R0, R1          ; Perform addition
    BVS     overflow        ; Branch if overflow set
\end{lstlisting}
\end{KR}

\begin{example2}{Flag Usage}
Examples of flag behavior:
\begin{lstlisting}[language=armasm, style=base]
    ; Zero flag example
    MOVS    R0, #5
    SUBS    R0, #5          ; Z=1 (result is zero)
    
    ; Negative flag example
    MOVS    R0, #1
    SUBS    R0, #2          ; N=1 (result is negative)
    
    ; Carry flag example
    MOVS    R0, #0xFF
    ADDS    R0, #1          ; C=1 (unsigned overflow)
    
    ; Overflow flag example
    MOVS    R0, #0x7F       ; Max positive 8-bit
    ADDS    R0, #1          ; V=1 (signed overflow)
\end{lstlisting}
\end{example2}

\begin{concept}{Number Circles and Two's Complement}\\
Understanding arithmetic wrap-around:
\begin{itemize}
  \item Fixed number of bits creates circular number space
  \item Addition moves clockwise on number circle
  \item Subtraction moves counter-clockwise
  \item Two's complement:
    \begin{itemize}
      \item Invert all bits (one's complement)
      \item Add 1 to result
      \item Enables using addition hardware for subtraction
    \end{itemize}
\end{itemize}

Example for 4-bit numbers:
\begin{verbatim}
Positive: 0000 to 0111 (0 to 7)
Negative: 1000 to 1111 (-8 to -1)
\end{verbatim}
\end{concept}

\begin{KR}{Multi-Word Arithmetic}\\
Guidelines for operations on large numbers:

1. Addition sequence:
\begin{lstlisting}[language=armasm, style=base]
    ; 64-bit addition (R1:R0 + R3:R2)
    ADDS    R0, R2          ; Add low words
    ADCS    R1, R3          ; Add high words with carry
\end{lstlisting}

2. Subtraction sequence:
\begin{lstlisting}[language=armasm, style=base]
    ; 64-bit subtraction (R1:R0 - R3:R2)
    SUBS    R0, R2          ; Subtract low words
    SBCS    R1, R3          ; Subtract high words with borrow
\end{lstlisting}

3. Important considerations:
\begin{itemize}
  \item Start with least significant words
  \item Use carry-aware instructions for higher words
  \item Ensure proper register allocation
  \item Track flags through entire operation
\end{itemize}
\end{KR}

\begin{example2}{Multiplication}
Simple multiplication examples:
\begin{lstlisting}[language=armasm, style=base]
    ; Basic multiplication
    MULS    R0, R1, R0      ; R0 = R1 * R0
    
    ; Multiply by constant using shifts
    LSLS    R0, R0, #2      ; R0 = R0 * 4
    
    ; Multiply by 10 (8 + 2)
    LSLS    R1, R0, #3      ; R1 = R0 * 8
    LSLS    R2, R0, #1      ; R2 = R0 * 2
    ADDS    R0, R1, R2      ; R0 = R0 * 10
\end{lstlisting}
\end{example2}

\begin{concept}{ALU Operation Fundamentals}\\
The Arithmetic Logic Unit (ALU) processes data:
\begin{itemize}
  \item 32-bit wide data processing unit
  \item Fixed point operations only (no floating point)
  \item Flag outputs indicate operation results
  \item Can perform both signed and unsigned operations
  \item Same hardware used for addition and subtraction
\end{itemize}
\end{concept}

\begin{formula}{Addition Operations}\\
Addition instructions and their uses:
\begin{itemize}
  \item \textbf{ADDS Rd, Rn, Rm}
    \begin{itemize}
      \item Rd = Rn + Rm
      \item Updates flags
      \item Only low registers
    \end{itemize}
  \item \textbf{ADD Rd, Rm}
    \begin{itemize}
      \item Rd = Rd + Rm
      \item No flag updates
      \item Can use high registers
    \end{itemize}
  \item \textbf{ADDS Rd, \#imm}
    \begin{itemize}
      \item Rd = Rd + immediate
      \item 8-bit immediate value only
    \end{itemize}
\end{itemize}

Example encodings:
\begin{lstlisting}[language=armasm, style=base]
    ; Different ADD variants
    ADDS    R1, R2, R3      ; R1 = R2 + R3, update flags
    ADD     R8, R9          ; R8 = R8 + R9, no flags
    ADDS    R1, #255        ; R1 = R1 + 255, update flags
\end{lstlisting}
\end{formula}

\begin{formula}{Subtraction Operations}\\
Subtraction instructions and their uses:
\begin{itemize}
  \item \textbf{SUBS Rd, Rn, Rm}
    \begin{itemize}
      \item Rd = Rn - Rm
      \item Updates flags
      \item Only low registers
    \end{itemize}
  \item \textbf{SUBS Rd, \#imm}
    \begin{itemize}
      \item Rd = Rd - immediate
      \item 8-bit immediate value
    \end{itemize}
  \item \textbf{RSBS Rd, Rn, \#0}
    \begin{itemize}
      \item Rd = -Rn (2's complement)
      \item Special case for negation
    \end{itemize}
\end{itemize}

Example encodings:
\begin{lstlisting}[language=armasm, style=base]
    ; Different SUB variants
    SUBS    R1, R2, R3      ; R1 = R2 - R3
    SUBS    R1, #100        ; R1 = R1 - 100
    RSBS    R1, R2, #0      ; R1 = -R2
\end{lstlisting}
\end{formula}

\begin{KR}{Overflow Detection}\\
Steps to detect overflow in arithmetic operations:

1. For unsigned arithmetic (using C flag):
\begin{itemize}
  \item Addition: Check C flag (C=1 means overflow)
  \item Subtraction: Check C flag (C=0 means underflow)
\end{itemize}

2. For signed arithmetic (using V flag):
\begin{itemize}
  \item Addition: Check V flag for same-sign operands
  \item Subtraction: Check V flag for opposite-sign operands
\end{itemize}

Example:
\begin{lstlisting}[language=armasm, style=base]
    ; Unsigned overflow detection
    ADDS    R0, R1          ; Perform addition
    BCS     overflow        ; Branch if carry set
    
    ; Signed overflow detection
    ADDS    R0, R1          ; Perform addition
    BVS     overflow        ; Branch if overflow set
\end{lstlisting}
\end{KR}

\begin{example2}{Flag Usage}
Examples of flag behavior:
\begin{lstlisting}[language=armasm, style=base]
    ; Zero flag example
    MOVS    R0, #5
    SUBS    R0, #5          ; Z=1 (result is zero)
    
    ; Negative flag example
    MOVS    R0, #1
    SUBS    R0, #2          ; N=1 (result is negative)
    
    ; Carry flag example
    MOVS    R0, #0xFF
    ADDS    R0, #1          ; C=1 (unsigned overflow)
    
    ; Overflow flag example
    MOVS    R0, #0x7F       ; Max positive 8-bit
    ADDS    R0, #1          ; V=1 (signed overflow)
\end{lstlisting}
\end{example2}

\begin{concept}{Number Circles and Two's Complement}\\
Understanding arithmetic wrap-around:
\begin{itemize}
  \item Fixed number of bits creates circular number space
  \item Addition moves clockwise on number circle
  \item Subtraction moves counter-clockwise
  \item Two's complement:
    \begin{itemize}
      \item Invert all bits (one's complement)
      \item Add 1 to result
      \item Enables using addition hardware for subtraction
    \end{itemize}
\end{itemize}

Example for 4-bit numbers:
\begin{verbatim}
Positive: 0000 to 0111 (0 to 7)
Negative: 1000 to 1111 (-8 to -1)
\end{verbatim}
\end{concept}

\begin{KR}{Multi-Word Arithmetic}\\
Guidelines for operations on large numbers:

1. Addition sequence:
\begin{lstlisting}[language=armasm, style=base]
    ; 64-bit addition (R1:R0 + R3:R2)
    ADDS    R0, R2          ; Add low words
    ADCS    R1, R3          ; Add high words with carry
\end{lstlisting}

2. Subtraction sequence:
\begin{lstlisting}[language=armasm, style=base]
    ; 64-bit subtraction (R1:R0 - R3:R2)
    SUBS    R0, R2          ; Subtract low words
    SBCS    R1, R3          ; Subtract high words with borrow
\end{lstlisting}

3. Important considerations:
\begin{itemize}
  \item Start with least significant words
  \item Use carry-aware instructions for higher words
  \item Ensure proper register allocation
  \item Track flags through entire operation
\end{itemize}
\end{KR}

\begin{example2}{Multiplication}
Simple multiplication examples:
\begin{lstlisting}[language=armasm, style=base]
    ; Basic multiplication
    MULS    R0, R1, R0      ; R0 = R1 * R0
    
    ; Multiply by constant using shifts
    LSLS    R0, R0, #2      ; R0 = R0 * 4
    
    ; Multiply by 10 (8 + 2)
    LSLS    R1, R0, #3      ; R1 = R0 * 8
    LSLS    R2, R0, #1      ; R2 = R0 * 2
    ADDS    R0, R1, R2      ; R0 = R0 * 10
\end{lstlisting}
\end{example2}