

\section{JavaScript}
\begin{formula}{Web-Konsole}
    In JS mit dem Keyword \texttt{console}:
    \begin{itemize}
        \item \texttt{console.log(message)}: Loggt eine Nachricht
        \item \texttt{console.clear()}: Löscht die Konsole
        \item \texttt{console.trace(message)}: Stack trace ausgeben
        \item \texttt{console.error(message)}: stderr ausgeben
        \item \texttt{console.time()}: Startet einen Timer
        \item \texttt{console.timeEnd()}: Stoppt den Timer
    \end{itemize}
    Website für Konsolen-API: \url{https://nodejs.org/api/console.html}
\end{formula}

\begin{definition}{Datentypen}
    \begin{itemize}
        \item \texttt{undefined}: Variable wurde deklariert, aber nicht initialisiert
        \item \texttt{null}: Variable wurde deklariert und initialisiert, aber nicht belegt
        \item \texttt{Symbol}: Eindeutiger, unveränderlicher Wert
        \item \texttt{Number}: Ganze Zahlen, Fließkommazahlen, NaN, Infinity
        \begin{itemize}
            \item Infinity: $1/0$, $-1/0$
            \item NaN: $0/0$, $\sqrt{-1}$
        \end{itemize}
        \item \texttt{BigInt}: Ganze Zahlen beliebiger Größe
        \item \texttt{Object}: Sammlung von Schlüssel-Wert-Paaren
        \item \texttt{Function}: Funktionen sind Objekte
    \end{itemize}
\end{definition}

\begin{code}{typeof}

Mit dem Keyword \texttt{typeof} kann der Datentyp zurückgegeben werden:
\begin{lstlisting}[language=JavaScript, style=base]
typeof 12       // 'number'
typeof(12)      // 'number'
typeof 2n       // 'bigint'
typeof Infinity // 'number'
typeof NaN      // 'number' !!
typeof 'number' // 'string'
\end{lstlisting}
\end{code}

\begin{theorem}{Variablen und Variablenbindung}

    \begin{tabular}{|l|l|l|}
        \hline
        Keyword & Scope & Binding \\ 
        \hline
        \texttt{var} & Global oder lokal & Funktionsbindung \\ 
        \hline
        \texttt{let} & Nur lokal & Blockbindung \\ 
        \hline
        \texttt{const} & Konstante & Blockbindung \\ 
        \hline
    \end{tabular}
\end{theorem}

\begin{corollary}{Operatoren}
    \begin{itemize}
        \item Arithmetische Operatoren: $+, -, *, /, \%, ++, --$
        \item Zuweisungsoperatoren: $=, +=, -=, *=, /=, \%=, **=, $\\$<<=, >>=, >>>=, \&=, ^=, |=$
        \item Vergleichsoperatoren: $==, ===, !=, !==, >, <, >=, <=$
        \item Logische Operatoren: $\&\&, ||, !$
        \item Bitweise Operatoren: $\&, |, ^, ~, <<, >>, >>>$
        \item Sonstige Operatoren: \texttt{typeof}, \texttt{instanceof}
    \end{itemize}
\end{corollary}

\begin{formula}{Vergleich mit \texttt{==} und \texttt{===}}
    \begin{itemize}
        \item \texttt{==}: Vergleicht Werte, konvertiert Datentypen
        \item \texttt{===}: Vergleicht Werte und Datentypen ohne Konvertierung
    \end{itemize}
    ebenfalls: \texttt{!=} und \texttt{!==}
\end{formula}

\begin{KR}{Verzweigungen\text{,} Wiederholung und Switch Case}
    \begin{itemize}
        \item \texttt{if (condition) \{...\} else \{...\}}
        \item \texttt{switch (expression) \{ case x: ... break; default: ... \}}
        \item \texttt{for (initialization; condition; increment) \{...\}}
        \item \texttt{while (condition) \{...\}}
        \item \texttt{do \{...\} while (condition)}
        \item \texttt{for (let x of iterable) \{...\}}
    \end{itemize}
\end{KR}

\begin{KR}{Funktionsdefinition}
    \begin{itemize}
        \item \texttt{function name(parameters) \{...\}}
        \item \texttt{const name = (parameters) => \{...\}}
        \item \texttt{const name = parameters => \{...\}}
        \item \texttt{const name = parameters => expression}
    \end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
function add(a, b) {    // Beispiel einer Funktion
    return a + b;
}
const add = (a, b) => a + b;    // Arrow-Funktion
\end{lstlisting}
\end{KR}

\subsection{Objekte und Arrays}

\begin{theorem}{Objekt vs Array}

    \begin{tabular}{|l|l|l|}
        \hline
        Was & Objekt & Array \\
        \hline
        Art & Attribut-Wert-Paare & Sequenz von Werten \\
        \hline
        Literalnotation & werte $=\{$ a: 1, b: 2$\}$ & liste $=[1,2,3]$ \\
        \hline
        Ohne Inhalt & werte $=\{ \}$ & liste $=[]$ \\
        \hline
        Elementzugriff & werte[''a'' $]$ oder werte.a & liste[0] \\
        \hline
        \end{tabular}
\end{theorem}

\begin{concept}{Json}
    JavaScript Object Notation
    \begin{itemize}
    \item Daten-Austauschformat, nicht nur für JavaScript
    \item Orientiert an Notation für JavaScript-Objektliterale
  \end{itemize}
  https://www.json.org/json-en.html
\begin{lstlisting}[language=JavaScript, style=basesmol]
> JSON.stringify({type: "cat", name: "Mimi", age: 3})
'{"type":"cat", "name":"Mimi", "age":3}'
> JSON.parse('{"type": "cat", "name": "Mimi", "age": 3}')
{type: 'cat', name: 'Mimi', age: 3}
\end{lstlisting}
\end{concept}

\begin{definition}{Objekte}
    \begin{itemize}
        \item Objekt Attribute sind dynamisch und können einfach erweitert werden:
        \item Objekt Attribute können auch einfach mit dem delete keyword entfernt werden.
        \item Mit in kann überprüft werden, ob ein Attribut existiert
    \end{itemize}
\end{definition}

\begin{examplecode}{working with objects}
\begin{lstlisting}[language=JavaScript, style=basesmol]
let person = {
    name: "John Baker",
    age: 23,
    "exam results": [5.5, 5.0, 5.0, 6.0, 4.5]
}
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, style=basesmol]
let obj = { message: "not yet implemented" }
obj.ready = false
console.log(obj)
// { message: 'not yet implemented', ready: false }
console.log(obj.attr)   // undefined

\end{lstlisting}

\begin{lstlisting}[language=JavaScript, style=basesmol]
let obj = { message: "ready", ready: true, tasks: 3 }
delete obj.message
obj.tasks = undefined
console.log(obj)
// { ready: true, tasks: undefined }
console.log("message" in obj)   // false
console.log("tasks" in obj)     // true
\end{lstlisting}
\end{examplecode}

\begin{code}{Methoden}
    Ein Objekt kann auch Methoden enthalten:
\begin{lstlisting}[language=JavaScript, style=basesmol]
> let cat = { type: "cat", sayHello: () => "Meow" }
> cat.sayHello
[Function: sayHello]
> cat.sayHello()
'Meow'
\end{lstlisting}
\end{code}

\begin{formula}{Arrays}
    Verschiedene Hilfsfunktionen:

    \begin{minipage}{0.45\linewidth}
                \begin{itemize}
                        \item \texttt{Array.isArray()}
                        \item \texttt{.push()}
                        \item \texttt{.pop()}
                        \item \texttt{Indexof}, \texttt{lastIndexOf}
                \end{itemize}
        \end{minipage}
        \begin{minipage}{0.5\linewidth}
                \begin{itemize}
                        \item \texttt{Concat}
                        \item \texttt{slice}
                        \item \texttt{Shift}, \texttt{unshift}
                        \item \texttt{.forEach(item => ....)}
                \end{itemize}
        \end{minipage}
    \includegraphics[width=0.5\linewidth]{images/array_cheatsheet.png}

    \textcolor{red}{Achtung:} draw new!!!
\end{formula}
 





\subsection{Funktionen und funktionale Programmierung}

\begin{definition}{Funktionen}
    \begin{itemize}
        \item Funktionen sind spezielle, aufrufbare Objekte
        \item Man kann ihnen jederzeit Attribute oder Methoden hinzufügen
        \item Sie haben bereits vordefinierte Methoden
      \end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
> const add = (x, y) => x + y
> add.doc = "This function adds two values"
> add(3,4)
7
> add.doc
'This function adds two values'
\end{lstlisting}
\end{definition}

\begin{concept}{Modulsystem in JavaScript}
    \begin{itemize}
        \item \texttt{import} und \texttt{export} für Module
        \item \texttt{export default} für Standardexport
        \item \texttt{import \{name\} from 'module'} für benannte Exports
        \item \texttt{import * as name from 'module'} für alle Exports
    \end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const car = {                   //car-lib.js
    brand: 'Ford',
    model: 'Fiesta'
}
module.exports = car
const car = require('./car-lib') //other js file
\end{lstlisting}
\end{concept}

\subsection{Prototypen von Objekten}

\begin{definition}{Prototypen}
    \begin{itemize}
        \item Die meisten Objekte haben ein Prototyp-Objekt.
        \item Dieses fungiert als Fallback für Attribute und Methoden.
      \end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol, numbers=none, xleftmargin=-2pt]
>Object.getPrototypeOf(Math.max)==Function.prototype
true
>Object.getPrototypeOf([])==Array.prototype
true
>Object.getPrototypeOf(Function.prototype)==Object.prototype
true
>Object.getPrototypeOf(Array.prototype)==Object.prototype
true
\end{lstlisting}
\end{definition}

\begin{concept}{Prototypen-Kette}
    Call, apply, bind
    \begin{itemize}
        \item Weitere Argumente von call : Argumente der Funktion
        \item Weiteres Argument von apply : Array mit den Argumenten
        \item Erzeugt neue Funktion mit gebundenem this
    \end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
function Employee (name, salary) {
    Person.call(this, name)
    this.salary = salary
}
Employee.prototype = new Person()
Employee.prototype.constructor = Employee
let e17 = new Employee("Mary", 7000)
console.log(e17.toString()) // Person with name 'Mary' 
console.log(e17.salary) // 7000 
\end{lstlisting}
\end{concept}

\begin{definition}{Klassen}
    \begin{itemize}
        \item Klassen sind syntaktischer Zucker für Prototypen
        \item Klassen können Attribute und Methoden enthalten
        \item Klassen können von anderen Klassen erben
    \end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
class Person {
    constructor (name) {
        this.name = name
    }
    toString () {
        return `Person with name '${this.name}'
    }
}
let p35 = new Person("John")
console.log(p35.toString()) // Person with name 'John'
\end{lstlisting}
\end{definition}

\begin{code}{Vererbung}
\begin{lstlisting}[language=JavaScript, style=basesmol]
class Employee extends Person {
    constructor (name, salary) {
        super(name)
        this.salary = salary
    }
    toString () {
        return `${super.toString()} and salary ${this.salary}
    }
}
let e17 = new Employee("Mary", 7000);
console.log(e17.toString()) /* Person with name 'Mary' and salary 7000 */
console.log(e17.salary) /* 7000 */
\end{lstlisting}
\end{code}

\begin{examplecode}{Getter und Setter}
\begin{lstlisting}[language=JavaScript, style=basesmol]
class PartTimeEmployee extends Employee {
    constructor (name, salary, percentage) {
        super(name, salary)
        this.percentage = percentage
    }
    get salary100 () { return this.salary * 100 / this.percentage}
    set salary100 (amount) { this.salary = amount * this.percentage / 100 }
}
let e18 = new PartTimeEmployee("Bob", 4000, 50)
console.log(e18.salary100) /* -> 8000 */
e18.salary100 = 9000
console.log(e18.salary) /* \ 4500 */
\end{lstlisting}
\end{examplecode}

\columnbreak
\subsection{Asynchrone Programmierung}

\subsubsection{Filesystem}

\begin{code}{Pfade der Datei}
Um Pfad-informationen einer Datei zu ermitteln muss man dies mit require('path') machen.
\begin{lstlisting}[language=JavaScript, style=basesmol]
const path = require('path')
const notes = '/users/bkrt/notes.txt'
path.dirname(notes) /* /users/bkrt */
path.basename(notes) /* notes.txt */
path.extname(notes) /* .txt */
path.basename(notes, path.extname(notes)) /* notes */
\end{lstlisting}
\end{code}

\begin{definition}{File API}
    Mit require('fs') wird auf die File-Api zugegriffen.
    Die File-Api bietet Funktionen zum Lesen und Schreiben von Dateien.
\end{definition}

\begin{formula}{FS Funktionen}
\begin{itemize}
    \item \texttt{fs.access}: Zugriff auf Datei oder Ordner prüfen
    \item \texttt{fs.mkdir}: Verzeichnis anlegen
    \item \texttt{fs.readdir}: Verzeichnis lesen, liefert Array von Einträgen
    \item \texttt{fs.rename}: Verzeichnis umbenennen
    \item \texttt{fs.rmdir}: Verzeichnis löschen
    \item \texttt{fs.chmod}: Berechtigungen ändern
    \item \texttt{fs.chown}: Besitzer und Gruppe ändern
    \item \texttt{fs.copyFile}: Datei kopieren
    \item \texttt{fs.link}: Besitzer und Gruppe ändern
    \item \texttt{fs.symlink}: Symbolic Link anlegen
    \item \texttt{fs.watchFile}: Datei auf Änderungen überwachen
\end{itemize}
\end{formula}

\begin{code}{Datei-Informationen}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const fs = require('fs')
fs.stat('test.txt' , (err, stats) => {
    if (err) {
    console.error(err)
    return
    }
    stats.isFile() /* true */
    stats.isDirectory() /* false */
    stats.isSymbolicLink() /* false */
stats.size /* 1024000 = ca 1MB */
})
\end{lstlisting}
\end{code}

\begin{examplecode}{Dateien lesen und schreiben}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const fs = require('fs')
fs.readFile('/etc/hosts',"utf8", (err, data) => {
        if (err) throw err
        console.log(data)
})

const content = 'Node was here!'
fs.writeFile('/Users/bkrt/test.txt', content, (err) => {
    if (err) {
        console.error(`Failed to write file: ${err}`)
        return
    } // file written successfully
})
\end{lstlisting}
\end{examplecode}

\columnbreak

\subsubsection{Callbacks und Timers}

\begin{definition}{Callbacks}
Ein Callback ist eine Funktion, welche als Argument einer anderen Funktion übergeben wird und erst aufgerufen wird, wenn das Ereignis eingetreten ist. 
In der folgenden Abbildung wird die KlickFunktion vom Button mit der Id «Button» abonniert.
\begin{lstlisting}[language=JavaScript, style=basesmol]
document.getElementById('button').addEventListener('click', () => {
//item clicked
})
\end{lstlisting}
\end{definition}

\begin{code}{SetTimeout}
\begin{itemize}
  \item Mit setTimeout kann Code definiert werden, der zu einem späteren Zeitpunkt ausgeführt werden soll
  \item Eintrag in die Timer-Liste, auch wenn Zeit auf 0 gesetzt wird
  \item Kann mit clearTimeout entfernt werden
\end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
setTimeout(() => {
    /* runs after 50 milliseconds */
}, 50)
\end{lstlisting}
\end{code}

\begin{code}{SetInterval}
\begin{itemize}
  \item Callback alle n Millisekunden in die Callback Queue eingefügt
  \item Kann mit clearInterval beendet werden
\end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const id = setInterval(() => {
// runs every 2 seconds
}, 2000)
clearInterval(id)
\end{lstlisting}
\end{code}

\begin{code}{SetImmediate}
\begin{itemize}
  \item Callback wird in die Immediate Queue eingefügt
  \item Wird nach dem aktuellen Event-Loop ausgeführt
\end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
setImmediate(() => {
    console.log('immediate')
})
\end{lstlisting}
\end{code}

\subsubsection{Events und Promises}

\begin{definition}{Event-Modul (EventMitter)}
\begin{itemize}
  \item EventEmitter verwaltet Liste von Listeners zu bestimmten Events
  \item Listener für das Event können hinzugefügt oder entfernt werden
  \item Event kann ausgelöst werden $\rightarrow$ Listener werden informiert
\end{itemize}
\end{definition}

\begin{examplecode}{Listener hinzufügen}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const EventEmitter = require('events')
const door = new EventEmitter()

door.on('open', () => {
    console.log('Door was opened')
})
\end{lstlisting}
\end{examplecode}

\begin{examplecode}{Event auslösen}
\begin{lstlisting}[language=JavaScript, style=basesmol]
door.on('open', (speed) => {
    console.log(`Door was opened, speed: ${speed || 'unknown'}`)
})

door.emit('open')
door.emit('open', 'slow')
\end{lstlisting}
\end{examplecode}

\begin{definition}{Promises}
Ist ein Platzhalter für einen Wert, der erst später voraussichtlich verfügbar sein wird.
Funktion mit Promise:
\begin{lstlisting}[language=JavaScript, style=basesmol]
function readFilePromise(file) {
    let promise = new Promise(function resolver(resolve, reject) {
        fs.readFile(file, "utf8", (err, data) => {
            if (err) reject(err);
            else resolve(data);
        });
    });
    return promise;
}
\end{lstlisting}
Gibt nun ein Promise-Object zurück
\end{definition}

\begin{concept}{Promise-Konstruktor erhält resolver-Funktion}

Rückgabe einer Promise: potentieller Wert kann später erfüllt oder zurückgewiesen werden
\begin{itemize}
  \item Rückgabe einer Promise: potentieller Wert
  \item kann später erfüllt oder zurückgewiesen werden
\end{itemize}
Aufruf neu:
\begin{lstlisting}[language=JavaScript, style=basesmol]
readFilePromise('/etc/hosts')
    .then(console.log)
    .catch(() => {
        console.log("Error reading file")
    })
\end{lstlisting}
\end{concept}

\begin{theorem}{Promise-Zustände}
\begin{itemize}
  \item pending: Ausgangzustand
  \item fulfilled: erfolgreich abgeschlossen
  \item rejected: ohne Erfolg abgeschlossen
  \end{itemize}
  Nur ein Zustandsübergang möglich und Zustand in Promise-Objekt gekapselt\\
\includegraphics[width=0.8\linewidth]{images/2024_12_29_858f09cde51177c71657g-14}
\end{theorem}

\begin{corollary}{Promises Verknüpfen}
\begin{itemize}
  \item Then-Aufruf gibt selbst Promise zurück
  \item Catch-Aufruf ebenfalls, per Default erfüllt
  \item So können diese Aufrufe verkettet werden
  \item Promise, welche unmittelbar resolved wird: Promise.resolve (...)
  \item Promise, welche unmittelbar rejected wird: Promise.reject (...)
\end{itemize}
\end{corollary}

\begin{definition}{Promise.all()}
\begin{itemize}
  \item Erhält Array von Promises
  \item Erfüllt mit Array der Result, wenn alle erfüllt sind
  \item Zurückgewiesen sobald eine Promise zurückgewiesen wird
\end{itemize}
\end{definition}

\begin{definition}{Promise.race()}
\begin{itemize}
  \item Erhält Array von Promises
  \item Erfüllt sobald eine davon erfüllt ist
  \item Zurückgewiesen sobald eine davon zurückgewiesen wird
\end{itemize}
\end{definition}

\begin{code}{ASYNC/AWAIT}
\begin{lstlisting}[language=JavaScript, style=basesmol]
/* Bekanntes Beispiel */
const readHosts =() => {
    readFilePromise('/etc/hosts')
        .then(console.log)
        . catch(() => {
            console.log("Error reading file")
        })
}
/* Mit async/await */
const readHosts = async () => {
    try {
        console.log(await readFilePromise('/etc/hosts'))
    }
    catch (err) {
        console.log("Error reading file")
    }
}
\end{lstlisting}
Beispiel 2:
\begin{lstlisting}[language=JavaScript, style=basesmol]
function resolveAfter2Seconds (x) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(x)
        }, 2000)
    })
}
async function add1(x) {
    var a = resolveAfter2Seconds(20)
    var b = resolveAfter2Seconds(30)
    return x + await a + await b
}
add1(10).then(console.log)
\end{lstlisting}
\end{code}

\columnbreak

\subsection{Webserver}
Die Standard-Ports von einem Webserver sind 80 und 443. Der Webserver wartet auf eine Anfrage vom Client.

\begin{definition}{Server im Internet}
\begin{itemize}
  \item Wartet auf Anfragen auf bestimmtem Port
  \item Client stellt Verbindung her und sendet Anfrage
  \item Server beantwortet Anfrage
\end{itemize}
\end{definition}

\begin{corollary}{Ports}
\begin{center}
\begin{tabular}{|l|l|}
\hline
Port & Service \\
\hline
$\mathbf{2 0}$ & FTP - Data \\
\hline
$\mathbf{2 1}$ & FTP - Control \\
\hline
$\mathbf{2 2}$ & SSH Remote Login Protocol \\
\hline
$\mathbf{2 3}$ & Telnet \\
\hline
$\mathbf{2 5}$ & Simple Mail Transfer Protocol (SMTP) \\
\hline
$\mathbf{5 3}$ & Domain Name System (DNS) \\
\hline
$\mathbf{8 0}$ & HTTP \\
\hline
$\mathbf{4 4 3}$ & HTTPs \\
\hline
\end{tabular}
\end{center}
\end{corollary}

\begin{definition}
    {File-Transfer} File Server\\
    Um Dateien auf einem File-Server auszutauschen, werden die Protokolle FTP (File Transfer Protocol) und SFTP (SSH File Transfer Protocol) verwendet.
\end{definition}

\subsubsection{HTTP}

\begin{theorem}{HTTP-Requests}
    \begin{itemize}
        \item GET: Ressource laden
        \item POST: Informationen senden
        \item PUT: Ressource anlegen, überschreiben
        \item PATCH: Ressource anpassen
        \item DELETE: Ressource löschen
    \end{itemize}
\end{theorem}

\begin{corollary}{HTTP-Response Codes}
    \begin{center}
    \begin{tabular}{|l|l|}
    \hline
    Code & Beschreibung \\
    \hline
    $\mathbf{1 x x}$ & Information (101 Switching protocols) \\
    \hline
    $\mathbf{2 x x}$ & Erfolg (200 OK) \\
    \hline
    $\mathbf{3 x x}$ & Weiterleitung (301 Moved permanently) \\
    \hline
    $\mathbf{4 x x}$ & Fehler in Anfrage (403 Forbidden, 404 Not Found) \\
    \hline
    $\mathbf{5 x x}$ & Server-Fehler (501 Not implemented) \\
    \hline
    \end{tabular}
    \end{center}
\end{corollary}

\columnbreak

\subsection{Einfacher Webserver (Node.js)}

\begin{concept}{Node.js Webserver}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const {createServer} = require("http")
Let server = createServer((request, response) => {
    response.writeHead(200, {"Content-Type": "text/html"})
    response.write(`
        <h1>Hello!</h1>
        <p>You asked for <code>${request.url}</code></p>`)
    response.end()
})
server.listen(8000)
console.log("Listening! (port 8000)")|
\end{lstlisting}
\end{concept}


\begin{code}{Einfacher Webclient}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const {request} = require("http")
let requestStream = request({
    hostname: "eloquentjavascript.net",
        path: "/20_node.html",
        method: "GET"
        headers: {Accept: "text/html"}
}, response => {
        console.log("Server responded with status code", response.statusCode)
})
requestStream.end()
\end{lstlisting}
\end{code}

\begin{examplecode}{Server und Client mit Streams}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const {createServer} = require("http")
createServer((request, response) => {
    response.writeHead(200, {"Content-Type": "text/plain"})
        request.on("data", chunk =>
            response.write(chunk.toString().toUpperCase()))
        request.on("end" , () => response.end())
    }).listen(8000)
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, style=basesmol]
const {request} = require("http")
Let rq = request({
    hostname: "localhost",
    port: 8000,
    method: "POST"
}, response => {
    response.on("data", chunk =>
    process.stdout.write(chunk.toString()));
})
rq.write("Hello server\n")
rq.write("And good bye\n")
rq.end()
\end{lstlisting}
\end{examplecode}

\begin{definition}{REST API}
\begin{itemize}
  \item REST: Representational State Transfer
  \item Zugriff auf Ressourcen über ihre Adresse (URI)
  \item Kein Zustand: jede Anfrage komplett unabhängig
  \item Kein Bezug zu vorhergehenden Anfragen
  \item Alle nötigen Informationen in Anfrage enthalten
  \item Verwenden der HTTP-Methoden: GET , PUT , POST , ...
\end{itemize}
\end{definition}

\begin{concept}{Express.js}\\
    Express.js ist ein minimales, aber flexibles Framework für Web-apps. Es hat zahlreiche Utilities und Erweiterungen. 
    Express.js basiert auf Node.js.
    $\rightarrow$ http://expressjs.com
\end{concept}


\begin{KR}{Installation}
\begin{itemize}
  \item Der Schritt npm init fragt eine Reihe von Informationen (Projektname, Version, ...) zum Projekt ab
  \item Als Entry Point ist hier index.js voreingestellt
  \item Das kann zum Beispiel in app.js geändert werden.
\end{itemize}
\begin{lstlisting}[language=JavaScript, style=basesmol]
$ mkdir myapp
$ cd myapp
$ npm init
$ npm install express --save
\end{lstlisting}
\end{KR}

\begin{code}{Beispiel: Express Server}
\begin{lstlisting}[language=JavaScript, style=basesmol]
const express = require('express')
const app = express()
const port = 3000
app.get('/', (req, res) => {
        res.send('Hello World!')
})
app.listen(port, () => {
    console.log(`Example app listening at http://localhost:${port}`)
}})
\end{lstlisting}
\end{code}

\begin{KR}{Routing}
\begin{lstlisting}[language=JavaScript, style=basesmol]
app.get('/', function (req, res) {
    res.send('Hello World!')
})
app.post('/', function (req, res) {
    res.send('Got a POST request')
})
app.put('/user', function (req, res) {
    res.send('Got a PUT request at /user')
})
app.delete('/user', function (req, res) {
    res.send('Got a DELETE request at /user')
})
\end{lstlisting}
\end{KR}






\subsection{Jasmine (Testing)}

\begin{examplecode}{Beispiel (zugehörige Tests)}
\begin{lstlisting}[language=JavaScript, style=basesmol]
/* PlayerSpec.js - Auszug */
describe("when song has been paused", function() {
    beforeEach(function() {
        player.play(song)
        player.pause()
    })
    it("should indicate that the song is currently paused", function() {
        expect(player.isPlaying).toBeFalsy()
        /* demonstrates use of 'not' with a custom matcher */
        expect(player).not.toBePlaying(song)
    })
    it("should be possible to resume", function() {
        player.resume()
        expect(player.isPlaying).toBeTruthy()
        expect(player.currentlyPlayingSong) .toEqual(song)
    })
})
\end{lstlisting}
\end{examplecode}

\begin{code}{JASMINE: MATCHER}
\begin{lstlisting}[language=JavaScript, style=basesmol]
expect([1, 2, 3]).toEqual([1, 2, 3])
expect(12).toBeTruthy()
expect("").toBeFalsy()
expect("Hello planet").not.toContain("world")
expect(null).toBeNull()
expect(8).toBeGreaterThan(5)
expect(12.34).toBeCloseTo(12.3, 1)
expect("horse_ebooks.jpg") .toMatch(/\w+.(jpg|gif|png|svg)/i)
\end{lstlisting}
\end{code}

\begin{KR}{JASMINE: TESTS DURCHFÜHREN}
\begin{lstlisting}[language=bash, style=basesmol]
$ npx jasmine
Randomized with seed 03741
Started
......
5 specs, 0 failures
Finished in 0.014 seconds
Randomized with seed 03741 
    (jasmine --random=true --seed=03741)
\end{lstlisting}
\end{KR}