\section{Introduction to Operating Systems}

\begin{remark}
    Content:
    \begin{itemize}
        \item Basic Principles of Operating Systems
        \item Computer Hardware Review
    \end{itemize}
\end{remark}

\subsection{Basic Principles of Operating Systems}

\begin{concept}{Operating System (OS)} as an extended machine
    \begin{itemize}
        \item Software that manages computer hardware
        \item Provides services for programs
        \item Acts as intermediary between user and hardware
    \end{itemize}
    \includegraphics[width=\linewidth]{OS_overview.png}

    Hardware is very complicated: The job of the operating system is to create good abstractions 
    and manage the abstract objects thus created.
\end{concept}

\begin{definition}{Operating System (OS)}
    \begin{itemize}
        \item User Mode vs Kernel Mode
        \item Northbound Interface: User Interface
        \item Southbound Interface: Hardware Interface
    \end{itemize}
    \includegraphics[width=\linewidth]{OS_def.png}
\end{definition}

\begin{concept}{OS as a Resource Manager}
    \begin{itemize}
        \item Process Management
        \item Memory Management
        \item File System Management
        \item Device Management
        \item Security
    \end{itemize}
    \includegraphics[width=\linewidth]{os_resource_magaer.png}

    The OS controls resource usage, grants resource request, accounts for usage and mediates conflicting requests.
\end{concept}

\raggedcolumns

\subsection{Computer Hardware Review}

\begin{definition}{CPU} Central Processing Unit\\
    \begin{itemize}
        \item Basic cycle: Fetch, Decode, Execute
        \item CPUs feature some registers to hold key variables and temporary results
        \item Special registers for internal use: Program Counter (PC), Stack Pointer (SP), Program Status Word (PSW), etc.
    \end{itemize}
    \vspace{2mm}
    CPUs and their Instruction Sets are architecture-specific:
    \begin{itemize}
        \item ARM, RISC, X86, etc.
        \item Instructions are classified along Execution Privileges, enforced by CPU:
        \begin{itemize}
            \item Intel: User Mode (limited set of instructions) vs Kernel Mode (full set of instructions)
            \item ARM: UnPrivileged Mode vs Privileged Mode
        \end{itemize}
    \end{itemize}
\end{definition}

\begin{concept}{CPU cycles}\\
    Basic cycle of every CPU:    
    \begin{itemize}
        \item Fetches the first instructions from memory into registers
        \item Decodes instructions (determining type and operands)
        \item Executes instructions
        \item fetch, decode, execute, ...
    \end{itemize}
CPUs have multiple cores, each having multiple execution units and parallel pipelines:

\includegraphics[width=0.6\linewidth]{cpu_cycles1.png}\\
\includegraphics[width=\linewidth]{cpu_cycles2.png}
\end{concept}

\begin{theorem}{CPU Caches}\\
    CPUS may have multiple levels of caches:
    \begin{itemize}
        \item L1: Small, fast, close to CPU
        \item L2: Larger, slower, further away
        \item L3: Even larger, even slower, even further away
        \item Caches are used to store frequently accessed data and instructions
    \end{itemize}
    
    Example: Quad-core chip with a shared L2 cache and a quad-core chip with separate L2 caches for each core.
    
    \includegraphics[width=\linewidth]{cpu_caches.png}
\end{theorem}

\begin{definition}{Memory}
    The memory system is constructed as a hierarchy of layers, according to access time:

    \includegraphics[width=\linewidth]{hardware_review_memory.png}
\end{definition}

\begin{concept}{Input/Output}
    Huge amount of I/O Devices, Hard Drives, Network Interfaces, Serial Ports,
    Keyboard, Mouse, Graphics, Cameras, etc
    \vspace{2mm}\\
    Devices connected with CPU via a Bus System (SW), I/O Interfaces (SW) and I/O
    Controllers (HW)
    \vspace{2mm}\\
    Software that talks to the I/O Controller (Commands/Responses), called Device Driver
    Runs in Kernel or User Mode.
    Built-into Kernel or modular and loadable at boot-/run-time

    \includegraphics[width=\linewidth]{io_overview.png}
\end{concept}

\begin{example2}{IO and Bus System} X86 System with different Bus standards:

    \includegraphics[width=\linewidth]{io_and_bus_syste_example.png}
\end{example2}

\begin{theorem}{Operating System Variants}
    \begin{itemize}
        \item Mainframe OS: IBM z/OS, IBM z/VM
        \item Server OS: Windows Server, Linux, Solaris
        \item Multiprocessor OS: Windows, Linux, Solaris
        \item Personal Computer OS: Windows, MacOS, Linux
        \item Handheld Computer OS: Android, iOS
        \item Embedded OS: VxWorks, QNX
        \item Real-Time OS: VxWorks, QNX
        \item Sensor Node OS: TinyOS, Contiki
        \item Cloud OS: OpenStack, OpenNebula
        \item Smart Card OS: JavaCard, MULTOS
    \end{itemize}
\end{theorem}

\begin{corollary}{Operating Systems vs. Distributions}
    \begin{itemize}
        \item Operating System: Kernel, System Libraries, System Utilities
        \item Distribution: OS + Applications, Tools, Documentation, etc.
    \end{itemize}
    Example: Linux Kernel + GNU Tools + X11 + Gnome + Firefox + LibreOffice = Ubuntu
    \textcolor{pink} evtl. add more info from slides
\end{corollary}

\subsection{Operation System Concepts}

\begin{concept}{Basics}\\
    Interacting with the OS:
    \begin{itemize}
        \item 
    \end{itemize}
    
\end{concept}

\raggedcolumns

\section{Introduction to Operating Systems}

\subsection{Defining Operating Systems}

\begin{concept}{The Operating System as an Extended Machine}\\
    The operating system serves as an abstraction layer between hardware and applications:
    \begin{itemize}
        \item Hardware is complex and difficult to program directly
        \item Operating systems create good abstractions for hardware resources
        \item These abstractions are implemented and managed by the OS
        \item Applications interact with these abstractions rather than directly with hardware
    \end{itemize}
\end{concept}

\begin{definition}{User Mode vs Kernel Mode}\\
    Operating systems operate in two fundamental modes:
    \begin{itemize}
        \item \textbf{Kernel Mode}: Privileged execution mode with full access to all hardware resources and instructions
        \item \textbf{User Mode}: Restricted execution mode where applications run with limited privileges
    \end{itemize}
    
    The OS provides two key interfaces:
    \begin{itemize}
        \item \textbf{Northbound Interface}: Towards user applications
        \item \textbf{Southbound Interface}: Towards hardware
    \end{itemize}
\end{definition}

\begin{concept}{The Operating System as a Resource Manager}\\
    The operating system:
    \begin{itemize}
        \item Controls resource usage
        \item Grants resource requests
        \item Accounts for resource usage
        \item Mediates conflicting requests
        \item Ensures fair and efficient resource allocation
    \end{itemize}
\end{concept}

\subsection{Computer Hardware Review}

\begin{definition}{Central Processing Unit (CPU)}\\
    The CPU follows a basic operation cycle:
    \begin{itemize}
        \item Fetch instructions from memory into registers
        \item Decode the instruction to determine type and operands
        \item Execute the instruction
        \item Repeat for subsequent instructions
    \end{itemize}
    
    Key CPU components include:
    \begin{itemize}
        \item Registers to hold variables and temporary results
        \item Special registers for internal use (Program Counter, Stack Pointer, Program Status Word)
        \item Execution units and pipelines for processing instructions
        \item Cache memory organized in hierarchical levels (L1, L2, L3)
    \end{itemize}
    
    CPUs enforce execution privileges through:
    \begin{itemize}
        \item Intel: Priority Rings (User Mode vs Kernel Mode)
        \item ARM: Privileged vs Unprivileged Mode
    \end{itemize}
\end{definition}

\begin{definition}{Memory System}\\
    Memory is organized as a hierarchy of layers based on access time:
    \begin{itemize}
        \item Registers (fastest, smallest)
        \item Cache memory (L1, L2, L3)
        \item Main memory (RAM)
        \item Secondary storage (disks, SSDs)
        \item Tertiary storage (backup systems)
    \end{itemize}
\end{definition}

\begin{definition}{Input/Output (I/O) System}\\
    The I/O system comprises:
    \begin{itemize}
        \item Various devices (hard drives, network interfaces, serial ports, keyboards, etc.)
        \item Bus systems to connect devices (PCI, PCIe, SATA, USB, etc.)
        \item I/O controllers (hardware)
        \item Device drivers (software)
    \end{itemize}
    
    Device drivers:
    \begin{itemize}
        \item Software that communicates with I/O controllers
        \item Can run in Kernel or User Mode
        \item May be built into the kernel or loaded as modules
    \end{itemize}
\end{definition}

\subsection{Operating System Variants}

\begin{definition}{Types of Operating Systems}\\
    Operating systems are categorized based on their purpose and environment:
    \begin{itemize}
        \item Mainframe Operating Systems
        \item Server Operating Systems
        \item Multiprocessor Operating Systems
        \item Personal Computer Operating Systems
        \item Handheld Computer Operating Systems
        \item Embedded Operating Systems
        \item Sensor Node Operating Systems
        \item Real-Time Operating Systems
        \item Smart Card Operating Systems
    \end{itemize}
\end{definition}

\begin{definition}{Operating System vs Distributions}\\
    \begin{itemize}
        \item \textbf{Operating System (Kernel)}: The core component that directly manages hardware resources
        \item \textbf{Distribution}: A complete package including kernel, utilities, and applications
    \end{itemize}
    
    Examples:
    \begin{itemize}
        \item Linux: The kernel available at \url{https://www.kernel.org/}
        \item Linux Distributions: OpenSUSE, RedHat, Ubuntu (kernel plus utilities)
        \item Microsoft: OS plus proprietary extensions and bundled software
        \item Apple: OS X kernel (Darwin) plus proprietary GUI components
        \item BSD: FreeBSD, NetBSD, OpenBSD (Unix-like systems)
    \end{itemize}
\end{definition}

\subsection{Basic OS Concepts}

\begin{definition}{Fundamental OS Concepts}\\
    \begin{itemize}
        \item \textbf{Interacting with OS}: Through terminal or graphical user interface
        \item \textbf{Users}: Regular vs. privileged users
        \item \textbf{Data organization}: Files, directories, filesystems
        \item \textbf{Programs vs. Processes}: A program is a compiled executable, while a process is an instance of a running program
        \item \textbf{Multi-tasking}: Running multiple processes concurrently
        \item \textbf{Context-switching}: Switching execution from one process to another
        \item \textbf{System calls}: Interface for processes to request OS services
        \item \textbf{Inter-Process Communication}: Methods for processes to communicate
        \item \textbf{Signals}: Mechanism for notifying processes of events
    \end{itemize}
\end{definition}

\begin{definition}{OS Structures}\\
    Operating systems can be organized in different ways:
    \begin{itemize}
        \item \textbf{Monolithic Systems}: Single executable containing all OS functionality
        \item \textbf{Modular Systems}: Core kernel with loadable modules
        \item \textbf{Microkernels}: Minimal kernel with most services running in user space
    \end{itemize}
\end{definition}

\begin{example}
    To check CPU information in Linux:
    \begin{lstlisting}[language=bash, style=basesmol]
    # Display kernel version information
    uname -a
    
    # View CPU details
    less /proc/cpuinfo
    
    # Display CPU architecture information
    lscpu
    \end{lstlisting}
\end{example}

\begin{KR}{Working with Processes in Linux}\\
    \paragraph{Viewing running processes}
    \begin{itemize}
        \item Use \texttt{ps aux} to display all processes
        \item Use \texttt{top} for an interactive process viewer
        \item Check environment variables with \texttt{env}
    \end{itemize}
    
    \paragraph{Process control}
    \begin{itemize}
        \item Background a process with \texttt{\&} or \texttt{bg}
        \item Bring to foreground with \texttt{fg}
        \item List background jobs with \texttt{jobs}
        \item Terminate a process with \texttt{kill PID}
    \end{itemize}
    
    \paragraph{System information}
    \begin{itemize}
        \item View process hierarchy with \texttt{pstree}
        \item Check system call activity with \texttt{strace}
    \end{itemize}
\end{KR}