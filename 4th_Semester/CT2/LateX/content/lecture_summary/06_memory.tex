\section{Memory}

\subsection{Memory Technologies Overview}

\begin{concept}{Semiconductor Memory Classifications}\\
Semiconductor memories can be classified into two main categories:
\begin{itemize}
    \item \textbf{Volatile Memory}: Loses data when power is turned off
    \begin{itemize}
        \item SRAM (Static Random Access Memory)
        \item DRAM (Dynamic Random Access Memory)
    \end{itemize}
    \item \textbf{Non-volatile Memory}: Retains data even without power
    \begin{itemize}
        \item ROM (Read-Only Memory)
        \item PROM (Programmable ROM)
        \item EPROM (Erasable PROM)
        \item EEPROM (Electrically Erasable PROM)
        \item Flash Memory
        \item NV-RAM (Non-Volatile RAM)
    \end{itemize}
\end{itemize}
\end{concept}

\begin{definition}{Memory Organization}\\
Memory devices are organized as arrays of bit cells:
\begin{itemize}
    \item \textbf{Array Size}: $n \times m$ (n words with m data bits each)
    \item \textbf{Address Lines}: $k$ bits can address $2^k$ words
    \item \textbf{Data Lines}: Width of data bus (8, 16, 32 bits, etc.)
    \item \textbf{Control Lines}: Enable read/write operations
\end{itemize}
\end{definition}

\subsection{PROM, EEPROM, and Flash Memory}

\mult{2}

\begin{concept}{PROM (Programmable Read-Only Memory)}
\begin{itemize}
    \item One-time programmable memory
    \item Programming involves physically altering the circuit (e.g., blowing fuses)
    \item Once programmed, contents cannot be changed
    \item Used for permanent storage of code or data
\end{itemize}
\end{concept}

\begin{concept}{EEPROM (Electrically Erasable PROM)}
\begin{itemize}
    \item Uses floating-gate transistors to store data
    \item Can be electrically programmed and erased
    \item Byte-level erase and write operations
    \item Limited write cycles (typically 100,000 to 1,000,000)
    \item Slower and more expensive than SRAM
    \item Used for storing configuration data or parameters
\end{itemize}
\end{concept}

\begin{concept}{Flash Memory}
\begin{itemize}
    \item Based on floating-gate transistor technology (like EEPROM)
    \item Higher density and lower cost per bit than EEPROM
    \item Block-wise erase operations (not byte-level)
    \item Write operations can only change bits from '1' to '0'
    \item Erase operations reset all bits in a block to '1'
    \item Limited write/erase cycles (typically 10,000 to 100,000)
    \item Used for code storage and mass data storage
\end{itemize}
\end{concept}

\begin{definition}{NOR vs. NAND Flash}\\
\textbf{NOR Flash}:
\begin{itemize}
    \item Random access (like RAM)
    \item Execute-in-place capability (XIP)
    \item Fast read access
    \item Slow write and erase operations
    \item Lower density
    \item Used for code storage and execution
\end{itemize}
\textbf{NAND Flash}:
\begin{itemize}
    \item Page-based access (not random)
    \item Cannot execute code directly
    \item Slow random read access
    \item Fast sequential read and write
    \item Higher density
    \item Used for mass storage (SSDs, memory cards)
\end{itemize}
\end{definition}

\multend

\subsection{SRAM (Static RAM)}

\mult{2}

\begin{concept}{SRAM Structure and Characteristics}
\begin{itemize}
    \item Uses flip-flop circuit for each bit (typically 6 transistors)
    \item Maintains data as long as power is supplied
    \item No refresh required (unlike DRAM)
    \item Fast access times (a few nanoseconds)
    \item Low power consumption in standby mode
    \item Higher cost and lower density than DRAM
    \item Used for cache memory and high-speed buffers
\end{itemize}
\end{concept}

\begin{definition}{SRAM Cell}\\
A typical SRAM cell consists of:
\begin{itemize}
    \item Cross-coupled inverters forming a latch to store one bit
    \item Two access transistors to connect the cell to bit lines
    \item Word line to enable/disable access to the cell
    \item High state ('1') and low state ('0') stable as long as power is maintained
\end{itemize}
\end{definition}

\begin{definition}{SRAM Operations}\\
\textbf{Read Operation}:
\begin{itemize}
    \item Word line is activated
    \item Access transistors connect cell to bit lines
    \item Sense amplifiers detect voltage difference on bit lines
    \item Data is read from bit lines
\end{itemize}
\textbf{Write Operation}:
\begin{itemize}
    \item Word line is activated
    \item Access transistors connect cell to bit lines
    \item Write drivers force bit lines to desired values
    \item Cell state changes to match bit line values
\end{itemize}
\end{definition}

\begin{definition}{Asynchronous SRAM Interface}\\
Asynchronous SRAM devices typically have these control signals:
\begin{itemize}
    \item \textbf{CS} (Chip Select): Enables the memory device (active low)
    \item \textbf{OE} (Output Enable): Enables data output during read (active low)
    \item \textbf{WE} (Write Enable): Indicates write operation (active low)
    \item \textbf{Address Lines}: Select memory location
    \item \textbf{Data Lines}: Bidirectional lines for data transfer
\end{itemize}
\end{definition}

\multend

\subsection{SDRAM (Synchronous DRAM)}

\mult{2}

\begin{concept}{SDRAM Structure and Characteristics}
\begin{itemize}
    \item Uses a capacitor and one transistor for each bit
    \item Requires periodic refresh to maintain data (capacitor leakage)
    \item Synchronous interface (clocked)
    \item Row and column addressing (multiplexed address bus)
    \item Higher density and lower cost than SRAM
    \item Higher power consumption due to refresh
    \item Used for main memory in computers and embedded systems
\end{itemize}
\end{concept}

\begin{definition}{SDRAM Operation}\\
Key aspects of SDRAM operation:
\begin{itemize}
    \item \textbf{Refresh}: Periodic read and rewrite of all memory cells
    \item \textbf{Row Activation}: Opening a row copies data to row buffer
    \item \textbf{Column Access}: Selecting specific bytes from row buffer
    \item \textbf{Precharge}: Preparing a bank for next row activation
    \item \textbf{Burst Mode}: Sequential access to multiple columns
\end{itemize}
\end{definition}

\multend

\begin{concept}{SRAM vs. SDRAM Comparison}
\begin{center}
\begin{tabular}{|p{3cm}|p{4cm}|p{4cm}|}
\hline
\textbf{Feature} & \textbf{SRAM} & \textbf{SDRAM} \\
\hline
Cell Structure & 6 transistors (flip-flop) & 1 transistor + 1 capacitor \\
\hline
Refresh & Not required & Required (periodic) \\
\hline
Density & Lower & Higher \\
\hline
Cost per bit & Higher & Lower \\
\hline
Access Time & Faster, uniform & Variable (row hit vs. miss) \\
\hline
Interface & Often asynchronous & Synchronous (clocked) \\
\hline
Power Consumption & Lower static power & Higher due to refresh \\
\hline
Applications & Cache, high-speed buffer & Main memory \\
\hline
\end{tabular}
\end{center}
\end{concept}

\subsection{STM32F4 On-Chip Memory}

\begin{concept}{STM32F4 Memory Architecture}\\
The STM32F429ZI microcontroller includes:
\begin{itemize}
    \item \textbf{Flash Memory}: 2 MB (program storage)
    \begin{itemize}
        \item NOR flash with execute-in-place capability
        \item Divided into sectors of varying sizes (16KB to 128KB)
        \item Organized in two banks for read-while-write operations
    \end{itemize}
    \item \textbf{SRAM}: 256 KB total
    \begin{itemize}
        \item SRAM1: 112 KB
        \item SRAM2: 16 KB
        \item SRAM3: 64 KB
        \item CCM (Core Coupled Memory): 64 KB (accessible only by CPU)
    \end{itemize}
\end{itemize}
\end{concept}

\begin{definition}{STM32F4 Flash Characteristics}
\begin{itemize}
    \item \textbf{Write Operations}: Can only change bits from '1' to '0'
    \item \textbf{Erase Operations}: Resets all bits in a sector to '1'
    \item \textbf{Programming Time}: Around 16µs per double word
    \item \textbf{Erase Time}: 1-2 seconds for a 128KB sector
    \item \textbf{Endurance}: 10,000 erase cycles
    \item \textbf{Access Time}: Higher latency than SRAM (requires wait states)
\end{itemize}
\end{definition}

\subsection{External Memory Interface}

\begin{concept}{Flexible Memory Controller (FMC)}\\
The STM32F4 Flexible Memory Controller (FMC) provides:
\begin{itemize}
    \item Interface between on-chip system bus and external memory devices
    \item Support for different memory types:
    \begin{itemize}
        \item SRAM, NOR Flash, PSRAM
        \item NAND Flash
        \item SDRAM
    \end{itemize}
    \item Configurable bus width (8, 16, or 32 bits)
    \item Programmable timing parameters
    \item Memory banking with up to 6 banks
\end{itemize}
\end{concept}

\begin{definition}{FMC Signals}\\
Key FMC signals for external SRAM/NOR flash:
\begin{itemize}
    \item \textbf{A[25:0]}: Address bus
    \item \textbf{D[31:0]}: Data bus (bidirectional)
    \item \textbf{NE[4:1]}: Chip enable signals (active low)
    \item \textbf{NOE}: Output enable (active low)
    \item \textbf{NWE}: Write enable (active low)
    \item \textbf{NBL[3:0]}: Byte lane enables (active low)
\end{itemize}
\end{definition}

\begin{concept}{External Memory Access}\\
Accessing external memory with different bus widths:
\begin{itemize}
    \item \textbf{32-bit CPU Access to 32-bit Memory}: 1 external bus cycle
    \item \textbf{32-bit CPU Access to 16-bit Memory}: 2 external bus cycles
    \item \textbf{32-bit CPU Access to 8-bit Memory}: 4 external bus cycles
\end{itemize}
\textbf{Write Operations}:
\begin{itemize}
    \item CPU write stored in FMC FIFO buffer
    \item System bus released for other access
    \item FMC completes external write(s)
\end{itemize}
\textbf{Read Operations}:
\begin{itemize}
    \item System bus must wait until all external reads complete
    \item Multiple external cycles for narrow memory widths
\end{itemize}
\end{concept}

\begin{KR}{Connecting Asynchronous SRAM to STM32F4}
\paragraph{Step 1: Configure GPIO pins}
Set the GPIO pins for FMC signals to alternate function mode.
\paragraph{Step 2: Configure FMC timing}
Set appropriate timing parameters (ADDSET, DATAST) based on memory datasheet.
\paragraph{Step 3: Configure FMC bank}
Set the memory type, data width, and other parameters.
\paragraph{Step 4: Enable FMC}
Enable the FMC peripheral.

\begin{lstlisting}[language=C, style=basesmol]
// Configure external SRAM (16-bit) on FMC bank 1

// Step 1: Configure GPIO pins for FMC
// Enable GPIO clocks
RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN | RCC_AHB1ENR_GPIOEEN |
                RCC_AHB1ENR_GPIOFEN | RCC_AHB1ENR_GPIOGEN;

// Configure GPIO pins (example for some pins)
// Set alternate function mode (0x2)
GPIOD->MODER |= 0x55555555;  // All pins to alternate function
GPIOE->MODER |= 0x55555555;
// Set to AF12 (FMC)
GPIOD->AFR[0] = 0xCCCCCCCC;
GPIOD->AFR[1] = 0xCCCCCCCC;
GPIOE->AFR[0] = 0xCCCCCCCC;
GPIOE->AFR[1] = 0xCCCCCCCC;

// Step 2: Enable FMC clock
RCC->AHB3ENR |= RCC_AHB3ENR_FMCEN;

// Step 3: Configure FMC bank 1 for SRAM
// Set timing for SRAM (example values)
FMC_Bank1->BTCR[0] = 
    FMC_BCR1_MBKEN |    // Memory bank enable
    FMC_BCR1_MTYP_0 |   // Memory type SRAM
    FMC_BCR1_MWID_0 |   // 16-bit data bus
    FMC_BCR1_WREN;      // Write enable

// Set timing (ADDSET=1, DATAST=2)
FMC_Bank1->BTCR[1] = 
    (1 << FMC_BTR1_ADDSET_Pos) |
    (2 << FMC_BTR1_DATAST_Pos);
\end{lstlisting}
\end{KR}

\begin{example2}{Address Space Calculation for External Memory}\\
Calculate the address range for an external 32K x 8-bit SRAM connected to FMC bank 3.
\tcblower
For an external SRAM connected to FMC bank 3:

1. Base address of FMC bank 3 = 0x68000000
2. Memory size = 32K bytes = 32,768 bytes = 0x8000 bytes

Therefore, the address range for this SRAM would be:
- Start address: 0x68000000
- End address: 0x68000000 + 0x8000 - 1 = 0x68007FFF

Address range: 0x68000000 - 0x68007FFF

Note: Due to partial address decoding, this SRAM might also be accessible at other addresses within bank 3. For example, it might also respond to addresses:
0x68008000 - 0x6800FFFF, 0x68010000 - 0x68017FFF, etc.
\end{example2}

\section{Memory Exercises}

\subsection{Memory Technology Comparison}

\begin{KR}{Comparing Memory Technologies}\\
\paragraph{Identify memory characteristics}
\begin{itemize}
    \item \textbf{Volatility:} Whether memory loses contents when power is removed
    \begin{itemize}
        \item \textit{Volatile:} SRAM, DRAM/SDRAM
        \item \textit{Non-volatile:} PROM, EEPROM, Flash, NV-RAM
    \end{itemize}
    \item \textbf{Storage mechanism:} How bits are physically stored
    \begin{itemize}
        \item \textit{SRAM:} Flip-flop-based cells (6 transistors)
        \item \textit{DRAM:} Capacitor-based cells (1 transistor + 1 capacitor)
        \item \textit{Flash:} Floating-gate transistors
    \end{itemize}
    \item \textbf{Access method:} How data is accessed
    \begin{itemize}
        \item \textit{Random access:} Any location accessed in the same time (SRAM, NOR Flash)
        \item \textit{Block access:} Efficient for large blocks (NAND Flash)
        \item \textit{Sequential access:} Fast for sequential data (SDRAM with burst mode)
    \end{itemize}
\end{itemize}

\paragraph{Compare memory performance metrics}
\begin{itemize}
    \item \textbf{Access time:} Time to read/write data
    \begin{itemize}
        \item SRAM: 2-10ns
        \item SDRAM: 60ns+ for first access, then fast for burst
        \item NOR Flash: \~120ns read
        \item NAND Flash: Slow random access (25$\mu$s first byte)
    \end{itemize}
    \item \textbf{Density:} Storage capacity per unit area
    \begin{itemize}
        \item SRAM: Low (large cells, expensive)
        \item DRAM: High (small cells, inexpensive)
        \item NAND Flash: Very high (highest density, lowest cost per bit)
    \end{itemize}
    \item \textbf{Power consumption:} Energy required for operation
    \begin{itemize}
        \item SRAM: Low static power (no refresh needed)
        \item DRAM: Higher (requires refresh)
        \item Flash: Very low when not being written/erased
    \end{itemize}
\end{itemize}

\paragraph{Analyze application suitability}
\begin{itemize}
    \item \textbf{SRAM:} Cache memory, small temporary storage
    \item \textbf{DRAM/SDRAM:} Main memory, large temporary storage
    \item \textbf{NOR Flash:} Program code storage, direct execution
    \item \textbf{NAND Flash:} Mass storage, data logging, SSD drives
\end{itemize}
\end{KR}

\begin{example2}{Memory Technology Comparison}\\
Compare SDRAM (Synchronous Dynamic RAM) and SRAM (Static RAM) in terms of:
\begin{enumerate}
    \item Storage mechanism and structure
    \item Access patterns and timing characteristics
    \item Density and cost
    \item Refresh requirements
    \item Typical applications
\end{enumerate}

\tcblower
\paragraph{Solution:}

1. \textbf{Storage mechanism and structure:}
   \begin{itemize}
     \item \textbf{SRAM:} Uses flip-flop circuits with 6 transistors per bit. Stores data as long as power is applied, without requiring refresh.
     \item \textbf{SDRAM:} Uses a single capacitor and transistor per bit. Stores data as charge in a capacitor that leaks over time.
   \end{itemize}

2. \textbf{Access patterns and timing:}
   \begin{itemize}
     \item \textbf{SRAM:} Provides fast random access with consistent timing for all accesses (~5ns). All operations take roughly the same time.
     \item \textbf{SDRAM:} Synchronous interface with clock. Has higher latency for first access in a row (~60ns), but very fast subsequent access within same row. Optimized for burst transfers.
   \end{itemize}

3. \textbf{Density and cost:}
   \begin{itemize}
     \item \textbf{SRAM:} Low density due to large cell size (6 transistors). Higher cost per bit. Typically limited to 64Mb per device.
     \item \textbf{SDRAM:} High density due to small cell size (1 transistor + 1 capacitor). Lower cost per bit. Can reach 4Gb or more per device.
   \end{itemize}

4. \textbf{Refresh requirements:}
   \begin{itemize}
     \item \textbf{SRAM:} No refresh required (static). Maintains data as long as power is applied.
     \item \textbf{SDRAM:} Requires periodic refresh (dynamic). Capacitors discharge within milliseconds and must be refreshed regularly.
   \end{itemize}

5. \textbf{Typical applications:}
   \begin{itemize}
     \item \textbf{SRAM:} CPU cache memory, small buffer memory, applications requiring fast random access.
     \item \textbf{SDRAM:} Main system memory, large buffers, applications requiring high capacity with reasonable access speed.
   \end{itemize}
\end{example2}

\subsection{External Memory Configuration}

\begin{KR}{Connecting External Memory to STM32}\\
\paragraph{Identify external memory type and requirements}
\begin{itemize}
    \item Determine memory interface type (asynchronous SRAM, NOR Flash, NAND Flash, SDRAM)
    \item Identify memory capacity and organization (width x depth)
    \item Note timing requirements from datasheet
\end{itemize}

\paragraph{Configure FMC (Flexible Memory Controller)}
\begin{itemize}
    \item Enable FMC clock in RCC registers
    \item Configure memory bank registers based on memory type:
    \begin{itemize}
        \item Bank 1-4: SRAM/NOR/PSRAM (BCRx and BTRx registers)
        \item Bank 5-6: SDRAM (SDCR and SDTR registers)
    \end{itemize}
    \item Set data bus width (8/16/32 bits)
    \item Configure timing parameters:
    \begin{itemize}
        \item ADDSET: Address setup time
        \item DATAST: Data setup time
        \item BUSTURN: Bus turnaround time
    \end{itemize}
\end{itemize}

\paragraph{Configure GPIO pins for FMC}
\begin{itemize}
    \item Enable GPIO clocks in RCC registers
    \item Configure GPIO pins for alternate function (FMC)
    \item Set GPIO speed, typically high or very high
\end{itemize}

\paragraph{Understand memory mapping}
\begin{itemize}
    \item Know the address ranges for each FMC bank:
    \begin{itemize}
        \item Bank 1: 0x6000 0000 - 0x6FFF FFFF
        \item Bank 2: 0x7000 0000 - 0x7FFF FFFF
        \item Bank 3: 0x8000 0000 - 0x8FFF FFFF
        \item Bank 4: 0x9000 0000 - 0x9FFF FFFF
        \item SDRAM Bank 1: 0xC000 0000 - 0xCFFF FFFF
        \item SDRAM Bank 2: 0xD000 0000 - 0xDFFF FFFF
    \end{itemize}
    \item Understand chip select logic (NE1-NE4)
    \item Account for memory width in address calculations
\end{itemize}
\end{KR}

\begin{example2}{External Memory Connection Analysis}\\
A 64K × 8-bit asynchronous SRAM chip needs to be connected to the FMC of an STM32F429 microcontroller. The address 0x6800'0000 should be the lowest address used to access the memory.

Answer:
\begin{enumerate}
    \item How many address pins does the memory need?
    \item Which FMC signals should be connected to the SRAM chip?
    \item At what address is the highest byte of the memory accessed?
    \item Explain why the same memory location can be accessed at multiple addresses.
\end{enumerate}

\tcblower
\paragraph{Solution:}

1. \textbf{Number of address pins:}
   \begin{itemize}
     \item Memory size = 64K = 2$^{16}$ bytes
     \item Need 16 address lines: ADDR[15:0]
   \end{itemize}

2. \textbf{FMC signals to connect:}
   \begin{itemize}
     \item Address lines: A[15:0]
     \item Data lines: D[7:0] (8-bit data bus)
     \item Chip select: NE[3] (for Bank 3 based on address 0x6800'0000)
     \item Output Enable: NOE
     \item Write Enable: NWE
   \end{itemize}

3. \textbf{Highest memory address:}
   \begin{itemize}
     \item Lowest address: 0x6800'0000
     \item Memory size: 64K = 0x10000 bytes
     \item Highest address: 0x6800'0000 + 0xFFFF = 0x6800'FFFF
   \end{itemize}

4. \textbf{Multiple address access:}
   \begin{itemize}
     \item This occurs due to partial address decoding
     \item Only address lines A[15:0] are connected to the memory chip
     \item Higher address bits A[25:16] are not decoded/connected
     \item Any address where A[27:26] = 01 (Bank 2) and A[15:0] match will access the same memory location
     \item Example: Addresses 0x6800'0000, 0x6900'0000, 0x6A00'0000, etc. all access the same byte in memory
     \item The number of 64KB address blocks that map to the same memory is 2$^{10}$ = 1024 (from the 10 undecoded bits A[25:16])
   \end{itemize}
\end{example2}

\subsection{Memory Access Decomposition}

\begin{KR}{Analyzing Memory Access Patterns}\\
\paragraph{Determine memory access type}
\begin{itemize}
    \item Identify memory type and organization (width × depth)
    \item Determine CPU data bus width (typically 32-bit for Cortex-M)
    \item Identify the size of the access (byte, half-word, word)
\end{itemize}

\paragraph{Memory address decomposition}
\begin{itemize}
    \item Identify bank select bits from address (typically bits 27:26)
    \begin{itemize}
        \item 00: Bank 1, 01: Bank 2, 10: Bank 3, 11: Bank 4
    \end{itemize}
    \item Identify chip enable from bank and address
    \begin{itemize}
        \item Within each bank, specific regions activate NE1-NE4
    \end{itemize}
    \item Determine memory location within the device (lower address bits)
\end{itemize}

\paragraph{Analyze byte enables for sub-word accesses}
\begin{itemize}
    \item For 32-bit data bus: NBL[3:0] controls which bytes are active
    \begin{itemize}
        \item Word access (4 bytes): NBL[3:0] = 0000 (all active)
        \item Half-word access (2 bytes): NBL[3:0] = 0011 or 1100
        \item Byte access (1 byte): NBL[3:0] = 0111, 1011, 1101, or 1110
    \end{itemize}
    \item For 16-bit data bus: NBL[1:0] controls which bytes are active
    \begin{itemize}
        \item Half-word access (2 bytes): NBL[1:0] = 00 (both active)
        \item Byte access (1 byte): NBL[1:0] = 01 or 10
    \end{itemize}
\end{itemize}

\paragraph{Determine access pattern}
\begin{itemize}
    \item For 8-bit memory with 32-bit CPU: 4 accesses per word
    \item For 16-bit memory with 32-bit CPU: 2 accesses per word
    \item Account for address alignment:
    \begin{itemize}
        \item Unaligned access may require additional memory cycles
        \item Byte ordering (little-endian for ARM) affects access pattern
    \end{itemize}
\end{itemize}
\end{KR}

\begin{example2}{Memory Access Analysis}\\
A 16-bit wide asynchronous SRAM is connected to the FMC of an STM32F429 microcontroller. Analyze what happens when the CPU writes a single byte to address 0x6402'8F21:

\begin{enumerate}
    \item Determine the memory device and bank
    \item Calculate the memory location in the device
    \item Identify which byte line (NBL) is activated
    \item Explain the complete address decomposition
\end{enumerate}

\tcblower
\paragraph{Solution:}

1. \textbf{Memory device and bank:}
   \begin{itemize}
     \item Address 0x6402'8F21 begins with 0x64...
     \item From address bits [27:26] = 01, this is in Bank 2
     \item This activates NE2 (chip select 2)
   \end{itemize}

2. \textbf{Memory location in device:}
   \begin{itemize}
     \item Only address bits [25:1] are passed to the SRAM device
     \item Bit [0] is used to select the high/low byte within a 16-bit word
     \item Memory location = 0x0014'7490 (shifted right by 1 bit and ignoring higher bits that aren't connected)
   \end{itemize}

3. \textbf{Byte line activation:}
   \begin{itemize}
     \item Address bit [0] = 1, so we're accessing the high byte in the 16-bit word
     \item For 16-bit memory: NBL[1:0] = 10 (high byte active)
     \item NBL[0] = 1 (not active), NBL[1] = 0 (active)
   \end{itemize}

4. \textbf{Complete address decomposition:}
   \begin{itemize}
     \item 0x6402'8F21 decomposed:
     \begin{itemize}
       \item Bits [31:28]: 0x6 (not used for decoding)
       \item Bits [27:26]: 01 (Bank 2, activates NE2)
       \item Bits [25:1]: Memory address within SRAM (0x0014'7490)
       \item Bit [0]: 1 (select high byte)
     \end{itemize}
     \item FMC signals during access:
     \begin{itemize}
       \item NE2 = 0 (active)
       \item A[24:0] = 0x0014'7490 (memory address)
       \item NBL[1:0] = 10 (access high byte)
       \item NWE = 0 (active, writing)
       \item Data appears on D[15:8] (high byte)
     \end{itemize}
   \end{itemize}
\end{example2}

\section{Memory (Speicher)}

\subsection{Speicher-Technologien}

\begin{KR}{SRAM vs. SDRAM Unterschiede}\\
    \paragraph{Speichertyp}
    \begin{itemize}
        \item SRAM: Statisch (Flip-Flop basiert)
        \item SDRAM: Dynamisch (Kondensator basiert)
    \end{itemize}
    
    \paragraph{Refresh-Verhalten}
    \begin{itemize}
        \item SRAM: Kein Refresh nötig (Inhalt bleibt solange Spannung anliegt)
        \item SDRAM: Periodischer Refresh notwendig (Leckströme)
    \end{itemize}
    
    \paragraph{Schnittstelle}
    \begin{itemize}
        \item SRAM: Asynchron (NWE, NOE Signale)
        \item SDRAM: Synchron (RAS, CAS Signale, getaktet)
    \end{itemize}
    
    \paragraph{Zugriffszeit}
    \begin{itemize}
        \item SRAM: Alle Zugriffe gleich schnell
        \item SDRAM: Hohe Latenz für ersten Zugriff, kurze Zeit für Folgeadressen
    \end{itemize}
    
    \paragraph{Speicherdichte}
    \begin{itemize}
        \item SRAM: Größere Zellen $\rightarrow$ geringere Dichte, teurer
        \item SDRAM: Kleinere Zellen $\rightarrow$ höhere Dichte, günstiger
    \end{itemize}
\end{KR}

\begin{example2}{Asynchronous SRAM vs. SDRAM}\\
    Vergleiche die beiden Speichertypen anhand ihrer Eigenschaften.
    
    \tcblower
    
    \textbf{SRAM (Static RAM):}
    \begin{itemize}
        \item Speicherelement: Flip-Flop (6 Transistoren)
        \item Kein Refresh erforderlich
        \item Asynchrone Schnittstelle (einfache Anbindung)
        \item Konstante Zugriffszeit
        \item Hoher Preis pro Bit, niedrige Dichte
    \end{itemize}
    
    \textbf{SDRAM (Synchronous Dynamic RAM):}
    \begin{itemize}
        \item Speicherelement: Kondensator + Transistor
        \item Periodischer Refresh notwendig
        \item Synchrone Schnittstelle (komplexe Anbindung)
        \item Variable Zugriffszeit (Burst-optimiert)
        \item Niedriger Preis pro Bit, hohe Dichte
    \end{itemize}
    
    \textbf{OE-Pin Funktion bei SRAM:}
    Kontrolliert, ob das Memory Daten auf den Bus treibt oder ob sich die Ausgangstreiber im Floating-Zustand befinden.
\end{example2}

\subsection{SRAM-Anbindung und Address Decoding}

\begin{KR}{SRAM-Anbindung berechnen}
    \paragraph{Anzahl Adresspins}
    Für x K $\times$ y Bit SRAM: Adresspins = $\log_2$(x K) = $\log_2$(x $\times$ 1024)\\
    \includegraphics[width=\linewidth]{sram_pins_ex.png}
    
    \paragraph{Basisadresse + Anzahl Adressen}
    \begin{itemize}
        \item Basisadresse: niedrigste Adresse des Bausteins
        \item Höchste Adresse: Basisadresse + Speichergröße - 1
        \item Beispiel 64K: 64K = 64 $\times$ 1024 = 65536 = 0x10000
    \end{itemize}
    
    \paragraph{Partial Address Decoding}
    \begin{itemize}
        \item Nicht alle Adressleitungen werden dekodiert
        \item Führt zu mehreren gültigen Adressbereichen (Aliasing)
        \item Anzahl Bereiche = $2^{nicht\_dekodierte\_Bits}$
    \end{itemize}
    
    \paragraph{FMC-Signale zuordnen}
    \begin{itemize}
        \item NE[x]: Chip Select (Bank-Auswahl)
        \item NOE: Output Enable
        \item NWE: Write Enable
        \item A[n:0]: Adressleitungen
        \item D[m:0]: Datenleitungen
    \end{itemize}
\end{KR}

\begin{example2}{64K x 8 Bit SRAM Anbindung}\\
    SRAM soll bei Basisadresse 0x6800'0000 angeschlossen werden.
    
    \tcblower
    
    \textbf{a) Anzahl Adresspins:}
    64K = $2^{16}$ $\rightarrow$ 16 Adresspins $\rightarrow$ A[15:0]
    
    \textbf{b) FMC-Signale:}
    \begin{itemize}
        \item NE[3] (Bank 3: 0x6800'0000 - 0x6BFF'FFFF)
        \item NOE (Output Enable)
        \item NWE (Write Enable)
        \item A[15:0] (Adressleitungen)
        \item D[7:0] (8-bit Datenbus)
    \end{itemize}
    
    \textbf{c) Höchste Adresse:}
    0x6800'0000 + 64K - 1 = 0x6800'0000 + 0xFFFF = 0x6800'FFFF
    
    \textbf{d) Partial Address Decoding:}
    Bits A[25:16] nicht angeschlossen $\rightarrow$ 10 Bits $\rightarrow$ $2^{10}$ = 1024 Adressblöcke
    
    \textbf{e) Aliasing-Bereiche:}
    0x68XX'0000, 0x69XX'0000, 0x6AXX'0000, 0x6BXX'0000
\end{example2}

\subsection{Flash-Speicher und DRAM}

\begin{KR}{DRAM-Eigenschaften bewerten}\\
    \paragraph{Speicherzelle}
    \begin{itemize}
        \item \textcolor{frog}{$\checkmark$} Kondensator + Transistor (nicht RS Flip-Flop)
        \item \textcolor{frog}{$\checkmark$} Sehr kleine Zelle $\rightarrow$ hohe Dichte
    \end{itemize}
    
    \paragraph{Zugriffsmuster}
    \begin{itemize}
        \item \textcolor{frog}{$\checkmark$} Hohe Latenz für einzelne Zugriffe
        \item \textcolor{frog}{$\checkmark$} Optimiert für Blockzugriffe (Burst)
    \end{itemize}
    
    \paragraph{Refresh und Leistung}
    \begin{itemize}
        \item \textcolor{frog}{$\checkmark$} Periodischer Refresh wegen Leckströmen
        \item \textcolor{frog}{$\checkmark$} Volatiler Speicher
        \item \textcolor{red}{$\times$} Kein niedriger Leistungsverbrauch (Refresh erforderlich)
    \end{itemize}
    
    \paragraph{Kosten}
    \begin{itemize}
        \item \textcolor{red}{$\times$} Niedriger Preis pro Speicherzelle (nicht hoch)
    \end{itemize}
\end{KR}

\begin{KR}{NOR vs. NAND Flash Vergleich}\\
    \paragraph{NOR Flash}
    \begin{itemize}
        \item \textcolor{frog}{$\checkmark$} Direkter Code-Execution (XIP - Execute in Place)
        \item \textcolor{frog}{$\checkmark$} Wahlfreie Byte-Zugriffe
        \item \textcolor{frog}{$\checkmark$} SRAM-kompatible Schnittstelle
        \item \textcolor{frog}{$\checkmark$} Bits einzeln auf '0' schreibbar
        \item \textcolor{frog}{$\checkmark$} Für Programmcode und persistente Daten
        \item \textcolor{red}{$\times$} Nicht für große Datenblöcke optimiert
    \end{itemize}
    
    \paragraph{NAND Flash}
    \begin{itemize}
        \item \textcolor{frog}{$\checkmark$} Effizient für große Datenblöcke
        \item \textcolor{frog}{$\checkmark$} Hohe Schreibgeschwindigkeit für Blöcke
        \item \textcolor{frog}{$\checkmark$} Spezielle Schnittstelle (nicht SRAM-kompatibel)
        \item \textcolor{frog}{$\checkmark$} Hohe Latenz für ersten Zugriff
        \item \textcolor{frog}{$\checkmark$} Für SSDs verwendet
        \item \textcolor{red}{$\times$} Code muss ins RAM geladen werden
        \item \textcolor{red}{$\times$} Keine wahlfreien Byte-Zugriffe
    \end{itemize}
    
    \paragraph{Gemeinsame Eigenschaften}
    \begin{itemize}
        \item \textcolor{frog}{$\checkmark$} Floating Gate Technologie
        \item \textcolor{frog}{$\checkmark$} Nur sektorweises Löschen auf '1'
        \item \textcolor{red}{$\times$} Bits können nicht einzeln auf '1' geschrieben werden
    \end{itemize}
\end{KR}

\begin{example2}{Flash-Speicher Eigenschaften}\\
    Bewerte Aussagen für NOR und NAND Flash.
    
    \tcblower
    
    \textbf{NOR Flash - Anwendungen:}
    \begin{itemize}
        \item Mikrocontroller-Firmware (direkte Ausführung)
        \item BIOS/UEFI Code
        \item Embedded Systems mit wenig RAM
    \end{itemize}
    
    \textbf{NAND Flash - Anwendungen:}
    \begin{itemize}
        \item Solid State Drives (SSDs)
        \item SD-Karten, USB-Sticks
        \item Smartphones (App-Speicher)
    \end{itemize}
    
    \textbf{Wichtiger Unterschied:}
    NOR ermöglicht wahlfreie Zugriffe wie RAM, während NAND blockweise gelesen werden muss und eine spezielle Controller-Logik benötigt.
\end{example2}

\begin{remark}
    Bei der Speicher-Auswahl ist das Anwendungsprofil entscheidend: NOR Flash für direkten Code-Zugriff, NAND Flash für große Datenmengen, SRAM für schnelle Zwischenspeicherung, DRAM für große Arbeitsspeicher mit hoher Dichte.
\end{remark}