\section{Serial Data Transfer - SPI}

\subsection{Serial Communication Basics}

\begin{concept}{Serial vs. Parallel Communication}\\
Microcontrollers often use serial connections for communication:
\begin{itemize}
    \item \textbf{Serial Connection}: Data transmitted one bit at a time over fewer wires
    \begin{itemize}
        \item Simpler (saves PCB area)
        \item Reduces number of switching lines (reduced power, improved EMC)
        \item Requires higher-level protocol for interpretation
    \end{itemize}
    \item \textbf{Parallel Bus}: Data transmitted over multiple lines simultaneously
    \begin{itemize}
        \item Faster for short distances
        \item More complex routing
        \item Higher power consumption and EMC issues
    \end{itemize}
\end{itemize}
\end{concept}

\begin{definition}{Serial Communication Modes}
\begin{itemize}
    \item \textbf{Simplex}: Unidirectional, one-way only communication
    \item \textbf{Half-duplex}: Bidirectional, but only one direction at a time
    \item \textbf{Full-duplex}: Bidirectional, both directions simultaneously
\end{itemize}
\end{definition}

\begin{definition}{Serial Communication Timing}
\begin{itemize}
    \item \textbf{Synchronous}: Both nodes use the same clock
    \begin{itemize}
        \item Clock often provided by master
        \item Examples: SPI, I2C
    \end{itemize}
    \item \textbf{Asynchronous}: Each node uses an individual clock
    \begin{itemize}
        \item Start/stop bits used for synchronization
        \item Example: UART
    \end{itemize}
\end{itemize}
\end{definition}

\subsection{SPI Overview}

\begin{concept}{SPI - Serial Peripheral Interface}\\
SPI is a synchronous serial bus primarily for on-board connections:
\begin{itemize}
    \item Introduced by Motorola (now NXP) around 1979
    \item Also called 4-wire bus
    \item De facto standard (no legally binding specification)
    \item Used for short-distance communication
    \item Connects microcontroller to external devices (sensors, displays, flash memory, etc.)
    \item Full-duplex communication
    \item Single master, multiple slaves
    \item Synchronous (master provides clock)
\end{itemize}
\end{concept}

\begin{definition}{SPI Signals}
\begin{itemize}
    \item \textbf{SCLK} (Serial Clock): Generated by master
    \item \textbf{MOSI} (Master Out Slave In): Data from master to slave
    \item \textbf{MISO} (Master In Slave Out): Data from slave to master
    \item \textbf{SS/CS} (Slave Select/Chip Select): Enables specific slave(s)
\end{itemize}
\end{definition}

\begin{concept}{SPI Master-Slave Architecture}
\begin{itemize}
    \item Master generates common clock signal (SCLK) for all slaves
    \item Master selects slave by asserting the appropriate SS line (active low)
    \item MOSI line connects to inputs of all slaves
    \item MISO lines from all slaves are connected to a single master input
    \item Inactive slaves (SS = '1') put their MISO line in tri-state (high impedance)
    \item Only one selected slave drives its MISO line at a time
\end{itemize}
\end{concept}

\subsection{SPI Implementation}

\begin{concept}{SPI Implementation Using Shift Registers}
\begin{itemize}
    \item Both master and slave contain 8-bit shift registers
    \item Bits are shifted out on one clock edge (toggling edge)
    \item Bits are sampled on the other clock edge (sampling edge)
    \item 8 clock cycles exchange 8 bits in each direction simultaneously
    \item After 8 clock cycles, data has been exchanged in both directions
    \item Status flags (TXE, RXNE) indicate buffer status
\end{itemize}
\end{concept}

\subsection{SPI Modes}

\begin{concept}{Clock Polarity and Phase}
SPI has four different modes based on two parameters:
\begin{itemize}
    \item \textbf{CPOL} (Clock Polarity): Idle state of clock
    \begin{itemize}
        \item CPOL = 0: Clock idles at low level
        \item CPOL = 1: Clock idles at high level
    \end{itemize}
    \item \textbf{CPHA} (Clock Phase): Which edge is used for data sampling
    \begin{itemize}
        \item CPHA = 0: Data sampled on first clock edge
        \item CPHA = 1: Data sampled on second clock edge
    \end{itemize}
\end{itemize}
\end{concept}

\begin{concept}{Four SPI Modes}
\begin{itemize}
    \item \textbf{Mode 0}: CPOL = 0, CPHA = 0
    \begin{itemize}
        \item Clock idles low
        \item Data sampled on rising edge, changed on falling edge
    \end{itemize}
    \item \textbf{Mode 1}: CPOL = 0, CPHA = 1
    \begin{itemize}
        \item Clock idles low
        \item Data sampled on falling edge, changed on rising edge
    \end{itemize}
    \item \textbf{Mode 2}: CPOL = 1, CPHA = 0
    \begin{itemize}
        \item Clock idles high
        \item Data sampled on falling edge, changed on rising edge
    \end{itemize}
    \item \textbf{Mode 3}: CPOL = 1, CPHA = 1
    \begin{itemize}
        \item Clock idles high
        \item Data sampled on rising edge, changed on falling edge
    \end{itemize}
\end{itemize}
\end{concept}

\subsection{SPI Characteristics}

\begin{definition}{SPI Properties}
\begin{itemize}
    \item No defined addressing scheme (uses SS lines instead)
    \item No built-in acknowledgment or error detection
    \item Originally for single-byte transfers (now also used for streaming)
    \item Flexible data rate (clock signal is transmitted with data)
    \item No flow control (master controls timing, slave cannot influence)
    \item Susceptible to clock line noise
\end{itemize}
\end{definition}

\columnbreak

\subsection{STM32 SPI Implementation}

\begin{concept}{STM32 SPI Architecture}
The STM32F4 SPI peripheral includes:
\begin{itemize}
    \item Configuration registers (SPI\_CR1, SPI\_CR2)
    \item Status register (SPI\_SR)
    \item Data register (SPI\_DR) for transmit and receive
    \item Status flags for synchronization (TXE, RXNE, BSY)
    \item Support for different communication modes
    \item DMA capability for high-speed transfers
\end{itemize}
\end{concept}

\begin{code}{STM32 SPI Register Configuration}
\begin{lstlisting}[language=C, style=basesmol]
// SPI configuration example
// Configure SPI1 in master mode, CPOL=1, CPHA=1, 8-bit data

// Enable SPI1 clock
RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;

// Configure SPI1
SPI1->CR1 = (1 << 0)   // CPHA=1
          | (1 << 1)   // CPOL=1
          | (1 << 2)   // Master mode
          | (3 << 3)   // BR[2:0]=011: fPCLK/16 (prescaler)
          | (0 << 7)   // MSB first (LSBFIRST=0)
          | (1 << 8)   // SSI=1 (needed for software SS)
          | (1 << 9);  // SSM=1 (software slave management)

// Enable SPI
SPI1->CR1 |= (1 << 6); // SPE=1 (SPI enable)
\end{lstlisting}
\end{code}

\begin{KR}{Transmitting Data with SPI}
\paragraph{Step 1: Prepare SPI}
Configure and enable the SPI peripheral.
\paragraph{Step 2: Check TXE flag}
Wait until the transmit buffer is empty.
\paragraph{Step 3: Write data}
Write data to the data register.
\paragraph{Step 4: Wait for completion}
Wait until transmission is complete by checking BSY flag.

\begin{lstlisting}[language=C, style=basesmol]
// Transmit a byte over SPI
uint8_t transmit_byte(uint8_t data) {
    // Step 1: SPI should already be configured
    
    // Step 2: Wait until TXE=1 (transmit buffer empty)
    while (!(SPI1->SR & (1 << 1))) { }
    
    // Step 3: Write data to transmit
    SPI1->DR = data;
    
    // Step 4: Wait for reception (needed to get received data)
    while (!(SPI1->SR & (1 << 0))) { }
    
    // Return received data (read DR clears RXNE flag)
    return SPI1->DR;
}
\end{lstlisting}
\end{KR}

\begin{KR}{Handling Full-Duplex SPI Communication}
\paragraph{Step 1: Enable SPI with SPE bit}
Ensure SPI is properly configured and enabled.
\paragraph{Step 2: Write first byte to transmit}
Write the first byte to DR to start transmission/reception.
\paragraph{Step 3: Process data in a loop}
Check TXE and RXNE flags to handle both transmission and reception.
\paragraph{Step 4: Wait for completion}
Wait for BSY=0 to ensure all transfers are complete.

\begin{lstlisting}[language=C, style=basesmol]
// Full-duplex SPI communication
void spi_transfer(uint8_t *tx_data, uint8_t *rx_data, uint16_t length) {
    // Enable SPI
    SPI1->CR1 |= (1 << 6);  // SPE=1
    
    // Write first TX byte to start transmission
    if (length > 0) {
        SPI1->DR = tx_data[0];
    }
    
    uint16_t tx_count = 1;
    uint16_t rx_count = 0;
    
    // Process data
    while (rx_count < length) {
        // Check if we can transmit more data
        if ((tx_count < length) && (SPI1->SR & (1 << 1))) {  // TXE=1
            SPI1->DR = tx_data[tx_count++];
        }
        
        // Check if we received data
        if (SPI1->SR & (1 << 0)) {  // RXNE=1
            rx_data[rx_count++] = SPI1->DR;
        }
    }
    
    // Wait until BSY=0 (SPI not busy)
    while (SPI1->SR & (1 << 7)) { }
}
\end{lstlisting}
\end{KR}

\begin{example2}{SPI Mode Identification from Timing Diagram}\\
Given the following timing diagram, identify the SPI mode (CPOL/CPHA values):
\important{add actual timing diagram here}\\
%SCLK: \_/‾\\\_/‾\\\_/‾\\\_/‾\\\_/‾\\\_/‾\\\_/‾\\\_/‾\\\_
%MOSI: ‾‾\\\_\_\_/‾‾‾\\\_\_\_/‾‾‾\\\_\_\_/‾‾‾
Data:  1     0     1     0     1     1     0     1

\tcblower
Looking at the diagram:
- Clock starts low and returns to low between transfers (CPOL = 0)
- Data appears to change on rising edges
- Data is sampled on falling edges

This corresponds to Mode 1: CPOL = 0, CPHA = 1
\end{example2}




    