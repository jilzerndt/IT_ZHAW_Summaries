\section{Interrupt Performance}

\subsection{Event Detection Methods}

\begin{theorem}{Polling vs. Interrupt-Driven I/O}\\
Two primary methods for detecting events in embedded systems:
\begin{itemize}
    \item \textbf{Polling}: Periodically checking status registers
    \begin{itemize}
        \item Synchronous with main program
        \item CPU actively queries peripherals
        \item Predictable timing
        \item Simple implementation
    \end{itemize}
    \item \textbf{Interrupt-Driven}: Hardware signals the CPU when events occur
    \begin{itemize}
        \item Asynchronous with main program
        \item CPU notified only when an event happens
        \item Event-driven approach
        \item More complex implementation
    \end{itemize}
\end{itemize}
\end{theorem}

\subsubsection{Polling}

\begin{definition}{Polling}\\
    Periodische Abfrage von Status-Informationen durch die CPU.
    \begin{itemize}
        \item Synchron mit dem Hauptprogramm
        \item CPU fragt aktiv nach Status-Aenderungen
        \item Einfach zu implementieren, deterministisch
        \item Verschwendet CPU-Zeit durch \important{Busy Wait}
    \end{itemize}
\end{definition}


\begin{concept}{Polling Implementation}\\
In polling, the CPU periodically checks status registers to detect events:
\begin{itemize}
    \item Main loop continuously or periodically inspects peripheral status
    \item When an event is detected, appropriate handler executes
    \item After handling, control returns to polling loop
    \item CPU always actively checking, even when no events occur
\end{itemize}

Advantages:
\begin{itemize}
    \item Simple and straightforward implementation
    \item Deterministic behavior (predictable timing)
    \item No need for complex interrupt handling
    \item Implicit synchronization (operations happen in sequence)
\end{itemize}

Disadvantages:
\begin{itemize}
    \item Wastes CPU cycles checking for events that haven't occurred
    \item Reduced system throughput (CPU busy checking instead of processing)
    \item Potentially long response times (if many devices must be checked)
    \item Inefficient for infrequent events
\end{itemize}
\end{concept}



\begin{KR}{Implementing Polling in C}
\paragraph{Step 1: Identify status registers}
Determine which peripheral registers contain status information.
\paragraph{Step 2: Create a polling loop}
Implement a loop that regularly checks the status flags.
\paragraph{Step 3: Check for events}
Test specific bits in the status registers to detect events.
\paragraph{Step 4: Handle detected events}
Process events when their status flags are set.
\paragraph{Step 5: Clear status flags}
Reset status flags to prepare for next event detection.

\begin{lstlisting}[language=C, style=basesmol]
// Main polling loop
while (1) {
    // Check SPI transmit buffer empty flag
    if (SPI1->SR & SPI_SR_TXE) {
        // Handle SPI transmission
        if (spi_tx_count < spi_tx_length) {
            SPI1->DR = spi_tx_buffer[spi_tx_count++];
        }
    }
    
    // Check UART receive data register not empty flag
    if (USART2->SR & USART_SR_RXNE) {
        // Handle UART reception
        uint8_t data = USART2->DR;
        process_uart_data(data);
    }
    
    // Check ADC end of conversion flag
    if (ADC1->SR & ADC_SR_EOC) {
        // Handle ADC conversion complete
        uint16_t adc_value = ADC1->DR;  // Reading DR clears EOC flag
        process_adc_data(adc_value);
    }
    
    // Other system tasks
    process_system_tasks();
}
\end{lstlisting}
\end{KR}

\raggedcolumns
\columnbreak

\subsubsection{Interrupt-Driven I/O}

\begin{definition}{Interrupt-driven I/O}\\
    Peripheriegeraete signalisieren Events asynchron an die CPU.
    \begin{itemize}
        \item Hardware setzt Interrupt-Flag bei Event
        \item CPU wird unterbrochen und fuehrt ISR aus
        \item Effiziente CPU-Nutzung
        \item Komplexere Implementierung
    \end{itemize}
\end{definition}

\begin{concept}{Interrupt-Driven I/O}
In interrupt-driven I/O, peripherals notify the CPU when events occur:
\begin{itemize}
    \item Peripherals assert interrupt signal when they need servicing
    \item CPU temporarily suspends current execution
    \item Control transfers to an Interrupt Service Routine (ISR)
    \item After handling the interrupt, control returns to previous execution
\end{itemize}

Advantages:
\begin{itemize}
    \item Efficient CPU utilization (only responds when needed)
    \item Fast response to events
    \item Good for infrequent, time-critical events
    \item Main program can focus on primary tasks
\end{itemize}

Disadvantages:
\begin{itemize}
    \item More complex implementation
    \item Can introduce timing uncertainties (non-deterministic behavior)
    \item Potential for interrupt conflicts and priority issues
    \item Overhead for context switching
\end{itemize}
\end{concept}

\begin{KR}{Configuring Interrupt-Driven I/O}
\paragraph{Step 1: Configure interrupt sources}
Enable specific interrupt sources in peripherals.
\paragraph{Step 2: Configure NVIC}
Set up the Nested Vectored Interrupt Controller for the interrupts.
\paragraph{Step 3: Implement ISRs}
Create Interrupt Service Routines to handle specific events.
\paragraph{Step 4: Enable global interrupts}
Enable the global interrupt flag.

\begin{lstlisting}[language=C, style=basesmol]
// Step 1: Configure SPI interrupt
void configure_spi_interrupt(void) {
    // Enable SPI peripheral clock
    RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
    
    // Configure SPI parameters
    SPI1->CR1 = SPI_CR1_MSTR | SPI_CR1_SSI | SPI_CR1_SSM;
    
    // Enable SPI TX buffer empty interrupt
    SPI1->CR2 |= SPI_CR2_TXEIE;
    
    // Step 2: Configure NVIC for SPI1
    NVIC_SetPriority(SPI1_IRQn, 2);  // Set priority level
    NVIC_EnableIRQ(SPI1_IRQn);       // Enable interrupt in NVIC
}

// Step 3: Implement SPI1 ISR
void SPI1_IRQHandler(void) {
    // Check if TX buffer empty interrupt
    if (SPI1->SR & SPI_SR_TXE) {
        if (spi_tx_count < spi_tx_length) {
            // Send next byte
            SPI1->DR = spi_tx_buffer[spi_tx_count++];
        } else {
            // Transfer complete, disable interrupt
            SPI1->CR2 &= ~SPI_CR2_TXEIE;
        }
    }
}

// Main function
int main(void) {
    // Initialize system
    system_init();
    
    // Configure SPI interrupt
    configure_spi_interrupt();
    
    // Step 4: Enable global interrupts
    __enable_irq();
    
    // Main loop - can perform other tasks
    while (1) {
        process_system_tasks();
    }
}
\end{lstlisting}
\end{KR}

\raggedcolumns
\columnbreak

\subsection{Interrupt Performance Analysis}

\begin{concept}{Interrupt Performance Metriken}\\
    Wichtige Kenngroessen zur Bewertung von Interrupt-Systemen:
    \begin{itemize}
        \item \important{Interrupt-Frequenz} $f_{INT}$ [Hz]: Wie oft tritt ein Interrupt auf?
        \item \important{Interrupt Service Time} $t_{ISR}$ [s]: Wie lange dauert die ISR-Ausfuehrung?
        \item \important{Impact} [\%]: Welcher Anteil der CPU-Zeit wird fuer Interrupts verwendet?
    \end{itemize}
\end{concept}

\begin{formula}{Impact Berechnung}\\
    Der Einfluss von Interrupts auf die Systemleistung:
    $$\text{Impact} = f_{INT} \times t_{ISR} \times 100\%$$
    
    Dabei ist:
    \begin{itemize}
        \item $f_{INT}$: Interrupt-Frequenz in Hz
        \item $t_{ISR}$: Interrupt Service Time in Sekunden
        \item Impact: Prozentuale CPU-Belastung durch Interrupts
    \end{itemize}
\end{formula}

\begin{KR}{Interrupt Performance Analyse}
    \paragraph{Schritt 1: Interrupt-Frequenz bestimmen}
    \begin{itemize}
        \item Datenrate und Puffergroesse analysieren
        \item $f_{INT} = \frac{\text{Datenrate [bit/s]}}{\text{Puffergroesse [bit]}}$
    \end{itemize}
    
    \paragraph{Schritt 2: Service Time berechnen}
    \begin{itemize}
        \item Anzahl Clockzyklen fuer ISR bestimmen
        \item $t_{ISR} = \frac{\text{Clockzyklen}}{\text{CPU-Frequenz [Hz]}}$
    \end{itemize}
    
    \paragraph{Schritt 3: Impact berechnen}
    \begin{itemize}
        \item $\text{Impact} = f_{INT} \times t_{ISR} \times 100\%$
        \item Pruefung: Impact $<$ 100\% fuer stabilen Betrieb
    \end{itemize}
    
    \paragraph{Schritt 4: Kritische Datenrate bestimmen}
    \begin{itemize}
        \item Fuer 100\% CPU-Auslastung: $f_{INT} \times t_{ISR} = 1$
        \item Maximale Datenrate: $\text{Rate}_{max} = \frac{\text{Puffergroesse}}{t_{ISR}}$
    \end{itemize}
\end{KR}

\begin{example2}{Interrupt Performance Berechnung}\\
    Ein Prozessorsystem (1 MHz Takt) empfaengt Daten mit 16 kbit/s. Das Peripheriegeraet kann 32 bit zwischenspeichern. Die ISR benoetigt 100 Clockzyklen.
    
    \tcblower
    
    \textbf{Loesung:}
    
    \textbf{a) Impact berechnen:}
    \begin{itemize}
        \item $f_{INT} = \frac{16 \text{ kbit/s}}{32 \text{ bit}} = 500 \text{ Hz}$
        \item $t_{ISR} = \frac{100 \text{ Zyklen}}{1 \text{ MHz}} = 100 \mu s$
        \item $\text{Impact} = 500 \text{ Hz} \times 100 \mu s \times 100\% = 5\%$
    \end{itemize}
    
    \textbf{b) Kritische Datenrate fuer 100\% CPU-Last:}
    \begin{itemize}
        \item $(x / 32 \text{ bit}) \times 100 \mu s = 1$
        \item $x = \frac{32 \text{ bit}}{100 \mu s} = 320 \text{ kbit/s}$
    \end{itemize}
    
    \textbf{c) Datenverlust bei 90\% Last:}
    \\ ISR-Zeit schwankt je nach Instruktion und Daten $\Rightarrow$ Peaks koennen zu Datenverlust fuehren.
\end{example2}


\begin{definition}{Key Performance Metrics}\\
Several metrics characterize interrupt performance:
\begin{itemize}
    \item \textbf{Interrupt Frequency} ($f_{INT}$): How often an interrupt occurs (events per second)
    \item \textbf{Interrupt Service Time} ($t_{ISR}$): Time required to process an interrupt
    \item \textbf{Interrupt Latency}: Time between interrupt event and start of ISR execution
    \item \textbf{System Impact}: Percentage of CPU time spent handling interrupts
\end{itemize}
\end{definition}

\begin{formula}{System Impact Calculation}\\
The percentage of CPU time consumed by interrupts can be calculated as:
\begin{align}
\text{Impact (\%)} = f_{INT} \times t_{ISR} \times 100\%
\end{align}

Examples:
\begin{itemize}
    \item Keyboard interrupt: $f_{INT} = 20$ Hz, $t_{ISR} = 6$ µs
    \begin{align}
    \text{Impact} = 20 \text{ Hz} \times 6 \text{ µs} \times 100\% = 0.012\%
    \end{align}
    \item High-speed serial interface: $f_{INT} = 28,800$ Hz, $t_{ISR} = 6$ µs
    \begin{align}
    \text{Impact} = 28,800 \text{ Hz} \times 6 \text{ µs} \times 100\% = 17.3\%
    \end{align}
\end{itemize}
\end{formula}

\begin{concept}{Interrupt Overload Conditions}\\
Interrupt overload occurs when the system cannot keep up with incoming interrupts:
\begin{itemize}
    \item When $t_{ISR} >$ time between interrupt events
    \item Some interrupt events will be missed or delayed
    \item Data may be lost
    \item System may become unresponsive to new interrupts
\end{itemize}

Factors that may lead to overload:
\begin{itemize}
    \item Too many interrupt sources
    \item Interrupt sources that trigger too frequently
    \item ISRs that take too long to execute
    \item Varying interrupt frequencies causing bursts
    \item Improper interrupt priority management
\end{itemize}
\end{concept}

\begin{KR}{Optimizing ISR Performance}
\paragraph{Keep ISRs short}
Perform only time-critical operations in the ISR.
\paragraph{Defer processing to main loop}
Use flags, queues, or buffers to pass data to main loop.
\paragraph{Use hardware features}
Take advantage of DMA and peripheral buffers.
\paragraph{Apply appropriate priorities}
Assign higher priorities to more time-critical interrupts.
\paragraph{Disable interrupts judiciously}
Disable interrupts only when necessary, for as short a time as possible.

\begin{lstlisting}[language=C, style=basesmol]
// Non-optimized ISR
void USART2_IRQHandler(void) {
    if (USART2->SR & USART_SR_RXNE) {
        // Directly process data in ISR (slow)
        char c = USART2->DR;
        process_character(c);  // Time-consuming
        update_display();      // Even more time-consuming
    }
}

// Optimized ISR
volatile uint8_t rx_buffer[256];
volatile uint8_t rx_write_idx = 0;
volatile uint8_t rx_read_idx = 0;
volatile bool new_data_available = false;

void USART2_IRQHandler(void) {
    if (USART2->SR & USART_SR_RXNE) {
        // Only store data in buffer (fast)
        rx_buffer[rx_write_idx++] = USART2->DR;
        new_data_available = true;
    }
}

// Process data in main loop
void main(void) {
    // Initialize
    system_init();
    
    while (1) {
        if (new_data_available) {
            // Process all received data
            while (rx_read_idx != rx_write_idx) {
                process_character(rx_buffer[rx_read_idx++]);
            }
            
            // Update display once after processing all characters
            update_display();
            
            // Reset flag
            new_data_available = false;
        }
        
        // Other system tasks
        process_system_tasks();
    }
}
\end{lstlisting}
\end{KR}

\subsection{Interrupt Latency}

\begin{definition}{Interrupt Latency}\\
Interrupt latency is the time between an interrupt event and the first useful instruction execution in the ISR:
\begin{itemize}
    \item \textbf{Hardware Latency}: Time for hardware to detect and signal the event
    \item \textbf{Arbitration Latency}: Time to determine which interrupt to service (if multiple)
    \item \textbf{CPU Latency}: Time to complete current instruction and save context
    \item \textbf{OS/Software Latency}: Additional delays due to software overhead
\end{itemize}
Latency is critical for real-time systems, where guaranteed response times are required.
\end{definition}

\begin{concept}{Sources of Interrupt Latency}\\
Several factors contribute to interrupt latency:
\begin{itemize}
    \item \textbf{Current CPU Instruction}:
    \begin{itemize}
        \item Multi-cycle instructions may complete before the interrupt is serviced
        \item Some instructions may be abandoned and restarted (e.g., SDIV/UDIV on Cortex-M3/M4)
        \item Some may be interrupted and resumed (e.g., LDM/STM on Cortex-M3/M4)
    \end{itemize}
    \item \textbf{Disabled Interrupts}:
    \begin{itemize}
        \item Global interrupts may be disabled (CPSID i / CPSIE i)
        \item Specific interrupts may be masked
    \end{itemize}
    \item \textbf{Higher Priority Interrupts}:
    \begin{itemize}
        \item Lower priority interrupts wait until higher priority ones complete
    \end{itemize}
    \item \textbf{Context Saving}:
    \begin{itemize}
        \item Pushing registers to stack
        \item More registers saved means higher latency
    \end{itemize}
    \item \textbf{Cache and Memory Behavior}:
    \begin{itemize}
        \item Cache misses when fetching ISR code
        \item Memory wait states
    \end{itemize}
\end{itemize}
\end{concept}

\begin{KR}{Managing Interrupt Latency}
\paragraph{Use interrupt priorities}
Assign appropriate priorities based on timing requirements.
\paragraph{Limit interrupt disable periods}
Minimize sections where interrupts are disabled.
\paragraph{Optimize context switching}
Use processor features that minimize context save/restore.
\paragraph{Preempt lower-priority tasks}
Allow high-priority interrupts to preempt less critical ones.
\paragraph{Move waiting loops to main program}
Don't block inside ISRs waiting for slow peripherals.

\begin{lstlisting}[language=C, style=basesmol]
// Poor: Blocking in ISR
void SPI1_IRQHandler(void) {
    // Read data from input
    input_data = read_input_source();
    
    // Process data
    processed_data = process_data(input_data);
    
    // Wait for output device to be ready (blocking)
    while (!(SPI1->SR & SPI_SR_TXE)) { }
    
    // Write data to output
    SPI1->DR = processed_data;
}

// Better: Queue-based approach
void SPI1_IRQHandler(void) {
    // Read data from input
    input_data = read_input_source();
    
    // Process data
    processed_data = process_data(input_data);
    
    // Add to output queue and return
    queue_add(output_queue, processed_data);
}

// In main loop
void main(void) {
    // Initialize
    system_init();
    
    while (1) {
        // Check if there's data to send and SPI is ready
        if (!queue_empty(output_queue) && (SPI1->SR & SPI_SR_TXE)) {
            // Send next item
            SPI1->DR = queue_get(output_queue);
        }
        
        // Other tasks
        process_system_tasks();
    }
}
\end{lstlisting}
\end{KR}

\subsection{Pre-emption and Priority}

\begin{concept}{Nested Vector Interrupt Controller (NVIC)}\\
The ARM Cortex-M NVIC provides advanced interrupt handling features:
\begin{itemize}
    \item Supports up to 240 external interrupt sources (IRQs)
    \item Each interrupt can be assigned one of 256 priority levels (processor specific)
    \item Priority-based interrupt preemption
    \item Automatic context saving and restoring
    \item Tail-chaining optimization (reduced latency between ISRs)
    \item Late-arrival handling (higher priority interrupts can overtake pending lower ones)
\end{itemize}
\end{concept}

\begin{definition}{Interrupt Preemption}\\
Preemption allows higher-priority interrupts to interrupt lower-priority ones:
\begin{itemize}
    \item When a higher-priority interrupt occurs during a lower-priority ISR
    \item Current ISR is suspended (context saved)
    \item Higher-priority ISR executes
    \item After completion, lower-priority ISR resumes
\end{itemize}
This ensures that critical interrupts are handled promptly, regardless of other interrupt activity.
\end{definition}

\begin{concept}{Priority-Based Interrupt Handling}\\
Key aspects of priority-based interrupt handling:
\begin{itemize}
    \item \textbf{Priority Assignment}:
    \begin{itemize}
        \item Assign priorities based on time-criticality and importance
        \item Lower numerical values usually indicate higher priority
    \end{itemize}
    \item \textbf{Priority Grouping}:
    \begin{itemize}
        \item Cortex-M supports priority grouping into pre-emption and sub-priority levels
        \item Pre-emption priority determines whether an interrupt can pre-empt another
        \item Sub-priority determines ordering when multiple interrupts of same pre-emption priority occur
    \end{itemize}
    \item \textbf{Priority Inversion}:
    \begin{itemize}
        \item Problem where a high-priority task is indirectly delayed by a low-priority task
        \item Can be mitigated through proper design and priority inheritance protocols
    \end{itemize}
\end{itemize}
\end{concept}

\begin{KR}{Configuring Interrupt Priorities}
\paragraph{Step 1: Analyze timing requirements}
Determine which interrupts are most time-critical.
\paragraph{Step 2: Group interrupts by importance}
Create logical groups based on system criticality.
\paragraph{Step 3: Assign priority levels}
Configure NVIC priority registers for each interrupt.
\paragraph{Step 4: Configure priority grouping}
Set priority group using NVIC\_SetPriorityGrouping().

\begin{lstlisting}[language=C, style=basesmol]
// Configure interrupt priorities
void configure_interrupt_priorities(void) {
    // Set priority grouping (4 bits for pre-emption priority, 0 bits for sub-priority)
    NVIC_SetPriorityGrouping(3);
    
    // Critical interrupts (highest priority)
    NVIC_SetPriority(EXTI0_IRQn, 0);      // Emergency stop button
    NVIC_SetPriority(TIM1_UP_IRQn, 1);    // Critical timing control
    
    // Medium priority interrupts
    NVIC_SetPriority(SPI1_IRQn, 4);       // Sensor data acquisition
    NVIC_SetPriority(USART2_IRQn, 5);     // Communication
    
    // Lower priority interrupts
    NVIC_SetPriority(ADC_IRQn, 10);       // Regular ADC sampling
    NVIC_SetPriority(TIM3_IRQn, 11);      // Status LED updates
    
    // Enable the interrupts
    NVIC_EnableIRQ(EXTI0_IRQn);
    NVIC_EnableIRQ(TIM1_UP_IRQn);
    NVIC_EnableIRQ(SPI1_IRQn);
    NVIC_EnableIRQ(USART2_IRQn);
    NVIC_EnableIRQ(ADC_IRQn);
    NVIC_EnableIRQ(TIM3_IRQn);
}
\end{lstlisting}
\end{KR}

\raggedcolumns
\pagebreak

\subsection{Interrupt-Driven State Machines}

\begin{concept}{Interrupt-driven Finite State Machine}\\
    Kombination von Interrupt-System und Zustandsautomat:
    \begin{itemize}
        \item ISRs generieren Events und schreiben sie in Queue
        \item FSM in Main Loop liest Events aus Queue
        \item Deterministische Event-Verarbeitung
        \item Saubere Trennung von Interrupt- und Anwendungslogik
    \end{itemize}
\end{concept}

\begin{code}{Interrupt-driven FSM Struktur}
\begin{lstlisting}[language=C, style=basesmol]
// Main Loop
int main(void) {
    event_t event;
    fsm_init();
    peripherals_init();
    
    while (1) {
        event = get_event_from_queue();
        if (event != NO_EVENT) {
            fsm_handle_event(event);
        }
    }
}

// Interrupt Service Routines
void ISR_Peripheral1(void) {
    // Event in Queue schreiben
    write_event_to_queue(EVENT_PERIPHERAL1);
    // Interrupt Flag loeschen
    clear_interrupt_flag();
}
\end{lstlisting}
\end{code}

\begin{example2}{Interrupt Performance Problem}
    System mit 90\% Interrupt-Last verliert trotzdem Daten. Erklaeren Sie eine plausible Ursache.
    
    \tcblower
    
    \textbf{Loesung:}
    
    Die Interrupt Service Time ist nicht konstant:
    \begin{itemize}
        \item \textbf{Variable Latency}: Je nach aktueller CPU-Instruktion
        \item \textbf{Datenabhaengige ISR-Dauer}: Unterschiedliche Verarbeitungszeiten
        \item \textbf{Jitter}: Schwankungen in der Interrupt-Behandlung
        \item \textbf{Preemption}: Andere Interrupts koennen verzoegern
    \end{itemize}
    
    Bei 90\% Durchschnittslast koennen Spitzen $>$ 100\% erreichen $\Rightarrow$ Datenverlust.
    
    \textbf{Abhilfe:}
    \begin{itemize}
        \item Puffergroesse erhoehen
        \item ISR-Zeit reduzieren und konstanter machen
        \item Sicherheitsmarge bei Systemauslegung einplanen
    \end{itemize}
\end{example2}

\begin{remark}
    \textbf{Faustregeln fuer Interrupt-Systeme:}
    \begin{itemize}
        \item Impact sollte $<$ 50\% bleiben fuer stabile Performance
        \item ISR-Zeit sollte konstant und vorhersagbar sein
        \item Kritische Daten immer puffern (Hardware oder Software)
        \item Bei mehreren Interrupt-Quellen: Prioritaeten sorgfaeltig waehlen
    \end{itemize}
\end{remark}

\begin{concept}{Integrating Interrupts and State Machines}\\
Combining interrupt-driven I/O with state machines creates efficient event-driven systems:
\begin{itemize}
    \item \textbf{Event Queue}: Buffer between ISRs and state machine
    \begin{itemize}
        \item ISRs detect events and add them to queue
        \item Main loop pulls events from queue and feeds state machine
    \end{itemize}
    \item \textbf{ISR Responsibilities}:
    \begin{itemize}
        \item Minimal processing (detect event, capture data)
        \item Add event to queue
        \item Return quickly
    \end{itemize}
    \item \textbf{Main Loop Responsibilities}:
    \begin{itemize}
        \item Pull events from queue
        \item Process events through state machine
        \item Handle longer-duration processing
    \end{itemize}
\end{itemize}
\end{concept}

\begin{KR}{Implementing Interrupt-Driven FSM}
\paragraph{Step 1: Create event queue}
Implement a buffer to store events from ISRs.
\paragraph{Step 2: Implement ISRs}
Keep ISRs short, just capturing events and adding to queue.
\paragraph{Step 3: Implement state machine}
Create state machine logic to process events from queue.
\paragraph{Step 4: Connect with main loop}
Pull events from queue and feed to state machine in main loop.

\begin{lstlisting}[language=C, style=basesmol]
// Define event types and queue
typedef enum {
    EVENT_BUTTON_PRESS,
    EVENT_TIMEOUT,
    EVENT_SENSOR_TRIGGER,
    EVENT_NO_EVENT
} event_t;

#define EVENT_QUEUE_SIZE 16
event_t event_queue[EVENT_QUEUE_SIZE];
int queue_head = 0;
int queue_tail = 0;
int queue_count = 0;

// Add event to queue (called from ISRs)
void queue_add_event(event_t event) {
    if (queue_count < EVENT_QUEUE_SIZE) {
        event_queue[queue_tail] = event;
        queue_tail = (queue_tail + 1) % EVENT_QUEUE_SIZE;
        queue_count++;
    }
}

// Get event from queue (called from main loop)
event_t queue_get_event(void) {
    event_t event = EVENT_NO_EVENT;
    
    if (queue_count > 0) {
        event = event_queue[queue_head];
        queue_head = (queue_head + 1) % EVENT_QUEUE_SIZE;
        queue_count--;
    }
    
    return event;
}

\end{lstlisting}
\end{KR}

\begin{KR}{Part 2: Implementing the State Machine}
\begin{lstlisting}[language=C, style=basesmol]

// Button interrupt handler
void EXTI0_IRQHandler(void) {
    // Check if EXTI0 interrupt occurred
    if (EXTI->PR & EXTI_PR_PR0) {
        // Add button press event to queue
        queue_add_event(EVENT_BUTTON_PRESS);
        
        // Clear pending bit
        EXTI->PR = EXTI_PR_PR0;
    }
}

// Timer interrupt handler
void TIM2_IRQHandler(void) {
    if (TIM2->SR & TIM_SR_UIF) {
        // Add timeout event to queue
        queue_add_event(EVENT_TIMEOUT);
        
        // Clear update interrupt flag
        TIM2->SR &= ~TIM_SR_UIF;
    }
}

// Main loop with state machine
int main(void) {
    // Initialize system and interrupts
    system_init();
    __enable_irq();
    
    // Initialize state machine
    fsm_init();
    
    while (1) {
        // Get event from queue
        event_t event = queue_get_event();
        
        // Process event with state machine
        if (event != EVENT_NO_EVENT) {
            fsm_handle_event(event);
        }
        
        // Background tasks
        process_system_tasks();
    }
}
\end{lstlisting}
\end{KR}

\begin{example2}{Complete Interrupt-Driven FSM Example}
Implement a button-controlled LED system with debouncing using timer interrupts.
\tcblower
The system has three states:
- OFF: LED is off
- ON: LED is on at full brightness
- BLINK: LED is blinking

Events:
- SHORT\_PRESS: Button pressed briefly
- LONG\_PRESS: Button held for >1 second
- BLINK\_TIMER: Timer for blinking

\begin{lstlisting}[language=C, style=basesmol]
// Event definitions
typedef enum {
    EVENT_NONE,
    EVENT_SHORT_PRESS,
    EVENT_LONG_PRESS,
    EVENT_BLINK_TIMER
} event_t;

// State definitions
typedef enum {
    STATE_OFF,
    STATE_ON,
    STATE_BLINK
} state_t;

// Global variables
volatile event_t event_queue[10];
volatile uint8_t queue_head = 0;
volatile uint8_t queue_tail = 0;
volatile uint8_t queue_count = 0;
volatile state_t current_state = STATE_OFF;
volatile uint32_t button_press_time = 0;
volatile uint8_t button_released = 1;

// Button interrupt handler (EXTI0)
void EXTI0_IRQHandler(void) {
    uint32_t current_time = HAL_GetTick();
    
    if (EXTI->PR & EXTI_PR_PR0) {
        if (GPIOA->IDR & GPIO_PIN_0) {
            // Button released
            if (!button_released) {
                uint32_t press_duration = current_time - button_press_time;
                if (press_duration > 1000) {
                    // Long press (>1s)
                    if (queue_count < 10) {
                        event_queue[queue_tail] = EVENT_LONG_PRESS;
                        queue_tail = (queue_tail + 1) % 10;
                        queue_count++;
                    }
                } else if (press_duration > 50) {
                    // Short press (debounced)
                    if (queue_count < 10) {
                        event_queue[queue_tail] = EVENT_SHORT_PRESS;
                        queue_tail = (queue_tail + 1) % 10;
                        queue_count++;
                    }
                }
                button_released = 1;
            }
        } else {
            // Button pressed
            button_press_time = current_time;
            button_released = 0;
        }
        
        // Clear pending bit
        EXTI->PR = EXTI_PR_PR0;
    }
}
\end{lstlisting}
\end{example2}

\begin{example2}{Complete Interrupt-Driven FSM Example (continued)}
\begin{lstlisting}[language=C, style=basesmol]
// Timer interrupt for blinking (TIM3)
void TIM3_IRQHandler(void) {
    if (TIM3->SR & TIM_SR_UIF) {
        // Add blink timer event to queue
        if (queue_count < 10) {
            event_queue[queue_tail] = EVENT_BLINK_TIMER;
            queue_tail = (queue_tail + 1) % 10;
            queue_count++;
        }
        
        // Clear update interrupt flag
        TIM3->SR &= ~TIM_SR_UIF;
    }
}

// State machine handler
void fsm_handle_event(event_t event) {
    switch (current_state) {
        case STATE_OFF:
            if (event == EVENT_SHORT_PRESS) {
                // Turn on LED
                GPIOC->BSRR = GPIO_PIN_13;
                current_state = STATE_ON;
                
                // Disable blink timer
                TIM3->CR1 &= ~TIM_CR1_CEN;
            } else if (event == EVENT_LONG_PRESS) {
                // Start blinking
                GPIOC->BSRR = GPIO_PIN_13;
                current_state = STATE_BLINK;
                
                // Enable blink timer
                TIM3->CR1 |= TIM_CR1_CEN;
            }
            break;
            
        case STATE_ON:
            if (event == EVENT_SHORT_PRESS) {
                // Turn off LED
                GPIOC->BSRR = (GPIO_PIN_13 << 16);
                current_state = STATE_OFF;
            } else if (event == EVENT_LONG_PRESS) {
                // Start blinking
                current_state = STATE_BLINK;
                
                // Enable blink timer
                TIM3->CR1 |= TIM_CR1_CEN;
            }
            break;
            
        case STATE_BLINK:
            if (event == EVENT_BLINK_TIMER) {
                // Toggle LED
                GPIOC->ODR ^= GPIO_PIN_13;
            } else if (event == EVENT_SHORT_PRESS) {
                // Turn off LED and blinking
                GPIOC->BSRR = (GPIO_PIN_13 << 16);
                current_state = STATE_OFF;
                
                // Disable blink timer
                TIM3->CR1 &= ~TIM_CR1_CEN;
            }
            break;
    }
}

\end{lstlisting}
\end{example2}

\begin{example2}{Complete Interrupt-Driven FSM Example (continued)}
\begin{lstlisting}[language=C, style=basesmol]

// Main function
int main(void) {
    // Initialize hardware
    system_init();
    
    // Configure EXTI for button
    // Configure TIM3 for blinking (500ms period)
    // Enable interrupts
    
    while (1) {
        // Get and process events
        if (queue_count > 0) {
            event_t event;
            
            // Disable interrupts to access queue
            __disable_irq();
            event = event_queue[queue_head];
            queue_head = (queue_head + 1) % 10;
            queue_count--;
            __enable_irq();
            
            // Handle event
            fsm_handle_event(event);
        }
        
        // System can enter low-power mode here
        // when queue is empty
    }
}
\end{lstlisting}
\end{example2}

\section{Interrupt Performance Exercises}

\subsection{Interrupt Performance Analysis}

\begin{KR}{Analyzing Interrupt System Performance}
\paragraph{Calculate interrupt frequency}
\begin{itemize}
    \item Identify the source and rate of interrupts
    \item For periodic interrupts, calculate frequency directly
    \item For data-driven interrupts (e.g., serial interface), calculate:
    \begin{itemize}
        \item f$_{INT}$ = data\_rate / data\_size\_per\_interrupt
        \item Example: 9600 baud UART with 8 data bits = 9600/8 = 1200 Hz
    \end{itemize}
\end{itemize}

\paragraph{Determine interrupt service time}
\begin{itemize}
    \item Estimate execution time of the Interrupt Service Routine (ISR)
    \item Include:
    \begin{itemize}
        \item Context switching time (register saving/restoring)
        \item Instruction execution time of the routine itself
        \item Memory access time
    \end{itemize}
    \item Measure or calculate in CPU clock cycles, then convert to time
    \item t$_{ISR}$ = cycles / f$_{CPU}$
\end{itemize}

\paragraph{Calculate system impact}
\begin{itemize}
    \item Percentage of CPU time used by interrupts:
    \item Impact = f$_{INT}$ × t$_{ISR}$ × 100\%
    \item Assess if the impact is acceptable:
    \begin{itemize}
        \item < 10\%: Minimal impact
        \item 10-50\%: Moderate impact
        \item > 50\%: Significant impact, may need optimization
        \item > 90\%: System likely unable to perform other tasks
    \end{itemize}
    \item Check if t$_{ISR}$ > 1/f$_{INT}$ - indicates missed interrupts
\end{itemize}

\paragraph{Optimize interrupt handling}
\begin{itemize}
    \item Reduce ISR execution time:
    \begin{itemize}
        \item Keep ISRs short
        \item Move non-critical processing to main loop
        \item Use efficient algorithms and data structures
    \end{itemize}
    \item Manage interrupt frequency:
    \begin{itemize}
        \item Use buffering to reduce interrupt rate
        \item Adjust hardware configurations if possible
    \end{itemize}
    \item Implement interrupt prioritization for critical tasks
\end{itemize}
\end{KR}

\begin{example2}{Interrupt System Analysis}\\
A processor system running at 1 MHz receives data through a peripheral interface at a rate of 16 kbit/s. The peripheral can buffer 32 bits of data and signals the processor via an interrupt line when the buffer is ready to be read. If the data is not read before the next interrupt, it is lost.

The Interrupt Service Routine (ISR) requires 100 clock cycles on average, including call and return overhead. The system uses no other interrupts.

\begin{enumerate}
    \item Calculate the impact of interrupts on the system performance.
    \item Determine the maximum data rate the interface could handle before the processor spends 100\% of its time handling interrupts.
    \item If the data rate is increased such that the system spends 90\% of its time handling interrupts, occasional data loss still occurs. Explain a possible cause.
\end{enumerate}

\tcblower
\paragraph{Solution:}

1. \textbf{Calculate interrupt impact:}
   \begin{itemize}
     \item Interrupt frequency: f$_{INT}$ = 16 kbit/s ÷ 32 bits = 500 Hz
     \item Interrupt service time: t$_{ISR}$ = 100 cycles ÷ 1 MHz = 100 $mu$s
     \item Impact = f$_{INT}$ × t$_{ISR}$ × 100\% = 500 Hz × 100 $mu$s × 100\% = 5\%
   \end{itemize}
   Therefore, interrupts consume 5\% of the CPU's processing time.

2. \textbf{Maximum data rate calculation:}
   \begin{itemize}
     \item For 100\% CPU usage: 1 = f$_{INT}$ × t$_{ISR}$
     \item f$_{INT}$ = 1 ÷ t$_{ISR}$ = 1 ÷ 100 $mu$s = 10,000 Hz
     \item Data rate = f$_{INT}$ × 32 bits = 10,000 × 32 = 320 kbit/s
   \end{itemize}

3. \textbf{Cause of occasional data loss:}
   \begin{itemize}
     \item At 90\% CPU utilization, there should theoretically be enough time to process all interrupts
     \item However, the service time (t$_{ISR}$) is not constant but an average
     \item Some interrupt instances may take longer than the average 100 cycles
     \item When t$_{ISR}$ varies, occasional peaks can exceed the time between interrupts
     \item The variation may come from:
     \begin{itemize}
       \item Different code paths within the ISR depending on the data
       \item Memory access times that vary due to cache effects
       \item Context switching overhead that varies based on CPU state
       \item Interrupt latency variations based on what instruction was executing
     \end{itemize}
     \item When a single interrupt takes too long, the next interrupt arrives before processing is complete
     \item With high CPU utilization (90\%), there's little margin for these variations
     \item Result: occasional buffer overflows and data loss
   \end{itemize}
\end{example2}

\subsection{Interrupt Latency Optimization}

\begin{KR}{Managing Interrupt Latency}
\paragraph{Understand latency components}
\begin{itemize}
    \item \textbf{Hardware latency:}
    \begin{itemize}
        \item Time for interrupt controller to recognize interrupt
        \item Time to finish current instruction (multi-cycle instructions)
        \item Time to push registers onto stack
    \end{itemize}
    \item \textbf{Software latency:}
    \begin{itemize}
        \item Interrupt disabled periods
        \item Higher priority interrupt processing
        \item Cache misses during ISR execution
    \end{itemize}
\end{itemize}

\paragraph{Measure interrupt latency}
\begin{itemize}
    \item Use an oscilloscope to measure time between:
    \begin{itemize}
        \item Interrupt trigger signal
        \item GPIO pin toggle in ISR
    \end{itemize}
    \item Alternatively, use a timer to capture timestamps:
    \begin{itemize}
        \item Configure timer to capture on interrupt signal
        \item Read timer value at ISR entry
        \item Calculate difference
    \end{itemize}
    \item Measure best-case, worst-case, and average latency
\end{itemize}

\paragraph{Optimize for consistent latency}
\begin{itemize}
    \item Minimize interrupt disable periods
    \begin{itemize}
        \item Keep critical sections short
        \item Use selective interrupt masking instead of global disable
    \end{itemize}
    \item Optimize ISR code
    \begin{itemize}
        \item Minimize stack usage to reduce push/pop operations
        \item Keep ISRs short and efficient
        \item Ensure frequently used data and code are in cache
    \end{itemize}
    \item Use appropriate priorities
    \begin{itemize}
        \item Assign higher priorities to time-critical interrupts
        \item Group interrupts with similar timing requirements
    \end{itemize}
\end{itemize}

\paragraph{Implement deterministic response}
\begin{itemize}
    \item For time-critical operations, consider:
    \begin{itemize}
        \item Polling instead of interrupts if determinism is crucial
        \item Hardware solutions (DMA, dedicated controllers)
        \item Real-time operating system with predictable scheduling
    \end{itemize}
    \item Move processing from ISRs to main loop
    \begin{itemize}
        \item ISR only captures essential data and signals main loop
        \item Use flags, semaphores, or message queues for communication
    \end{itemize}
\end{itemize}
\end{KR}

\begin{example2}{Interrupt Latency Optimization}\\
A microcontroller-based system needs to sample an analog signal at precise 100 µs intervals. The current implementation uses Timer1 to generate interrupts every 100 µs, and the ISR reads the ADC. Measurements show that the interrupt latency varies between 5-20 µs, causing jitter in the sampling.

Design an improved solution to minimize sampling jitter, explaining your approach and implementation.

\tcblower
\paragraph{Solution:}

The goal is to reduce sampling jitter by minimizing variations in the time between the timer interrupt and ADC sampling. Here's an improved solution:

\textbf{Hardware-triggered ADC approach:}

1. \textbf{Use timer to trigger ADC directly:}
   \begin{itemize}
     \item Configure Timer1 to generate a trigger signal every 100 µs
     \item Connect this trigger to the ADC hardware trigger input
     \item Configure the ADC to start conversion automatically on timer trigger
     \item Use DMA to transfer ADC results to memory without CPU intervention
   \end{itemize}

2. \textbf{Implementation details:}
\begin{lstlisting}[language=C, style=basesmol]
// Configure Timer1
void configure_timer(void) {
    // Enable clock for Timer1
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
    
    // Set prescaler and period for 100 microsecond interval
    TIM1->PSC = (SystemCoreClock / 1000000) - 1;  // 1 microsecond timer ticks
    TIM1->ARR = 100 - 1;  // 100 microsecond period
    
    // Configure timer to generate trigger output
    TIM1->CR2 &= ~TIM_CR2_MMS;
    TIM1->CR2 |= TIM_CR2_MMS_1;  // Update event as trigger output
    
    // Enable timer
    TIM1->CR1 |= TIM_CR1_CEN;
}

// Configure ADC with timer trigger
void configure_adc(void) {
    // Enable clocks for ADC and GPIO
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    
    // Configure GPIO pin as analog input
    GPIOA->MODER |= GPIO_MODER_MODER0;  // PA0 as analog
    
    // Configure ADC for timer trigger
    ADC1->CR2 |= ADC_CR2_EXTEN_0;        // Enable external trigger on rising edge
    ADC1->CR2 |= ADC_CR2_EXTSEL_3;       // Select Timer1 TRGO as trigger
    
    // Configure single conversion on channel 0
    ADC1->SQR3 = 0;  // Channel 0 as first conversion
    ADC1->SQR1 = 0;  // 1 conversion
    
    // Enable DMA for ADC
    ADC1->CR2 |= ADC_CR2_DMA;
    
    // Enable ADC
    ADC1->CR2 |= ADC_CR2_ADON;
}

\end{lstlisting}
\end{example2}

\begin{example2}{Complete Interrupt-Driven FSM Example (continued)}
\begin{lstlisting}[language=C, style=basesmol]

// Configure DMA for ADC
void configure_dma(uint16_t* buffer, uint32_t buffer_size) {
    // Enable DMA clock
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
    
    // Configure DMA stream
    DMA2_Stream0->CR &= ~DMA_SxCR_EN;  // Disable DMA during config
    
    DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;       // Source: ADC data register
    DMA2_Stream0->M0AR = (uint32_t)buffer;         // Destination: buffer
    DMA2_Stream0->NDTR = buffer_size;              // Number of data items
    
    DMA2_Stream0->CR &= ~DMA_SxCR_DIR;             // Peripheral to memory
    DMA2_Stream0->CR |= DMA_SxCR_CIRC;             // Circular mode
    DMA2_Stream0->CR |= DMA_SxCR_PSIZE_0;          // Peripheral size: 16 bits
    DMA2_Stream0->CR |= DMA_SxCR_MSIZE_0;          // Memory size: 16 bits
    DMA2_Stream0->CR |= DMA_SxCR_PL_1;             // Priority: high
    
    // Enable DMA
    DMA2_Stream0->CR |= DMA_SxCR_EN;
}

// Main application
int main(void) {
    // Sample buffer
    uint16_t adc_buffer[1000];
    
    // Configure peripherals
    configure_timer();
    configure_adc();
    configure_dma(adc_buffer, 1000);
    
    // Process samples in background
    while (1) {
        // Process captured samples from adc_buffer
        // Buffer is continuously updated by DMA
    }
}
\end{lstlisting}

3. \textbf{Advantages of this approach:}
   \begin{itemize}
     \item Eliminates interrupt latency completely from the sampling process
     \item Hardware triggers ADC directly with precise timing
     \item DMA transfers data without CPU intervention
     \item CPU is free to process samples when available
     \item Sampling jitter reduced to hardware timing accuracy (typically sub-µs)
   \end{itemize}

4. \textbf{Alternative approaches:}
   \begin{itemize}
     \item If hardware triggering is not available, optimize the ISR:
     \begin{itemize}
       \item Set ISR to highest priority
       \item Disable all other interrupts during the ISR
       \item Make the ISR as short as possible (just start ADC)
       \item Use a state variable to track if previous conversion completed
     \end{itemize}
     \item Use a high-precision external timer dedicated to ADC triggering
   \end{itemize}

This solution eliminates software-induced jitter by leveraging hardware synchronization between the timer and ADC, providing the precise 100 µs sampling interval required.
\end{example2}

\subsection{Interrupt-Driven System Design}

\begin{KR}{Designing Efficient Interrupt-Driven Systems}
\paragraph{Choose between polling and interrupts}
\begin{itemize}
    \item \textbf{Use interrupts when:}
    \begin{itemize}
        \item Events occur infrequently or at unpredictable times
        \item System needs to respond to external events quickly
        \item Power efficiency is important (can sleep between events)
        \item Multiple event sources need to be monitored simultaneously
    \end{itemize}
    \item \textbf{Use polling when:}
    \begin{itemize}
        \item Events occur at very high frequency
        \item Absolute determinism is required
        \item Interrupt overhead would be excessive
        \item Extremely low latency is required
    \end{itemize}
\end{itemize}

\paragraph{Design efficient ISRs}
\begin{itemize}
    \item Keep ISRs as short as possible
    \begin{itemize}
        \item Only handle time-critical operations in the ISR
        \item Defer processing to main loop using flags or queues
        \item Avoid complex calculations or I/O operations
    \end{itemize}
    \item Manage shared resources
    \begin{itemize}
        \item Use volatile for variables shared between ISR and main code
        \item Consider atomic operations for simple updates
        \item Implement proper synchronization for complex data structures
    \end{itemize}
    \item Avoid nesting or recursion in ISRs
\end{itemize}

\paragraph{Implement event queues}
\begin{itemize}
    \item Use queue to transfer events from ISRs to main loop
    \begin{itemize}
        \item ISR detects event and enqueues it
        \item Main loop dequeues and processes events
    \end{itemize}
    \item Design queue to be interrupt-safe
    \begin{itemize}
        \item Use atomic operations if available
        \item Consider implementing lock-free algorithms
        \item Size queue appropriately to avoid overflow
    \end{itemize}
    \item Process events in order of importance or arrival
\end{itemize}

\paragraph{Implement event-driven architecture}
\begin{itemize}
    \item Structure code as state machines responding to events
    \item Separate event detection (ISRs) from processing (handlers)
    \item Design for different operating modes
    \begin{itemize}
        \item Normal operation
        \item Power-saving modes
        \item Error handling and recovery
    \end{itemize}
    \item Consider using an RTOS for complex systems
\end{itemize}
\end{KR}

\begin{example2}{Interrupt-Driven UART Communication System}\\
Design an interrupt-driven communication system with the following requirements:
\begin{itemize}
    \item UART interface operating at 115200 baud, 8N1 format
    \item Must handle both transmit and receive operations
    \item System should never lose incoming data
    \item Main application should not be blocked by I/O operations
    \item CPU runs at 72 MHz and has other tasks to perform
\end{itemize}

\tcblower
\paragraph{Solution:}

The system will use an interrupt-driven approach with queues to handle UART communication efficiently:

1. \textbf{System architecture:}
   \begin{itemize}
     \item Receive interrupt (RXNE) to handle incoming data
     \item Transmit interrupt (TXE) to send outgoing data
     \item Circular buffers for both TX and RX data
     \item Non-blocking API for the main application
   \end{itemize}

2. \textbf{Implementation:}

\begin{lstlisting}[language=C, style=basesmol]
#include <stdint.h>
#include <stdbool.h>

// Buffer size must be power of 2 for efficient wrap-around
#define UART_BUFFER_SIZE 256
#define UART_BUFFER_MASK (UART_BUFFER_SIZE - 1)

// Circular buffer structure
typedef struct {
    volatile uint8_t data[UART_BUFFER_SIZE];
    volatile uint16_t head;
    volatile uint16_t tail;
} circular_buffer_t;

// Global buffers
static circular_buffer_t rx_buffer = {0};
static circular_buffer_t tx_buffer = {0};
static volatile bool tx_busy = false;

// Function prototypes
void uart_init(uint32_t baudrate);
bool uart_send_byte(uint8_t data);
bool uart_send_data(const uint8_t* data, uint16_t length);
bool uart_read_byte(uint8_t* data);
uint16_t uart_available(void);
void uart_flush(void);

// External hardware functions
extern void uart_hw_init(uint32_t baudrate);
extern void uart_hw_send_byte(uint8_t data);
extern uint8_t uart_hw_read_byte(void);
extern bool uart_hw_tx_empty(void);
extern bool uart_hw_rx_ready(void);
extern void uart_hw_enable_tx_interrupt(bool enable);
extern void uart_hw_enable_rx_interrupt(bool enable);

\end{lstlisting}
\end{example2}

\begin{example2}{Complete Interrupt-Driven FSM Example (continued)}
\begin{lstlisting}[language=C, style=basesmol]

// Buffer operations
static bool buffer_is_full(const circular_buffer_t* buffer) {
    return ((buffer->head + 1) & UART_BUFFER_MASK) == buffer->tail;
}

static bool buffer_is_empty(const circular_buffer_t* buffer) {
    return buffer->head == buffer->tail;
}

static bool buffer_push(circular_buffer_t* buffer, uint8_t data) {
    uint16_t next_head = (buffer->head + 1) & UART_BUFFER_MASK;
    
    if (next_head == buffer->tail) {
        return false; // Buffer full
    }
    
    buffer->data[buffer->head] = data;
    buffer->head = next_head;
    return true;
}

static bool buffer_pop(circular_buffer_t* buffer, uint8_t* data) {
    if (buffer->head == buffer->tail) {
        return false; // Buffer empty
    }
    
    *data = buffer->data[buffer->tail];
    buffer->tail = (buffer->tail + 1) & UART_BUFFER_MASK;
    return true;
}

static uint16_t buffer_count(const circular_buffer_t* buffer) {
    return (buffer->head - buffer->tail) & UART_BUFFER_MASK;
}

// UART initialization
void uart_init(uint32_t baudrate) {
    // Initialize hardware
    uart_hw_init(baudrate);
    
    // Reset buffers
    rx_buffer.head = rx_buffer.tail = 0;
    tx_buffer.head = tx_buffer.tail = 0;
    tx_busy = false;
    
    // Enable receive interrupt
    uart_hw_enable_rx_interrupt(true);
    // Transmit interrupt will be enabled when data is available
}

\end{lstlisting}
\end{example2}

\begin{example2}{Complete Interrupt-Driven FSM Example (continued)}
\begin{lstlisting}[language=C, style=basesmol]

// Send a single byte (non-blocking)
bool uart_send_byte(uint8_t data) {
    bool success;
    bool start_transmission = false;
    
    // Critical section: disable interrupts
    __disable_irq();
    
    success = buffer_push(&tx_buffer, data);
    
    // If TX is not busy and we successfully added data, start transmission
    if (success && !tx_busy) {
        start_transmission = true;
        tx_busy = true;
    }
    
    // End critical section
    __enable_irq();
    
    if (start_transmission) {
        uart_hw_enable_tx_interrupt(true);
    }
    
    return success;
}

// Send multiple bytes (non-blocking)
bool uart_send_data(const uint8_t* data, uint16_t length) {
    for (uint16_t i = 0; i < length; i++) {
        if (!uart_send_byte(data[i])) {
            return false; // Buffer full
        }
    }
    return true;
}

// Read a single byte (non-blocking)
bool uart_read_byte(uint8_t* data) {
    return buffer_pop(&rx_buffer, data);
}

// Get number of bytes available to read
uint16_t uart_available(void) {
    return buffer_count(&rx_buffer);
}

// Flush TX buffer
void uart_flush(void) {
    // Wait until TX buffer is empty
    while (!buffer_is_empty(&tx_buffer)) {
        __NOP(); // No operation - just wait
    }
    
    // Wait until last byte is transmitted
    while (tx_busy) {
        __NOP();
    }
}

// RX interrupt handler
void UART_RX_IRQHandler(void) {
    if (uart_hw_rx_ready()) {
        uint8_t data = uart_hw_read_byte();
        
        // If buffer full, data will be lost
        buffer_push(&rx_buffer, data);
    }
}

\end{lstlisting}
\end{example2}

\begin{example2}{Complete Interrupt-Driven FSM Example (continued)}
\begin{lstlisting}[language=C, style=basesmol]

// TX interrupt handler
void UART_TX_IRQHandler(void) {
    if (uart_hw_tx_empty()) {
        uint8_t data;
        
        if (buffer_pop(&tx_buffer, &data)) {
            // Send next byte
            uart_hw_send_byte(data);
        } else {
            // No more data, disable TX interrupt
            uart_hw_enable_tx_interrupt(false);
            tx_busy = false;
        }
    }
}

// Example usage in main application
void main(void) {
    // Initialize UART
    uart_init(115200);
    
    // Main loop
    while (1) {
        // Check for received data
        if (uart_available() > 0) {
            uint8_t data;
            uart_read_byte(&data);
            
            // Process received data
            process_data(data);
            
            // Echo back
            uart_send_byte(data);
        }
        
        // Perform other tasks
        other_application_tasks();
    }
}
\end{lstlisting}

3. \textbf{Key design elements:}
   \begin{itemize}
     \item \textbf{Circular buffers:} Efficient for handling serial data; no memory copying required
     \item \textbf{Non-blocking API:} Main application can send/receive without waiting
     \item \textbf{Interrupt-driven:} Minimal CPU overhead, responds quickly to data
     \item \textbf{Buffer size is power of 2:} Enables efficient masking for wrap-around
     \item \textbf{Buffer management:} Checks for full/empty conditions to prevent data loss
     \item \textbf{Critical sections:} Protect shared buffer access between ISR and main code
   \end{itemize}

4. \textbf{Performance analysis:}
   \begin{itemize}
     \item At 115200 baud, 8N1:
     \begin{itemize}
       \item 1 start bit + 8 data bits + 1 stop bit = 10 bits per byte
       \item Byte rate = 115200/10 = 11520 bytes per second
       \item Time between bytes = 1/11520 $\approx$ 87 $mu$s
     \end{itemize}
     \item With a 256-byte buffer:
     \begin{itemize}
       \item Buffer can hold 256 × 87 $mu$s $\approx$ 22 ms of data
       \item Sufficient for main loop to process data even with other tasks
     \end{itemize}
     \item ISR execution time:
     \begin{itemize}
       \item At 72 MHz, reading a byte and storing it takes ~10 cycles
       \item ISR overhead (entry/exit) ~20 cycles
       \item Total ~30 cycles = 0.42 $mu$s
       \item Impact = 0.42 $mu$s / 87 $mu$s $\approx$ 0.5\% of CPU time
     \end{itemize}
   \end{itemize}

This design provides an efficient, interrupt-driven UART interface that meets all requirements with minimal CPU overhead.
\end{example2}
