\section{eXtreme Programming (XP)}

\subsection{Einführung in eXtreme Programming}

\begin{definition}{Was ist eXtreme Programming?}\\
    eXtreme Programming (XP) ist eine agile Methode zur Softwareentwicklung, die 1996 von Kent Beck beim Chrysler Comprehensive Compensation System (C3) Projekt entwickelt wurde. XP zeichnet sich durch folgende Merkmale aus:
    \begin{itemize}
        \item Fokus auf Kommunikation, Einfachheit, Feedback, Mut und Respekt
        \item Kurze Entwicklungszyklen mit kontinuierlicher Verbesserung
        \item Betonung von technischer Exzellenz und gutem Design
        \item Reaktionsfähigkeit gegenüber wechselnden Kundenanforderungen
    \end{itemize}
\end{definition}

\begin{concept}{Ausgangslage und Problematik}\\
    XP wurde entwickelt, um typische Risiken in Entwicklungsprojekten zu adressieren:
    \begin{itemize}
        \item Zeitpläne verschieben sich
        \item Projekte werden abgebrochen
        \item Systementwicklung verläuft nicht linear (Fehlerrate steigt überproportional)
        \item Fachliche Missverständnisse
        \item Veränderungen des fachlichen Umfelds
        \item Implementierung der falschen Features
        \item Personalfluktuation
    \end{itemize}
    XP etabliert Prinzipien und Praktiken, um mit diesen Risiken umgehen zu können.
\end{concept}

\subsection{Die Werte von XP}

\begin{concept}{Kommunikation (Communication)}\\
    \begin{itemize}
        \item Jeder ist Teil des Teams mit täglicher Face-to-Face-Kommunikation
        \item Gemeinsame Arbeit in allen Aspekten des Projekts
        \item Zusammen wird die bestmögliche Lösung für Probleme gefunden
    \end{itemize}
\end{concept}

\begin{concept}{Einfachheit (Simplicity)}\\
    \begin{itemize}
        \item Nur das Notwendige und Angeforderte implementieren
        \item Den Wert im Verhältnis zum Aufwand maximieren
        \item Kleine, einfache Schritte zum Ziel machen und Fehler sofort lösen
        \item Lösungen schaffen, die mit vernünftigem Aufwand langfristig wartbar sind
    \end{itemize}
\end{concept}

\begin{concept}{Feedback}\\
    \begin{itemize}
        \item Commitments einer Iteration ernst nehmen und lauffähige Software liefern
        \item Software früh und oft zeigen, sorgfältig zuhören und notwendige Änderungen vornehmen
        \item Über das Projekt sprechen und den Prozess entsprechend anpassen
    \end{itemize}
\end{concept}

\begin{concept}{Mut (Courage)}\\
    \begin{itemize}
        \item Die Wahrheit über Fortschritt und Schätzungen kommunizieren
        \item Keine Ausreden für Scheitern dokumentieren, sondern für Erfolg planen
        \item Keine Angst haben, da niemand allein arbeitet
        \item Sich an Veränderungen anpassen, wann immer sie auftreten
    \end{itemize}
\end{concept}

\begin{concept}{Respekt}\\
    \begin{itemize}
        \item Jedes Teammitglied wird als wertvoll angesehen und respektiert
        \item Alle tragen etwas bei, und sei es nur Enthusiasmus
        \item Entwickler respektieren die Expertise des Kunden und umgekehrt
        \item Vorgesetzte respektieren das Recht des Teams, Verantwortung zu übernehmen
    \end{itemize}
\end{concept}

\subsection{Die Prinzipien von XP}

\begin{concept}{Fundamentale Prinzipien}\\
    \begin{itemize}
        \item \textbf{Rapid Feedback:} Schnellstmögliche Rückmeldung
        \item \textbf{Assume Simplicity:} Davon ausgehen, dass eine einfache Lösung existiert
        \item \textbf{Incremental Change:} Änderungen erfolgen inkrementell
        \item \textbf{Embracing Change:} Änderungen werden erwartet und vorgesehen
        \item \textbf{Quality Work:} Bestmögliche Lösung anstreben
    \end{itemize}
\end{concept}

\begin{concept}{Weitere Prinzipien}\\
    \begin{itemize}
        \item Teach learning (Lernen lehren)
        \item Small initial investment (Kleine anfängliche Investition)
        \item Play to win (Auf Sieg spielen)
        \item Concrete experiments (Konkrete Experimente)
        \item Open, honest communication (Offene, ehrliche Kommunikation)
        \item Work with people's instincts (Mit den Instinkten der Menschen arbeiten)
        \item Accepted responsibility (Akzeptierte Verantwortung)
        \item Local adaptation (Lokale Anpassung)
        \item Travel light (Leicht reisen)
        \item Honest measurement (Ehrliche Messung)
    \end{itemize}
\end{concept}

\begin{concept}{Learning to Drive}\\
    Ein Leitmotiv von XP, formuliert von Kent Beck:
    
    "Wir müssen die Entwicklung von Software durch viele kleine Anpassungen steuern, nicht durch wenige große Anpassungen, ähnlich wie beim Autofahren. Das bedeutet, dass wir das Feedback brauchen, um zu wissen, wann wir leicht abweichen, wir brauchen viele Gelegenheiten für Korrekturen, und wir müssen in der Lage sein, diese Korrekturen zu vernünftigen Kosten vorzunehmen."
\end{concept}

\subsection{XP Praktiken}

\begin{concept}{The Planning Game}\\
    Balance zwischen geschäftlichen und technischen Überlegungen:
    \begin{itemize}
        \item Business entscheidet über: Scope, Priorität, Zusammensetzung der Releases, Release-Daten
        \item Techniker entscheiden über: Schätzungen, Impacts, Prozesse, Feinplanung
    \end{itemize}
\end{concept}

\begin{concept}{Small Releases}\\
    \begin{itemize}
        \item Jedes Release sollte so klein wie möglich sein und die wichtigsten Geschäftsanforderungen enthalten
        \item Das Release muss als Ganzes Sinn machen (keine halbfertigen Features)
        \item Lieber monatlich als halbjährlich liefern
    \end{itemize}
\end{concept}

\begin{concept}{Metaphor}\\
    \begin{itemize}
        \item Jeder im Team muss ein "gemeinsames Verständnis" für das System haben
        \item Ein "gemeinsamer Wortschatz" wird etabliert
        \item Dies gilt für technische und nichttechnische Personen
        \item Definiert, was die Grundelemente des Systems sind und wie sie in Beziehung stehen
    \end{itemize}
\end{concept}

\begin{concept}{Simple Design}\\
    Das richtige Design für ein Softwaresystem:
    \begin{itemize}
        \item Alle Tests bestehen
        \item Keine redundante Logik enthalten
        \item Die kleinstmögliche Anzahl von Klassen und Methoden haben
        \item "Setzen Sie ein, was Sie brauchen, wenn Sie es brauchen" (YAGNI-Prinzip)
        \item Emergent, wachsendes Design; kein "Overdesigning"
    \end{itemize}
\end{concept}

\begin{concept}{Testing}\\
    \begin{itemize}
        \item Programmfunktionen ohne automatisierte Tests existieren nicht
        \item Tests werden Teil des Systems
        \item Tests ermöglichen dem System, Änderungen zu akzeptieren
        \item Entwicklungszyklus: Zuhören (Voraussetzungen) $\rightarrow$ Test (zuerst schreiben) $\rightarrow$ Code (am einfachsten) $\rightarrow$ Design (Refactoring)
    \end{itemize}
\end{concept}

\begin{concept}{Refactoring}\\
    \begin{itemize}
        \item Bei der Implementierung einer Funktion prüfen, ob vorhandener Code verbessert werden kann
        \item Automatisierte Tests bieten ein Sicherheitsnetz für angstfreies Refactoring
        \item Kontinuierliche Verbesserung der Codequalität
    \end{itemize}
\end{concept}

\begin{concept}{Pair Programming}\\
    \begin{itemize}
        \item Produktionscode wird von zwei Personen geschrieben, die gemeinsam an einem Bildschirm arbeiten
        \item Zwei Rollen: Der aktive Programmierer konzentriert sich auf die aktuelle Methode, der andere denkt über den weiteren Kontext nach
        \item Paare wechseln häufig
    \end{itemize}
\end{concept}

\begin{concept}{Collective Ownership}\\
    \begin{itemize}
        \item Jeder, der eine Verbesserungsmöglichkeit sieht, kann jederzeit jeden Teil des Codes ändern
        \item Alle übernehmen Verantwortung für das gesamte System
        \item Nicht jeder kennt jeden Teil gleich gut, aber jeder weiß etwas über jeden Teil
    \end{itemize}
\end{concept}

\begin{concept}{Continuous Integration}\\
    \begin{itemize}
        \item Code wird mindestens einmal täglich integriert und getestet
        \item Der Build-Prozess läuft automatisiert auf einem dedizierten Computer
        \item Automatisierte Tests ermöglichen es, Probleme frühzeitig zu erkennen
    \end{itemize}
\end{concept}

\begin{concept}{40 Hours Week}\\
    \begin{itemize}
        \item Nachhaltige Entwicklung mit gleichmäßig verteiltem Aufwand
        \item Längere Überstunden wirken sich negativ auf die Produktivität aus
        \item Ziel: Morgens frisch, abends müde und zufrieden sein
        \item Abstand vom Computer kann zu "Aha!"-Momenten führen
    \end{itemize}
\end{concept}

\begin{concept}{On-Site Customer}\\
    \begin{itemize}
        \item Ein echter Kunde ist physisch im Team präsent, um Fragen zu beantworten
        \item Echter Kunde = tatsächlicher Benutzer des Systems
        \item Muss nicht zu 100\% am Projekt arbeiten, aber erreichbar sein
        \item Hilft bei der Priorisierung
    \end{itemize}
\end{concept}

\begin{concept}{Coding Standards}\\
    \begin{itemize}
        \item Kollektives Eigentum und kontinuierliches Refactoring erfordern einheitliche Codierungspraktiken im Team
        \item Standards werden gemeinsam definiert und eingehalten
    \end{itemize}
\end{concept}

\subsection{Weitere XP-Praktiken (2. Version)}

\begin{concept}{Test-Driven Development (TDD)}\\
    Zyklische Vorgehensweise:
    \begin{itemize}
        \item Erst wird ein Test geschrieben, der zunächst fehlschlägt
        \item Genau so viel Code implementieren, dass der Test erfolgreich durchläuft
        \item Refactoring des Tests und des Codes
    \end{itemize}
\end{concept}

\begin{concept}{Slack}\\
    \begin{itemize}
        \item Einplanen von kleineren Aufgaben, die bei Bedarf gestrichen werden können
        \item Realistische, erreichbare Ziele setzen
        \item Puffer für unvorhergesehene Probleme einbauen
    \end{itemize}
\end{concept}

\begin{concept}{Spike}\\
    \begin{itemize}
        \item Eine zeitlich begrenzte Untersuchung eines Problems oder einer Technologie
        \item Dient dem Wissensaufbau, wenn das Team nicht genug weiß, um eine Story zu schätzen
        \item Timeboxing ist wichtig
    \end{itemize}
\end{concept}

\begin{concept}{Incremental Design}\\
    \begin{itemize}
        \item Kontinuierliche Verbesserung in kleinen oder kleinsten Schritten
        \item Design entsteht inkrementell während der Entwicklung
        \item Vermeidet umfangreiches Upfront-Design
    \end{itemize}
\end{concept}

\begin{concept}{Self-Organized Team}\\
    \begin{itemize}
        \item Das Unternehmen legt die Prioritäten fest
        \item Das Team organisiert sich selbst, um den besten Weg zur Umsetzung zu finden
        \item Keine Mikromanagement oder externe Arbeitszuweisung
    \end{itemize}
\end{concept}

\subsection{Kosten von Änderungen in XP}

\begin{concept}{Traditionelle vs. XP-Sicht auf Änderungskosten}\\
    \begin{itemize}
        \item \textbf{Traditionelle Sicht:} Kosten steigen exponentiell mit dem Projektfortschritt
        \item \textbf{XP-Sicht:} Durch XP-Praktiken (automatisierte Tests, Refactoring, kontinuierliche Integration) bleibt die Kostenkurve flacher
    \end{itemize}
    Diese flachere Kostenkurve ermöglicht es, Änderungen auch in späteren Projektphasen wirtschaftlich umzusetzen.
\end{concept}

\begin{formula}{XP-Fazit}\\
    \begin{itemize}
        \item XP ist keine "Silberkugel" - es gibt keinen magischen Prozess, der in jedem Projekt identisch funktioniert
        \item XP beschreibt zentrale Werte und Prinzipien, die auf den konkreten Kontext angewendet werden müssen
        \item Agile Teams müssen ihre Arbeit kontinuierlich reflektieren
        \item XP erscheint auf den ersten Blick weniger formal als traditionelle Methoden, erfordert aber eine hohe Disziplin
    \end{itemize}
\end{formula}

\begin{KR}{Test-Driven Development (TDD) in der Praxis}\\
    \paragraph{Vorbereitung}
    \begin{itemize}
        \item Verstehen der Anforderung
        \item Identifizieren der zu testenden Funktionalität
        \item Testumgebung einrichten
    \end{itemize}
    
    \paragraph{TDD-Zyklus (Red-Green-Refactor)}
    \begin{itemize}
        \item \textbf{Red:} Schreibe einen Test, der fehlschlägt
        \item \textbf{Green:} Implementiere den einfachsten Code, der den Test bestehen lässt
        \item \textbf{Refactor:} Verbessere den Code, ohne die Funktionalität zu ändern
    \end{itemize}
    
    \paragraph{Fortgeschrittene Anwendung}
    \begin{itemize}
        \item Tests als Dokumentation verwenden
        \item Testabdeckung überwachen
        \item Testsuiten automatisiert ausführen
        \item Integration in CI/CD-Pipeline
    \end{itemize}
\end{KR}

\begin{examplecode}{TDD-Beispiel: Einfache Additionsfunktion}\\
\begin{lstlisting}[language=Java, style=basesmol]
// 1. Test schreiben (Red)
@Test
public void testAddition() {
    Calculator calc = new Calculator();
    assertEquals(5, calc.add(2, 3));
}

// 2. Implementierung (Green)
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

// 3. Refactoring (falls noetig)
// In diesem einfachen Beispiel ist kein Refactoring noetig
\end{lstlisting}
\end{examplecode}