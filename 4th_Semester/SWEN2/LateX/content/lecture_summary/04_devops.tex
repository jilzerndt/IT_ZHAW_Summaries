\section{DevOps}

\subsection{Einführung in DevOps}

\begin{definition}{DevOps}\\
    DevOps ist eine Methodik, die darauf abzielt, die Lücke zwischen Entwicklung (Dev) und Betrieb (Ops) zu schließen:
    \begin{itemize}
        \item Kombination aus Menschen, Prozessen, Produkten und Technologien
        \item Ziel: Schnellere und bessere Software-Lieferung durch Integration vormals getrennter Teams
        \item Erweiterung agiler Praktiken mit Betriebs- und Automatisierungselementen
        \item Kontinuierliche Überwachung von Anwendungen im Betrieb
    \end{itemize}
\end{definition}

\begin{concept}{Die Entwicklung von DevOps}\\
    Die Rolle der IT hat sich dramatisch verändert:
    \begin{itemize}
        \item 1960/70er: Großrechner - IT-Systeme beschleunigen bestehende Prozesse
        \item 1980er: PC-Revolution - Office-Pakete, "Schatten-IT"
        \item 1990/2000er: Internet - IT als Wettbewerbsvorteil
        \item Heute: Mobilgeräte, Cloud, KI - "Technologie wird zum Geschäft"
        \item Agile Entwicklungsteams und Betriebsteams benötigen die gleichen Prioritäten → Entstehung von DevOps
    \end{itemize}
\end{concept}

\begin{concept}{Von Silos zu gemeinsamen Arbeitsabläufen}\\
    Traditionelles Modell (ca. 2000er Jahre):
    \begin{itemize}
        \item Entwickler schrieben Code, verpackten die Anwendung mit Dokumentation und übergaben sie an QA
        \item QA testete die Anwendung und übergab sie an das Produktionsteam
        \item Das Betriebsteam stellte die Software bereit und verwaltete sie - mit wenig direkter Interaktion mit den Entwicklern
        \item Das Sicherheitsteam überprüfte den Code erst nach dem Deployment
        \item Bei Problemen begann der Prozess von vorn
    \end{itemize}
    Dieser lineare Ansatz war langsam und frustrierend für alle Beteiligten.
\end{concept}

\begin{concept}{Unterschiedliche Perspektiven zusammenbringen}\\
    \begin{itemize}
        \item \textbf{Entwicklung:} Betrachtet eine Anwendung von innen nach außen, definiert durch die Struktur der Anforderungen
        \item \textbf{Betrieb:} Betrachtet eine Anwendung von außen nach innen, als ein weiteres zu verwaltendes Element, definiert durch die Struktur der Betriebsumgebung
        \item DevOps vereint diese Perspektiven in einer gemeinsamen, kollaborativen Sichtweise
    \end{itemize}
\end{concept}

\subsection{Der DevOps-Lebenszyklus}

\begin{concept}{Die vier Phasen des DevOps-Lebenszyklus}\\
    \begin{enumerate}
        \item \textbf{Die Idee:} Teams sammeln Anforderungen und Feedback und beginnen, die benötigten Ressourcen zu skizzieren. Stack: GitHub Issues und Project Boards.
        
        \item \textbf{Aufbauen:} Hier erwacht DevOps zum Leben. Mit Versionskontrolle und Cloud-basierten Entwicklungsumgebungen können Entwickler kontinuierlich Änderungen vornehmen und den Code gemeinsam in Echtzeit überprüfen. Auch die kontinuierliche Integration (CI) kommt zum Einsatz. Stack: GitHub Codespaces, GitHub Actions.
        
        \item \textbf{Ausliefern:} Nach erfolgreichen Tests verwenden Teams Tools für kontinuierliche Bereitstellung (CD), um Codeänderungen automatisch in eine Testumgebung zu übertragen. Stack: CD-Pipelines mit GitHub Actions, GitHub Packages, Azure.
        
        \item \textbf{Lernen:} Die Betriebsteams überwachen Releases mit Tools, die die Leistung messen und die Auswirkungen von Codeänderungen verfolgen. Sie sorgen für Stabilität, sammeln Kundenfeedback und kommunizieren eng mit den Entwicklern. Stack: Monitoring-Tools wie New Relic, Splunk, etc.
    \end{enumerate}
\end{concept}

\begin{concept}{DevOps als Erweiterung von Agile}\\
    DevOps wendet agile Prinzipien auf den Betrieb an:
    \begin{itemize}
        \item Kontinuierliche Lieferung entspricht dem agilen Grundsatz: "Unsere höchste Priorität ist es, den Kunden durch frühzeitige und kontinuierliche Bereitstellung wertvoller Software zufriedenzustellen"
        \item DevOps bringt die agile Einstellung zum Wandel dem IT-Betrieb näher
        \item Agile und DevOps sind nicht gegensätzlich, sondern ergänzen sich
    \end{itemize}
\end{concept}

\subsection{DevOps-Metriken und Erfolg}

\begin{definition}{DORA-Metriken}\\
    DevOps Research and Assessment (DORA) bietet einen Standardsatz von Metriken zur Bewertung von DevOps-Erfolg:
    \begin{enumerate}
        \item \textbf{Bereitstellungshäufigkeit:} Durchschnittliche Anzahl der täglichen Codebereitstellungen in einer bestimmten Umgebung
        \item \textbf{Vorlaufzeit für Änderungen:} Die Zeitspanne zwischen Annahme und Bereitstellung einer Änderung
        \item \textbf{Zeit bis zur Wiederherstellung der Dienste:} Wie lange es dauert, den Dienst nach einem Fehler wiederherzustellen
        \item \textbf{Fehlerquote bei Änderungen:} Wie häufig Implementierungen fehlschlagen
    \end{enumerate}
\end{definition}

\begin{concept}{Leistungsklassen nach DORA}\\
    Teams werden anhand ihrer DORA-Metriken klassifiziert:
    \begin{itemize}
        \item \textbf{Elite Performer:} Mehrere Deployments pro Tag, Vorlaufzeit < 1 Stunde, Wiederherstellungszeit < 1 Stunde, Fehlerrate < 5\%
        \item \textbf{High Performer:} Zwischen einmal pro Tag und einmal pro Woche, Vorlaufzeit zwischen einem Tag und einer Woche
        \item \textbf{Medium Performer:} Zwischen einmal pro Woche und einmal pro Monat
        \item \textbf{Low Performer:} Weniger als einmal pro Monat, Vorlaufzeit > 6 Monate
    \end{itemize}
\end{concept}

\subsection{Software-Automatisierung}

\begin{definition}{Arten der Software-Automatisierung}\\
    Eine Vielzahl von Aufgaben der Softwareentwicklung können automatisiert werden:
    \begin{itemize}
        \item \textbf{On-Demand:} Ein Skript ausführen oder eine Taste drücken
        \item \textbf{Scheduled:} Zu bestimmten Zeiten (z.B. nächtliche Builds)
        \item \textbf{Triggered:} Bei bestimmten Ereignissen (z.B. Git commit/push)
    \end{itemize}
\end{definition}

\begin{concept}{Typen der Automatisierung}\\
    \begin{itemize}
        \item \textbf{Build Automation:} Kompilieren, Software-Paketierung, Erstellen von Dokumentation
        \item \textbf{Test Automation:} Automatisierte Unit-, Integration- und Akzeptanztests
        \item \textbf{Deployment Automation:} Automatisiertes Deployment in verschiedene Umgebungen
        \item \textbf{Operation Automation:} Infrastruktur-Provisionierung, Monitoring, Skalierung
    \end{itemize}
\end{concept}

\begin{concept}{Warum Automatisierung wichtig ist}\\
    Probleme ohne Automatisierung:
    \begin{itemize}
        \item "Es läuft auf meinem Computer!" - Probleme bei der lokalen Entwicklung
        \item Inkonsistente Versionierung
        \item Unregelmäßige Unit-Tests
        \item Unklarer Build-Status
        \item Undefinierte Abhängigkeiten
        \item Intransparentes Deployment
        \item Fehleranfälligkeit bei manueller Arbeit
        \item Langweilige Wiederholungsarbeit
    \end{itemize}
\end{concept}

\begin{concept}{Ziele der Automatisierung}\\
    \begin{itemize}
        \item \textbf{Produktqualität verbessern:} Automatisierte Tests, Code-Auditing, dokumentierte Build-Historie
        \item \textbf{Markteinführungszeit verkürzen:} Schnellere Prozesse, unmittelbares Feedback, kürzere Innovationszyklen
        \item \textbf{Risiken minimieren:} Fortschritt nachweisen, fehlerhafte Builds frühzeitig finden, Abhängigkeiten von Schlüsselpersonen reduzieren
    \end{itemize}
\end{concept}

\subsection{Software Automation Pipeline: CI/CD}

\begin{concept}{Software Automation Pipeline}\\
    Automatisierung kann in jeder Phase des Softwareprozesses eingesetzt werden:
    \begin{itemize}
        \item Jeder Schritt kann nur fortgesetzt werden, wenn er mehrere Tests erfolgreich durchläuft
        \item Bei Fehlern werden die Verantwortlichen sofort informiert
        \item Der Prozess enthält Feedback-Schleifen für kontinuierliche Verbesserung
    \end{itemize}
\end{concept}

\begin{definition}{Stufen der Automatisierung}\\
    Je nach Automatisierungsgrad unterscheidet man:
    \begin{itemize}
        \item \textbf{Build Automation:} Entwicklung einzelner Komponenten und Unit-Tests, typischerweise lokal ausgeführt
        \item \textbf{Continuous Integration (CI):} Automatisierte Entwicklung, Testen und Integration von Komponenten sowie Integrationstests, typischerweise auf dem CI-Server
        \item \textbf{Continuous Delivery (CD):} Erzeugt auch Releases, deployt in die Staging-Umgebung und führt automatische Akzeptanztests aus; bereit für die Produktion, aber manueller Schritt für das Deployment
        \item \textbf{Continuous Deployment:} Automatisches Deployment in die Produktion nach erfolgreichen Akzeptanztests
        \item \textbf{DevOps:} Automatischer Betrieb des Produktionssystems (Konfigurationsmanagement, Infrastrukturbereitstellung, Backup, Monitoring, etc.)
    \end{itemize}
\end{definition}

\subsection{Continuous Integration}

\begin{concept}{Zentrale Praktiken der Continuous Integration}\\
    \begin{itemize}
        \item \textbf{Versionskontrolle:} Alles in einem versionskontrollierten Main-Branch (Trunk oder Main) ablegen
        \item \textbf{Automatisierte Builds:} Build-Prozess automatisieren und selbsttestend gestalten
        \item \textbf{Häufige Integration:} Jeder pusht Commits täglich in den Main-Branch
        \item \textbf{Schnelle Fehlerbehebung:} Fehlerhafte Builds sofort beheben
        \item \textbf{Kurze Build-Zeiten:} Builds unter 10 Minuten halten
    \end{itemize}
\end{concept}

\begin{KR}{Feature Flags für unfertige Funktionen}\\
    \paragraph{Problem}
    Wie integriert man Code für unfertige Features, die noch nicht für Benutzer sichtbar sein sollen?
    
    \paragraph{Lösung: Feature Flags}
    \begin{itemize}
        \item Feature Flags sind Konfigurationsoptionen, die bestimmte Funktionen aktivieren oder deaktivieren
        \item Sie ermöglichen es, unfertigen Code in den Hauptzweig zu integrieren, ohne ihn den Benutzern zu zeigen
        \item Der Code wird erst aktiviert, wenn das Feature fertig ist
    \end{itemize}
    
    \paragraph{Implementierung}
    \begin{itemize}
        \item Einfaches Boolean-Flag für An/Aus-Entscheidungen
        \item Konfigurierbar pro Umgebung (Entwicklung, Test, Produktion)
        \item Kann auch für A/B-Tests oder schrittweise Einführung verwendet werden
    \end{itemize}
\end{KR}

\begin{examplecode}{Feature Flag Implementierung}\\
\begin{lstlisting}[language=JavaScript, style=basesmol]
// Feature Flag Konfiguration
const featureFlags = {
  newUserInterface: false,
  advancedSearch: true,
  darkMode: true
};

// Verwendung im Code
function renderUserInterface() {
  if (featureFlags.newUserInterface) {
    // Neues UI rendern
    renderNewUI();
  } else {
    // Altes UI rendern
    renderLegacyUI();
  }
}

// Feature je nach Umgebung aktivieren
if (process.env.ENVIRONMENT === 'development') {
  featureFlags.newUserInterface = true;
}
\end{lstlisting}
\end{examplecode}

\subsection{Kontinuierliches Deployment}

\begin{concept}{Deployment-Strategien}\\
    \begin{itemize}
        \item \textbf{Blue/Green Deployment:} Zwei identische Produktionsumgebungen (Blue und Green), wobei nur eine aktiv ist. Nach dem Deployment auf die inaktive Umgebung wird der Traffic umgeleitet.
        
        \item \textbf{Canary Deployment:} Neue Version wird nur für einen kleinen Teil der Benutzer bereitgestellt, um Probleme früh zu erkennen, bevor die Version vollständig ausgerollt wird.
        
        \item \textbf{A/B-Testing:} Ähnlich wie Canary, aber mit Fokus auf Benutzerreaktionen statt technischer Probleme.
    \end{itemize}
\end{concept}

\begin{concept}{Automatisches Rollback}\\
    \begin{itemize}
        \item Bei Problemen im Deployment ist schnelles Rollback entscheidend
        \item Automated Rollback: Automatische Rückkehr zur letzten bekannten guten Version
        \item Monitoring-Systeme können Alarme auslösen, die ein Rollback initiieren
        \item Feature Flags ermöglichen ein schnelles "Ausschalten" problematischer Funktionen
    \end{itemize}
\end{concept}

\subsection{Virtuelle Umgebungen}

\begin{concept}{Virtualisierung und Containerisierung}\\
    \begin{itemize}
        \item \textbf{Virtualisierung:} Technologien zur Erstellung virtueller Versionen physischer Ressourcen; eine VM enthält ein vollständiges Betriebssystem
        
        \item \textbf{Containerisierung:} Leichtgewichtige Isolierung von Anwendungen; Container teilen sich das Betriebssystem des Hosts und enthalten nur die Anwendung und ihre Abhängigkeiten
        
        \item \textbf{Docker:} Populäres Tool für Containerisierung
        
        \item \textbf{Kubernetes:} System zur Orchestrierung und Verwaltung von Containern
    \end{itemize}
\end{concept}

\begin{concept}{Infrastructure as Code (IaC)}\\
    \begin{itemize}
        \item Verwaltung und Bereitstellung von IT-Infrastrukturen mithilfe von Code statt manueller Konfiguration
        \item Infrastrukturdateien werden in Versionskontrollsystemen gespeichert
        \item Ermöglicht reproduzierbare, konsistente Umgebungen
        \item Entwickler werden stärker in die Konfiguration einbezogen
        \item Ops-Teams werden früher in den Entwicklungsprozess einbezogen
        \item Populäre Tools: Terraform, AWS CloudFormation, Ansible
    \end{itemize}
\end{concept}

\begin{concept}{Microservices-Architektur}\\
    \begin{itemize}
        \item Zerlegt eine monolithische Anwendung in lose gekoppelte Dienste
        \item Jeder Dienst konzentriert sich auf eine Geschäftsfähigkeit
        \item Kommunikation über definierte APIs (meist RESTful)
        \item Vorteile: unabhängige Entwicklung und Skalierung, technologische Flexibilität
        \item Herausforderungen: Komplexität der Verteilung, Service Discovery, Fehlertoleranz
    \end{itemize}
\end{concept}

\subsection{GitHub Actions und CI/CD}

\begin{concept}{GitHub Actions}\\
    GitHub Actions ist eine CI/CD-Plattform, mit der man Build-, Test- und Deployment-Pipelines automatisieren kann:
    \begin{itemize}
        \item \textbf{Workflows:} YAML-Dateien, die die Pipeline definieren
        \item \textbf{Events:} Auslöser wie Push, Pull Request oder zeitgesteuerte Ereignisse
        \item \textbf{Jobs:} Aufgaben, die auf Runnern ausgeführt werden
        \item \textbf{Actions:} Wiederverwendbare Bausteine für Workflows
        \item \textbf{Runners:} Server, die die Jobs ausführen
    \end{itemize}
\end{concept}

\begin{examplecode}{Einfacher GitHub Actions Workflow} Language = YAML\\
\begin{lstlisting}[style=basesmol]
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm test
      
    - name: Build
      run: npm run build
\end{lstlisting}
\end{examplecode}

\subsection{Zusammenfassung}

\begin{formula}{DevOps Vorteile}\\
    DevOps bietet zahlreiche Vorteile gegenüber traditionellen Entwicklungsansätzen:
    \begin{itemize}
        \item Schnellere Markteinführung durch automatisierte Prozesse
        \item Höhere Softwarequalität durch frühe und kontinuierliche Tests
        \item Verbesserte Zusammenarbeit zwischen Entwicklung und Betrieb
        \item Geringere Fehlerrate bei Deployments
        \item Schnellere Erholung von Ausfällen
        \item Kontinuierliche Verbesserung durch Feedback-Schleifen
        \item Erhöhte Skalierbarkeit und Zuverlässigkeit von Systemen
    \end{itemize}
\end{formula}