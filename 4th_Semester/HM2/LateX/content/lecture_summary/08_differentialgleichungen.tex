\section{Einführung in gewöhnliche Differentialgleichungen}

\subsection{Problemstellung}

\begin{definition}{Gewöhnliche Differentialgleichung n-ter Ordnung}\\
Eine Gleichung, in der Ableitungen einer unbekannten Funktion $y = y(x)$ bis zur $n$-ten Ordnung auftreten, heißt eine gewöhnliche Differentialgleichung $n$-ter Ordnung. Sie hat die explizite Form:
$$y^{(n)}(x) = f\left(x, y(x), y'(x), ..., y^{(n-1)}(x)\right)$$

Gesucht sind die Lösungen $y = y(x)$ dieser Gleichung, wobei die Lösungen $y$ auf einem Intervall $[a,b]$ definiert sein sollen.

\textbf{Notationen für Ableitungen:}
\begin{itemize}
    \item \textbf{Lagrange:} $y'(x), y''(x), y'''(x), y^{(4)}(x), ..., y^{(n)}(x)$
    \item \textbf{Newton:} $\dot{y}(x), \ddot{y}(x), \dddot{y}(x), ...$
    \item \textbf{Leibniz:} $\frac{dy}{dx}, \frac{d^2y}{dx^2}, \frac{d^3y}{dx^3}, ..., \frac{d^ny}{dx^n}$
\end{itemize}
\end{definition}

\begin{definition}{Anfangswertproblem (AWP)}\\
Bei einem Anfangswertproblem für eine Differentialgleichung $n$-ter Ordnung werden der Lösungsfunktion $y = y(x)$ noch $n$ Werte vorgeschrieben:

\textbf{DGL 1. Ordnung:} Gegeben ist $y'(x) = f(x, y(x))$ und der Anfangswert $y(x_0) = y_0$.

\textbf{DGL 2. Ordnung:} Gegeben ist $y''(x) = f(x, y(x), y'(x))$ und die Anfangswerte $y(x_0) = y_0$, $y'(x_0) = y_0'$.
\end{definition}

\begin{example2}{Beispiele aus den Naturwissenschaften}\\
\textbf{Aufgabe:} Klassifizieren Sie die folgenden DGL und geben Sie physikalische Interpretationen an.
\tcblower
\textbf{Lösung:}

\textbf{1. Radioaktiver Zerfall:}
$$\frac{dn}{dt} = -\lambda n$$
DGL 1. Ordnung, Lösung: $n(t) = n_0 e^{-\lambda t}$

\textbf{2. Freier Fall:}
$$\ddot{s}(t) = -g$$
DGL 2. Ordnung, Lösung: $s(t) = -\frac{1}{2}gt^2 + v_0 t + s_0$

\textbf{3. Harmonische Schwingung (Federpendel):}
$$m\ddot{x} = -cx \Rightarrow \ddot{x} + \frac{c}{m}x = 0$$
DGL 2. Ordnung, Lösung: $x(t) = A \sin(\omega_0 t + \varphi)$ mit $\omega_0 = \sqrt{\frac{c}{m}}$
\end{example2}

\subsection{Richtungsfelder}

\begin{concept}{Geometrische Interpretation}\\
Die DGL $y'(x) = f(x, y(x))$ gibt uns einen Zusammenhang zwischen der Steigung $y'(x)$ der gesuchten Funktion und dem Punkt $(x, y(x))$.

Im Richtungsfeld wird an jedem Punkt $(x,y)$ die Steigung $y'(x) = f(x,y)$ durch einen kleinen Pfeil dargestellt. Die Lösungskurven verlaufen stets tangential zu diesen Pfeilen.
\end{concept}

\begin{KR}{Richtungsfeld zeichnen und interpretieren}\\
\paragraph{Schritt 1: Steigungen berechnen}
Für eine gegebene DGL $y' = f(x,y)$ berechne für verschiedene Punkte $(x_i, y_j)$ die Steigung $f(x_i, y_j)$.

\paragraph{Schritt 2: Richtungspfeile einzeichnen}
Zeichne an jedem Punkt $(x_i, y_j)$ einen kleinen Pfeil mit der Steigung $f(x_i, y_j)$.

\paragraph{Schritt 3: Lösungskurven folgen}
Von einem Anfangspunkt $(x_0, y_0)$ ausgehend folge den Richtungspfeilen, um die Lösungskurve zu approximieren.

\paragraph{Schritt 4: Python-Implementierung}
Verwende \texttt{numpy.meshgrid()} und \texttt{pyplot.quiver()} zur automatischen Darstellung.
\end{KR}

\begin{example2}{Richtungsfeld interpretieren}\\
\textbf{Aufgabe:} Zeichnen Sie das Richtungsfeld für $\frac{dy}{dt} = -\frac{1}{2} \cdot y \cdot t^2$ und bestimmen Sie die Lösungskurve für $y(0) = 3$.
\tcblower
\textbf{Lösung:}

\textbf{Steigungen an ausgewählten Punkten:}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
$\frac{dy}{dt}$ & $t=0$ & $t=1$ & $t=2$ & $t=3$ \\
\hline
$y=0$ & 0 & 0 & 0 & 0 \\
\hline
$y=1$ & 0 & -0.5 & -2 & -4.5 \\
\hline
$y=2$ & 0 & -1 & -4 & -9 \\
\hline
$y=3$ & 0 & -1.5 & -6 & -13.5 \\
\hline
\end{tabular}
\end{center}

Die Lösungskurve für $y(0) = 3$ folgt den Richtungspfeilen und zeigt exponentiellen Abfall für $t > 0$.
\end{example2}

\subsection{Numerische Lösungsverfahren}

\subsubsection{Das Euler-Verfahren}

\begin{theorem}{Klassisches Euler-Verfahren}\\
Gegeben sei das AWP $y' = f(x,y)$ mit $y(a) = y_0$ auf dem Intervall $[a,b]$.

Das Euler-Verfahren mit Schrittweite $h = \frac{b-a}{n}$ lautet:
$$x_{i+1} = x_i + h$$
$$y_{i+1} = y_i + h \cdot f(x_i, y_i)$$

wobei $x_0 = a$, $x_i = a + ih$ für $i = 0, ..., n-1$ und $y_0$ der gegebene Anfangswert ist.
\end{theorem}

\begin{concept}{Idee des Euler-Verfahrens}\\
Das Euler-Verfahren folgt der Tangente im Punkt $(x_i, y_i)$ mit der Steigung $f(x_i, y_i)$ um die Schrittweite $h$. Es ist das einfachste Einschrittverfahren mit Konvergenzordnung $p = 1$.
\end{concept}

\begin{KR}{Euler-Verfahren anwenden}\\
\paragraph{Schritt 1: Parameter bestimmen}
Gegeben: AWP $y' = f(x,y)$, $y(a) = y_0$, Intervall $[a,b]$, Anzahl Schritte $n$
Berechne: $h = \frac{b-a}{n}$

\paragraph{Schritt 2: Startwerte setzen}
$x_0 = a$, $y_0 = $ gegebener Anfangswert

\paragraph{Schritt 3: Iteration}
Für $i = 0, 1, ..., n-1$:
\begin{itemize}
    \item Berechne $f(x_i, y_i)$
    \item Setze $x_{i+1} = x_i + h$
    \item Setze $y_{i+1} = y_i + h \cdot f(x_i, y_i)$
\end{itemize}

\paragraph{Schritt 4: Lösung interpretieren}
Die Punkte $(x_i, y_i)$ approximieren die Lösung $y(x)$ an den Stützstellen.
\end{KR}

\begin{example2}{Euler-Verfahren berechnen}\\
\textbf{Aufgabe:} Lösen Sie $\frac{dy}{dx} = \frac{x^2}{y}$ mit $y(0) = 2$ auf dem Intervall $[0, 1.4]$ mit $h = 0.7$ (Euler-Verfahren).
\tcblower
\textbf{Lösung:}

\textbf{Parameter:} $n = 2$, $h = 0.7$, $f(x,y) = \frac{x^2}{y}$

\textbf{Iteration:}
\begin{itemize}
    \item $i = 0$: $x_0 = 0$, $y_0 = 2$
    \item $f(0, 2) = \frac{0^2}{2} = 0$
    \item $x_1 = 0 + 0.7 = 0.7$, $y_1 = 2 + 0.7 \cdot 0 = 2$
\end{itemize}

\begin{itemize}
    \item $i = 1$: $x_1 = 0.7$, $y_1 = 2$
    \item $f(0.7, 2) = \frac{0.7^2}{2} = 0.245$
    \item $x_2 = 0.7 + 0.7 = 1.4$, $y_2 = 2 + 0.7 \cdot 0.245 = 2.1715$
\end{itemize}

\textbf{Exakte Lösung:} $y(x) = \sqrt{\frac{2x^3}{3} + 4}$
$y(1.4) = \sqrt{\frac{2 \cdot 1.4^3}{3} + 4} = 2.253$

\textbf{Absoluter Fehler:} $|2.253 - 2.1715| = 0.0815$
\end{example2}

\subsubsection{Verbesserte Euler-Verfahren}

\begin{theorem}{Mittelpunkt-Verfahren}\\
Das Mittelpunkt-Verfahren berechnet die Steigung in der Mitte des Intervalls:
$$x_{h/2} = x_i + \frac{h}{2}$$
$$y_{h/2} = y_i + \frac{h}{2} \cdot f(x_i, y_i)$$
$$x_{i+1} = x_i + h$$
$$y_{i+1} = y_i + h \cdot f(x_{h/2}, y_{h/2})$$

Konvergenzordnung: $p = 2$
\end{theorem}

\begin{theorem}{Modifiziertes Euler-Verfahren (Heun-Verfahren)}\\
Das modifizierte Euler-Verfahren verwendet den Durchschnitt zweier Steigungen:
$$k_1 = f(x_i, y_i)$$
$$k_2 = f(x_i + h, y_i + h \cdot k_1)$$
$$x_{i+1} = x_i + h$$
$$y_{i+1} = y_i + h \cdot \frac{k_1 + k_2}{2}$$

Konvergenzordnung: $p = 2$
\end{theorem}

\begin{example2}{Vergleich der Euler-Verfahren}\\
\textbf{Aufgabe:} Lösen Sie das AWP aus dem vorigen Beispiel mit Mittelpunkt- und modifiziertem Euler-Verfahren. Vergleichen Sie die Genauigkeit.
\tcblower
\textbf{Lösung:}

\textbf{Mittelpunkt-Verfahren:}
\begin{itemize}
    \item $x_{1/2} = 0.35$, $y_{1/2} = 2$, $f(0.35, 2) = 0.061$
    \item $y_1 = 2 + 0.7 \cdot 0.061 = 2.043$
    \item $x_{3/2} = 1.05$, $y_{3/2} = 2.128$, $f(1.05, 2.128) = 0.518$
    \item $y_2 = 2.043 + 0.7 \cdot 0.518 = 2.406$
\end{itemize}

\textbf{Modifiziertes Euler-Verfahren:}
\begin{itemize}
    \item $k_1 = 0$, $k_2 = f(0.7, 2) = 0.245$
    \item $y_1 = 2 + 0.7 \cdot \frac{0 + 0.245}{2} = 2.086$
    \item $k_1 = 0.245$, $k_2 = f(1.4, 2.257) = 0.866$
    \item $y_2 = 2.086 + 0.7 \cdot \frac{0.245 + 0.866}{2} = 2.475$
\end{itemize}

\textbf{Fehlervergleich bei $x = 1.4$:}
\begin{itemize}
    \item Exakt: $y(1.4) = 2.253$
    \item Euler: $|2.253 - 2.172| = 0.081$
    \item Mittelpunkt: $|2.253 - 2.406| = 0.153$
    \item Modifiziert: $|2.253 - 2.475| = 0.222$
\end{itemize}
\end{example2}

\subsubsection{Runge-Kutta Verfahren}

\begin{theorem}{Klassisches vierstufiges Runge-Kutta Verfahren}\\
Das klassische Runge-Kutta Verfahren verwendet vier Steigungen und hat Konvergenzordnung $p = 4$:

$$k_1 = f(x_i, y_i)$$
$$k_2 = f\left(x_i + \frac{h}{2}, y_i + \frac{h}{2} k_1\right)$$
$$k_3 = f\left(x_i + \frac{h}{2}, y_i + \frac{h}{2} k_2\right)$$
$$k_4 = f(x_i + h, y_i + h k_3)$$
$$x_{i+1} = x_i + h$$
$$y_{i+1} = y_i + h \cdot \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$
\end{theorem}

\begin{concept}{Butcher-Schema}\\
Runge-Kutta Verfahren werden durch Butcher-Schemata charakterisiert:
\begin{center}
\begin{tabular}{c|cccc}
0 & & & & \\
$\frac{1}{2}$ & $\frac{1}{2}$ & & & \\
$\frac{1}{2}$ & 0 & $\frac{1}{2}$ & & \\
1 & 0 & 0 & 1 & \\
\hline
& $\frac{1}{6}$ & $\frac{1}{3}$ & $\frac{1}{3}$ & $\frac{1}{6}$
\end{tabular}
\end{center}
\end{concept}

\begin{KR}{Runge-Kutta Verfahren anwenden}\\
\paragraph{Schritt 1: Steigungen berechnen}
$$k_1 = f(x_i, y_i)$$
$$k_2 = f\left(x_i + \frac{h}{2}, y_i + \frac{h}{2} k_1\right)$$
$$k_3 = f\left(x_i + \frac{h}{2}, y_i + \frac{h}{2} k_2\right)$$
$$k_4 = f(x_i + h, y_i + h k_3)$$

\paragraph{Schritt 2: Gewichtetes Mittel bilden}
$$\text{Steigung} = \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$

\paragraph{Schritt 3: Nächsten Punkt berechnen}
$$x_{i+1} = x_i + h$$
$$y_{i+1} = y_i + h \cdot \text{Steigung}$$

\paragraph{Schritt 4: Iteration fortsetzen}
Wiederhole bis zum Ende des Intervalls.
\end{KR}

\begin{example2}{Runge-Kutta vs. andere Verfahren}\\
\textbf{Aufgabe:} Lösen Sie $y' = 1 - \frac{y}{t}$ mit $y(1) = 5$ für $t \in [1,6]$ mit $h = 0.01$ und vergleichen Sie mit der exakten Lösung $y(t) = \frac{t^2 + 9}{2t}$.
\tcblower
\textbf{Lösung:}

\textbf{Implementierung in Python:}
\begin{lstlisting}[language=Python, style=basesmol]
def runge_kutta_4(f, a, b, n, y0):
    h = (b - a) / n
    x = a
    y = y0
    
    for i in range(n):
        k1 = f(x, y)
        k2 = f(x + h/2, y + h/2 * k1)
        k3 = f(x + h/2, y + h/2 * k2)
        k4 = f(x + h, y + h * k3)
        
        x += h
        y += h * (k1 + 2*k2 + 2*k3 + k4) / 6
        
    return x, y
\end{lstlisting}

\textbf{Fehlervergleich bei $t = 6$:}
\begin{itemize}
    \item Exakt: $y(6) = 3.25$
    \item Euler: Fehler $\approx 0.1$
    \item Runge-Kutta: Fehler $\approx 10^{-6}$
\end{itemize}
\end{example2}

\subsection{Systeme von Differentialgleichungen}

\begin{concept}{DGL höherer Ordnung $\rightarrow$ System 1. Ordnung}\\
Jede DGL $n$-ter Ordnung kann in ein System von $n$ DGL 1. Ordnung umgewandelt werden durch Einführung von Hilfsvariablen für die Ableitungen.
\end{concept}

\begin{KR}{DGL höherer Ordnung auf System 1. Ordnung zurückführen}\\
\paragraph{Schritt 1: Nach höchster Ableitung auflösen}
Bringe die DGL in die Form $y^{(n)} = f(x, y, y', ..., y^{(n-1)})$.

\paragraph{Schritt 2: Hilfsvariablen einführen}
$$z_1(x) = y(x)$$
$$z_2(x) = y'(x)$$
$$z_3(x) = y''(x)$$
$$\vdots$$
$$z_n(x) = y^{(n-1)}(x)$$

\paragraph{Schritt 3: System aufstellen}
$$z_1' = z_2$$
$$z_2' = z_3$$
$$\vdots$$
$$z_{n-1}' = z_n$$
$$z_n' = f(x, z_1, z_2, ..., z_n)$$

\paragraph{Schritt 4: Vektorielle Schreibweise}
$$\mathbf{z}' = \mathbf{f}(x, \mathbf{z})$$ mit $\mathbf{z}(x_0) = \begin{psmallmatrix} y(x_0) \\ y'(x_0) \\ \vdots \\ y^{(n-1)}(x_0) \end{psmallmatrix}$
\end{KR}

\begin{example2}{Landende Boeing - DGL 2. Ordnung}\\
\textbf{Aufgabe:} Eine Boeing 737-200 landet mit $v_0 = 100$ m/s und erfährt die Bremskraft $F = -5\dot{x}^2 - 570000$. Die Bewegungsgleichung ist:
$$m\ddot{x} = -5\dot{x}^2 - 570000$$
mit $m = 97000$ kg. Formen Sie in ein System 1. Ordnung um.
\tcblower
\textbf{Lösung:}

\textbf{Schritt 1:} Nach $\ddot{x}$ auflösen:
$$\ddot{x} = \frac{-5\dot{x}^2 - 570000}{97000}$$

\textbf{Schritt 2:} Hilfsvariablen:
$$z_1(t) = x(t) \quad \text{(Position)}$$
$$z_2(t) = \dot{x}(t) = v(t) \quad \text{(Geschwindigkeit)}$$

\textbf{Schritt 3:} System 1. Ordnung:
$$z_1' = z_2$$
$$z_2' = \frac{-5z_2^2 - 570000}{97000}$$

\textbf{Schritt 4:} Anfangsbedingungen:
$$\mathbf{z}(0) = \begin{psmallmatrix} 0 \\ 100 \end{psmallmatrix}$$

Das System kann nun mit Runge-Kutta gelöst werden.
\end{example2}

\begin{example2}{Raketenbewegung}\\
\textbf{Aufgabe:} Die Bewegungsgleichung einer Rakete lautet:
$$a(t) = \ddot{h}(t) = v_{rel} \cdot \frac{\mu}{m_A - \mu \cdot t} - g$$

mit $v_{rel} = 2600$ m/s, $m_A = 300000$ kg, $m_E = 80000$ kg, $t_E = 190$ s.

Berechnen Sie Geschwindigkeit und Höhe als Funktion der Zeit.
\tcblower
\textbf{Lösung:}

\textbf{Parameter:} $\mu = \frac{m_A - m_E}{t_E} = \frac{220000}{190} = 1158$ kg/s

\textbf{System 1. Ordnung:}
$$z_1' = z_2 \quad \text{(Höhe)}$$
$$z_2' = 2600 \cdot \frac{1158}{300000 - 1158t} - 9.81 \quad \text{(Geschwindigkeit)}$$

\textbf{Anfangsbedingungen:} $z_1(0) = 0$, $z_2(0) = 0$

\textbf{Numerische Lösung mit Trapezregel:}
$$v(t) = \int_0^t a(\tau) d\tau$$
$$h(t) = \int_0^t v(\tau) d\tau$$

\textbf{Analytische Vergleichslösung:}
$$v(t) = v_{rel} \ln\left(\frac{m_A}{m_A - \mu t}\right) - gt$$
$$h(t) = -\frac{v_{rel}(m_A - \mu t)}{\mu} \ln\left(\frac{m_A}{m_A - \mu t}\right) + v_{rel} t - \frac{1}{2}gt^2$$

\textbf{Ergebnisse nach 190s:}
\begin{itemize}
    \item Geschwindigkeit: $\approx 2500$ m/s
    \item Höhe: $\approx 180$ km
    \item Beschleunigung: $\approx 2.5g$
\end{itemize}
\end{example2}

\subsection{Stabilität}

\begin{concept}{Stabilitätsproblem}\\
Bei der numerischen Lösung von DGL kann es vorkommen, dass der numerische Fehler unbeschränkt wächst, unabhängig von der Schrittweite $h$. Dies führt zu \textbf{instabilen} Lösungen.

Die Stabilität hängt ab von:
\begin{itemize}
    \item Dem verwendeten Verfahren
    \item Der Schrittweite $h$
    \item Dem spezifischen Anfangswertproblem
\end{itemize}
\end{concept}

\begin{definition}{Stabilitätsfunktion}\\
Für die DGL $y' = -\alpha y$ (mit $\alpha > 0$) kann die numerische Lösung in der Form
$$y_{i+1} = g(h\alpha) \cdot y_i$$
geschrieben werden. Die Funktion $g(z)$ heißt \textbf{Stabilitätsfunktion} des Verfahrens.

Das offene Intervall $z \in (0, \alpha)$, in dem $|g(z)| < 1$ gilt, bezeichnet man als \textbf{Stabilitätsintervall}.
\end{definition}

\begin{example2}{Stabilität des Euler-Verfahrens}\\
\textbf{Aufgabe:} Untersuchen Sie die Stabilität des Euler-Verfahrens für $y' = -2.5y$ mit $y(0) = 1$.
\tcblower
\textbf{Lösung:}

\textbf{Euler-Verfahren:} $y_{i+1} = y_i - h \cdot 2.5 y_i = y_i(1 - 2.5h)$

\textbf{Stabilitätsfunktion:} $g(z) = 1 - z$ mit $z = 2.5h$

\textbf{Stabilitätsbedingung:} $|1 - 2.5h| < 1$
$\Rightarrow 0 < 2.5h < 2 \Rightarrow 0 < h < 0.8$

\textbf{Verhalten:}
\begin{itemize}
    \item $h = 0.2$: Stabile Lösung (exponentieller Abfall)
    \item $h = 0.85$: Instabile Lösung (Oszillation mit wachsender Amplitude)
\end{itemize}

\textbf{Exakte Lösung:} $y(x) = e^{-2.5x}$ (streng monoton fallend)
\end{example2}

\begin{remark}
\textbf{Praktische Hinweise zur Stabilität:}
\begin{itemize}
    \item \textbf{Schrittweiten-Kontrolle:} Beginne mit kleiner Schrittweite und prüfe Konvergenz
    \item \textbf{Verfahrensvergleich:} Teste verschiedene Verfahren und vergleiche Ergebnisse
    \item \textbf{Analytische Kontrolle:} Vergleiche mit bekannten analytischen Lösungen
    \item \textbf{Steife DGL:} Verwende implizite Verfahren für steife Probleme
    \item \textbf{Python-Tools:} Nutze \texttt{scipy.integrate.solve\_ivp()} für robuste Implementierungen
\end{itemize}
\end{remark}

\subsection{Python-Implementierung}

\begin{code}{DGL-Löser in Python}\\
Standard-Bibliothek für DGL-Probleme:
\begin{lstlisting}[language=Python, style=basesmol]
from scipy.integrate import solve_ivp
import numpy as np
import matplotlib.pyplot as plt

def f(t, y):
    # DGL: y' = -2*y + sin(t)
    return -2*y + np.sin(t)

# Anfangswertproblem loesen
sol = solve_ivp(f, [0, 5], [1], dense_output=True)

# Losung plotten
t = np.linspace(0, 5, 100)
y = sol.sol(t)
plt.plot(t, y[0])
plt.xlabel('t')
plt.ylabel('y(t)')
plt.title('Numerische Loesung der DGL')
plt.show()
\end{lstlisting}

\textbf{Verfügbare Methoden:}
\begin{itemize}
    \item \texttt{'RK45'}: Runge-Kutta 5(4) (Standard)
    \item \texttt{'RK23'}: Runge-Kutta 3(2)
    \item \texttt{'DOP853'}: Runge-Kutta 8. Ordnung
    \item \texttt{'Radau'}: Implizites Runge-Kutta
    \item \texttt{'BDF'}: Backward Differentiation (für steife DGL)
    \item \texttt{'LSODA'}: Automatische Steifigkeits-Erkennung
\end{itemize}
\end{code}

\begin{KR}{Eigene DGL-Löser implementieren}\\
\paragraph{Schritt 1: Grundstruktur}
\begin{lstlisting}[language=Python, style=basesmol]
def runge_kutta_4(f, a, b, n, y0):
    h = (b - a) / n
    x = np.linspace(a, b, n+1)
    y = np.zeros(n+1)
    y[0] = y0
    
    for i in range(n):
        k1 = f(x[i], y[i])
        k2 = f(x[i] + h/2, y[i] + h/2 * k1)
        k3 = f(x[i] + h/2, y[i] + h/2 * k2)
        k4 = f(x[i] + h, y[i] + h * k3)
        
        y[i+1] = y[i] + h/6 * (k1 + 2*k2 + 2*k3 + k4)
    
    return x, y
\end{lstlisting}

\paragraph{Schritt 2: Für Systeme erweitern}
\begin{lstlisting}[language=Python, style=basesmol]
def runge_kutta_system(f, a, b, n, y0):
    h = (b - a) / n
    x = np.linspace(a, b, n+1)
    y = np.zeros((n+1, len(y0)))
    y[0] = y0
    
    for i in range(n):
        k1 = f(x[i], y[i])
        k2 = f(x[i] + h/2, y[i] + h/2 * k1)
        k3 = f(x[i] + h/2, y[i] + h/2 * k2)
        k4 = f(x[i] + h, y[i] + h * k3)
        
        y[i+1] = y[i] + h/6 * (k1 + 2*k2 + 2*k3 + k4)
    
    return x, y
\end{lstlisting}

\paragraph{Schritt 3: Richtungsfeld visualisieren}
\begin{lstlisting}[language=Python, style=basesmol]
def plot_direction_field(f, xmin, xmax, ymin, ymax, hx, hy):
    x = np.arange(xmin, xmax, hx)
    y = np.arange(ymin, ymax, hy)
    X, Y = np.meshgrid(x, y)
    
    DX = np.ones_like(X)
    DY = f(X, Y)
    
    plt.quiver(X, Y, DX, DY, alpha=0.6)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title('Richtungsfeld')
\end{lstlisting}
\end{KR}

\subsection{Fehlerordnung und Konvergenz}

\begin{definition}{Lokaler und globaler Fehler}\\
\textbf{Lokaler Fehler:} Der Fehler nach einer Iteration
$\varphi(x_i, h) := y(x_{i+1}) - y_{i+1}$

\textbf{Globaler Fehler:} Der Fehler nach $n$ Iterationen
$y(x_n) - y_n$

\textbf{Konsistenzordnung $p$:} Ein Verfahren hat Konsistenzordnung $p$, falls
$|\varphi(x_i, h)| \leq C \cdot h^{p+1}$

\textbf{Konvergenzordnung $p$:} Ein Verfahren hat Konvergenzordnung $p$, falls
$|y(x_n) - y_n| \leq C \cdot h^p$
\end{definition}

\begin{concept}{Konvergenzordnungen der Verfahren}\\
\begin{itemize}
    \item \textbf{Euler-Verfahren:} Konvergenzordnung $p = 1$
    \item \textbf{Mittelpunkt-Verfahren:} Konvergenzordnung $p = 2$
    \item \textbf{Modifiziertes Euler-Verfahren:} Konvergenzordnung $p = 2$
    \item \textbf{Klassisches Runge-Kutta:} Konvergenzordnung $p = 4$
\end{itemize}

\textbf{Praktische Bedeutung:} Bei Halbierung der Schrittweite $h$ reduziert sich der Fehler um den Faktor $2^p$.
\end{concept}

\begin{example2}{Konvergenzverhalten untersuchen}\\
\textbf{Aufgabe:} Untersuchen Sie das Konvergenzverhalten verschiedener Verfahren für $\frac{dy}{dx} = \frac{x^2}{y}$ mit $y(0) = 2$ auf $[0, 10]$.
\tcblower
\textbf{Lösung:}

\textbf{Exakte Lösung:} $y(x) = \sqrt{\frac{2x^3}{3} + 4}$

\textbf{Fehler bei $x = 10$ für verschiedene $h$:}

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
$h$ & Euler & Mittelpunkt & Mod. Euler & Runge-Kutta \\
\hline
0.1 & $10^{-1}$ & $10^{-2}$ & $10^{-2}$ & $10^{-5}$ \\
\hline
0.05 & $5 \times 10^{-2}$ & $2.5 \times 10^{-3}$ & $2.5 \times 10^{-3}$ & $6 \times 10^{-7}$ \\
\hline
0.025 & $2.5 \times 10^{-2}$ & $6 \times 10^{-4}$ & $6 \times 10^{-4}$ & $4 \times 10^{-8}$ \\
\hline
\end{tabular}
\end{center}

\textbf{Beobachtung:} Bei Halbierung von $h$:
\begin{itemize}
    \item Euler: Fehler halbiert sich (Ordnung 1)
    \item Mittelpunkt/Mod. Euler: Fehler viertelt sich (Ordnung 2)
    \item Runge-Kutta: Fehler wird um Faktor 16 kleiner (Ordnung 4)
\end{itemize}
\end{example2}

\subsection{Spezielle Anwendungen}

\begin{example2}{Schwingungsgleichung - Gekoppeltes System}\\
\textbf{Aufgabe:} Lösen Sie die Schwingungsgleichung $\ddot{x} + \omega^2 x = 0$ mit $x(0) = 1$, $\dot{x}(0) = 0$ und $\omega = 2$.
\tcblower
\textbf{Lösung:}

\textbf{System 1. Ordnung:}
$z_1' = z_2$
$z_2' = -\omega^2 z_1 = -4z_1$

\textbf{Anfangsbedingungen:} $z_1(0) = 1$, $z_2(0) = 0$

\textbf{Analytische Lösung:} $x(t) = \cos(2t)$

\textbf{Numerische Implementierung:}
\begin{lstlisting}[language=Python, style=basesmol]
def harmonic_oscillator(t, z):
    # z[0] = x, z[1] = dx/dt
    return [z[1], -4*z[0]]

# Losung mit scipy
sol = solve_ivp(harmonic_oscillator, [0, 10], [1, 0], 
                method='RK45', dense_output=True)

t = np.linspace(0, 10, 1000)
z = sol.sol(t)
x_num = z[0]
x_exact = np.cos(2*t)

plt.plot(t, x_num, 'b-', label='Numerisch')
plt.plot(t, x_exact, 'r--', label='Exakt')
plt.legend()
\end{lstlisting}

\textbf{Energieerhaltung prüfen:} 
$E = \frac{1}{2}\dot{x}^2 + \frac{1}{2}\omega^2 x^2 = \text{const}$
\end{example2}

\begin{example2}{Populationsdynamik - Logistisches Wachstum}\\
\textbf{Aufgabe:} Das logistische Wachstumsmodell lautet:
$\frac{dP}{dt} = rP\left(1 - \frac{P}{K}\right)$
mit Wachstumsrate $r = 0.1$ und Kapazität $K = 1000$. Anfangspopulation: $P(0) = 50$.
\tcblower
\textbf{Lösung:}

\textbf{Analytische Lösung:}
$P(t) = \frac{K}{1 + \left(\frac{K}{P_0} - 1\right)e^{-rt}}$

\textbf{Numerische Lösung:}
\begin{lstlisting}[language=Python, style=basesmol]
def logistic_growth(t, P, r=0.1, K=1000):
    return r * P * (1 - P/K)

# Parameter
r, K, P0 = 0.1, 1000, 50

# Numerische Loesung
sol = solve_ivp(lambda t, P: logistic_growth(t, P, r, K), 
                [0, 100], [P0], dense_output=True)

# Analytische Loesung
def P_exact(t):
    return K / (1 + (K/P0 - 1) * np.exp(-r*t))

t = np.linspace(0, 100, 1000)
P_num = sol.sol(t)[0]
P_ana = P_exact(t)

plt.plot(t, P_num, 'b-', label='Numerisch')
plt.plot(t, P_ana, 'r--', label='Analytisch')
plt.axhline(y=K, color='k', linestyle=':', label='Kapazitaet K')
plt.xlabel('Zeit t')
plt.ylabel('Population P(t)')
plt.legend()
\end{lstlisting}

\textbf{Charakteristisches Verhalten:} Exponentielles Wachstum für kleine $P$, Sättigung bei $K$.
\end{example2}

\subsection{Erweiterte Themen}

\begin{concept}{Mehrschrittverfahren}\\
Im Gegensatz zu Einschrittverfahren verwenden Mehrschrittverfahren mehrere vorhergehende Punkte:

\textbf{Adams-Bashforth 2. Ordnung:}
$y_{i+1} = y_i + \frac{h}{2}(3f(x_i, y_i) - f(x_{i-1}, y_{i-1}))$

\textbf{Adams-Bashforth 3. Ordnung:}
$y_{i+1} = y_i + \frac{h}{12}(23f(x_i, y_i) - 16f(x_{i-1}, y_{i-1}) + 5f(x_{i-2}, y_{i-2}))$

\textbf{Vorteil:} Effizienter (weniger Funktionsauswertungen pro Schritt)
\textbf{Nachteil:} Benötigen Startwerte von Einschrittverfahren
\end{concept}

\begin{concept}{Implizite Verfahren}\\
Implizite Verfahren sind stabiler, aber aufwendiger zu berechnen:

\textbf{Implizites Euler-Verfahren:}
$y_{i+1} = y_i + h \cdot f(x_{i+1}, y_{i+1})$

Erfordert Lösung einer nichtlinearen Gleichung in jedem Schritt (z.B. mit Newton-Verfahren).

\textbf{Anwendung:} Steife Differentialgleichungen, bei denen explizite Verfahren sehr kleine Schrittweiten erfordern.
\end{concept}

\begin{concept}{Steife Differentialgleichungen}\\
Steife DGL haben stark unterschiedliche Zeitskalen und erfordern spezielle Behandlung:

\textbf{Beispiel:} $y' = -1000y + \sin(x)$

Die exakte Lösung hat sowohl schnell abklingende ($e^{-1000x}$) als auch langsam variierende ($\sin(x)$) Komponenten.

\textbf{Problem:} Explizite Verfahren benötigen $h < \frac{2}{1000}$ für Stabilität, auch wenn nur die langsame Komponente interessiert.

\textbf{Lösung:} Implizite Verfahren (BDF, Radau) oder adaptive Verfahren mit Steifigkeitserkennung.
\end{concept}

\begin{KR}{Verfahren auswählen}\\
\paragraph{Schritt 1: Problemanalyse}
\begin{itemize}
    \item Ist die DGL steif? $\rightarrow$ Implizite Verfahren
    \item Hohe Genauigkeit erforderlich? $\rightarrow$ Runge-Kutta höherer Ordnung
    \item Lange Zeitintegrationen? $\rightarrow$ Adaptive Schrittweiten
    \item Einfache Probleme? $\rightarrow$ RK4 oder scipy.solve\_ivp
\end{itemize}

\paragraph{Schritt 2: Implementierungsstrategie}
\begin{itemize}
    \item Beginne mit Standard-Verfahren (RK4)
    \item Teste Konvergenz durch Schrittweiten-Variation
    \item Vergleiche mit analytischen Lösungen (falls verfügbar)
    \item Bei Instabilität: Kleinere Schrittweiten oder andere Verfahren
\end{itemize}

\paragraph{Schritt 3: Qualitätskontrolle}
\begin{itemize}
    \item Energieerhaltung bei konservativen Systemen
    \item Monotonie-Eigenschaften
    \item Langzeit-Stabilität
    \item Vergleich verschiedener Verfahren
\end{itemize}
\end{KR}

\begin{remark}
\textbf{Zusammenfassung - Wann welches Verfahren?}
\begin{itemize}
    \item \textbf{Euler:} Einfachste Implementierung, Lernzwecke, grobe Näherungen
    \item \textbf{Mittelpunkt/Modifiziert:} Bessere Genauigkeit als Euler, moderater Aufwand
    \item \textbf{Runge-Kutta 4:} Standard für die meisten Probleme, gute Balance zwischen Genauigkeit und Aufwand
    \item \textbf{Adaptive Verfahren:} Komplexe Probleme, automatische Schrittweitenkontrolle
    \item \textbf{Implizite Verfahren:} Steife Probleme, Langzeit-Stabilität
    \item \textbf{Spezialisierte Methoden:} Symplektische Integratoren für Hamiltonssche Systeme, geometrische Integratoren
\end{itemize}

\textbf{Praktischer Tipp:} Verwende \texttt{scipy.integrate.solve\_ivp()} mit automatischer Methodenwahl für die meisten Anwendungen.
\end{remark}

\section{Claude try 1}

\section{Ordinary Differential Equations}

\subsection{Introduction and Motivation}

\begin{definition}{Ordinary Differential Equation}\\
An ordinary differential equation (ODE) is an equation that contains derivatives of an unknown function with respect to a single independent variable. 

A first-order ODE has the form:
\begin{align*}
\frac{dy}{dt} = f(t, y(t))
\end{align*}
where $y(t)$ is the unknown function, $t$ is the independent variable, and $f$ is a given function.

An $n^{th}$-order ODE has the form:
\begin{align*}
y^{(n)}(x) = f(x, y(x), y'(x), ..., y^{(n-1)}(x))
\end{align*}
where $y^{(n)}$ denotes the $n^{th}$ derivative of $y$.
\end{definition}

\begin{definition}{Initial Value Problem}\\
An initial value problem (IVP) for an $n^{th}$-order ODE specifies the function values and its first $n-1$ derivatives at a particular point $x_0$:
\begin{align*}
y^{(n)}(x) &= f(x, y(x), y'(x), ..., y^{(n-1)}(x))\\
y(x_0) &= y_0\\
y'(x_0) &= y_1\\
&\vdots\\
y^{(n-1)}(x_0) &= y_{n-1}
\end{align*}

For a first-order ODE, an IVP simply specifies $y(x_0) = y_0$.
\end{definition}

\subsection{Examples from Natural Sciences}

\subsubsection{Free Fall}

\begin{example2}{Free Fall}\\
Consider an object falling freely in a vacuum near Earth's surface. If we denote the position by $s(t)$ (with positive direction upward), the motion is governed by:
\begin{align*}
\ddot{s}(t) = -g
\end{align*}
where $g \approx 9.81 \text{ m/s}^2$ is the gravitational acceleration, and $\ddot{s}(t)$ is the second derivative of position with respect to time (i.e., acceleration).

This is a second-order ODE, which can be solved by direct integration:
\begin{align*}
\ddot{s}(t) &= -g\\
\dot{s}(t) &= -gt + v_0\\
s(t) &= -\frac{1}{2}gt^2 + v_0t + s_0
\end{align*}

Here, $v_0 = \dot{s}(0)$ is the initial velocity, and $s_0 = s(0)$ is the initial height.

For $s_0 = 1000 \text{ m}$, $v_0 = 0$, and $g = 10 \text{ m/s}^2$, the position after 3 seconds is:
\begin{align*}
s(3) &= -\frac{1}{2} \cdot 10 \cdot 3^2 + 0 \cdot 3 + 1000\\
&= -45 + 1000 = 955 \text{ m}
\end{align*}

The object reaches the ground ($s = 0$) when:
\begin{align*}
-\frac{1}{2} \cdot 10 \cdot t^2 + 1000 &= 0\\
t &= \sqrt{\frac{2 \cdot 1000}{10}} = 14.14 \text{ s}
\end{align*}

At impact, its velocity is:
\begin{align*}
\dot{s}(14.14) = -10 \cdot 14.14 = -141.4 \text{ m/s} \approx -509.1 \text{ km/h}
\end{align*}
\end{example2}

\subsubsection{Harmonic Oscillator}

\begin{example2}{Harmonic Oscillator}\\
The motion of a mass $m$ attached to a spring with spring constant $c$ is governed by:
\begin{align*}
m\ddot{x} = -cx
\end{align*}
where $x$ is displacement from equilibrium.

This equation can be rewritten as:
\begin{align*}
\ddot{x} = -\frac{c}{m}x = -\omega_0^2 x
\end{align*}
where $\omega_0 = \sqrt{\frac{c}{m}}$ is the natural frequency.

The general solution is:
\begin{align*}
x(t) = A \sin(\omega_0 t + \phi)
\end{align*}
where $A$ is the amplitude and $\phi$ is the phase shift, determined by initial conditions.

The position $x(t)$ oscillates with period $T = \frac{2\pi}{\omega_0}$, demonstrating the characteristic behavior of simple harmonic motion.
\end{example2}

\subsection{Direction Fields}

\begin{definition}{Direction Field}\\
A direction field (or slope field) is a graphical representation of a first-order ODE $y' = f(x,y)$. At each point $(x,y)$ in the plane, a small line segment with slope $f(x,y)$ is drawn, indicating the direction a solution curve would take through that point.

Direction fields help visualize the behavior of solutions without actually solving the ODE. Solution curves to the ODE are always tangent to the direction field at each point.
\end{definition}

\begin{example2}{Direction Field Example}\\
Consider the ODE $y' = x^2 + 0.1y$. The direction field shows small line segments with slope $x^2 + 0.1y$ at various points in the $(x,y)$-plane.

For example:
\begin{itemize}
    \item At point $(-1, 1)$, the slope is $(-1)^2 + 0.1 \cdot 1 = 1.1$
    \item At point $(0.5, 1)$, the slope is $(0.5)^2 + 0.1 \cdot 1 = 0.35$
\end{itemize}

Solution curves pass through these points tangent to these slopes, gradually revealing the complete solution path.
\end{example2}

\subsection{Numerical Methods for First-Order ODEs}

\subsubsection{Euler's Method}

\begin{KR}{Euler's Method}\\
Euler's method is the simplest numerical approach for solving first-order IVPs. It approximates the solution by using the tangent line at each step.

\paragraph{Problem Statement}
Given an IVP $y' = f(x,y)$ with $y(a) = y_0$ on interval $[a,b]$.

\paragraph{Algorithm}
\begin{enumerate}
    \item Choose a step size $h = \frac{b-a}{n}$ for some integer $n > 0$
    \item Set $x_0 = a$ and calculate $x_i = a + ih$ for $i = 1, 2, \ldots, n$
    \item Set $y_0 = y(a)$
    \item For $i = 0, 1, \ldots, n-1$, compute:
    \begin{align*}
    y_{i+1} = y_i + h \cdot f(x_i, y_i)
    \end{align*}
\end{enumerate}

\paragraph{Error Analysis}
The local truncation error (error after one step) is $O(h^2)$, and the global truncation error (total accumulated error) is $O(h)$.

\paragraph{Interpretation}
Euler's method follows the tangent line at $(x_i, y_i)$ for a distance $h$. It approximates the curve by a sequence of short line segments.
\end{KR}

\begin{example2}{Euler's Method Application}\\
Solve the IVP $y' = t^2 + 0.1y$ with $y(-1.5) = 0$ on $[-1.5, 1.5]$ using Euler's method with $n = 5$ steps.

Step size: $h = \frac{1.5-(-1.5)}{5} = 0.6$

Points: $x_0 = -1.5, x_1 = -0.9, x_2 = -0.3, x_3 = 0.3, x_4 = 0.9, x_5 = 1.5$

Computations:
\begin{align*}
y_0 &= 0\\
y_1 &= y_0 + h \cdot f(x_0, y_0) = 0 + 0.6 \cdot ((-1.5)^2 + 0.1 \cdot 0) = 0.6 \cdot 2.25 = 1.35\\
y_2 &= y_1 + h \cdot f(x_1, y_1) = 1.35 + 0.6 \cdot ((-0.9)^2 + 0.1 \cdot 1.35)\\
&= 1.35 + 0.6 \cdot (0.81 + 0.135) = 1.35 + 0.6 \cdot 0.945 = 1.917\\
\end{align*}

Continuing this process gives the approximate solution at the specified points.
\end{example2}

\subsubsection{Midpoint Method}

\begin{KR}{Midpoint Method}\\
The midpoint method (also called the modified Euler method or the second-order Runge-Kutta method) improves on Euler's method by using the slope at the midpoint of each interval.

\paragraph{Problem Statement}
Given an IVP $y' = f(x,y)$ with $y(a) = y_0$ on interval $[a,b]$.

\paragraph{Algorithm}
\begin{enumerate}
    \item Choose a step size $h = \frac{b-a}{n}$ for some integer $n > 0$
    \item Set $x_0 = a$ and calculate $x_i = a + ih$ for $i = 1, 2, \ldots, n$
    \item Set $y_0 = y(a)$
    \item For $i = 0, 1, \ldots, n-1$:
    \begin{itemize}
        \item Calculate midpoint values:
        \begin{align*}
        x_{h/2} &= x_i + \frac{h}{2}\\
        y_{h/2} &= y_i + \frac{h}{2} \cdot f(x_i, y_i)
        \end{align*}
        \item Update using the midpoint slope:
        \begin{align*}
        y_{i+1} &= y_i + h \cdot f(x_{h/2}, y_{h/2})
        \end{align*}
    \end{itemize}
\end{enumerate}

\paragraph{Error Analysis}
Both the local and global truncation errors are better than Euler's method, with a global error of $O(h^2)$.
\end{KR}

\begin{example2}{Midpoint Method Application}\\
Solve the IVP $y' = t^2 + 0.1y$ with $y(-1.5) = 0$ on $[-1.5, 1.5]$ using the midpoint method with $n = 5$ steps.

Step size: $h = \frac{1.5-(-1.5)}{5} = 0.6$

First step:
\begin{align*}
x_{h/2} &= x_0 + \frac{h}{2} = -1.5 + 0.3 = -1.2\\
y_{h/2} &= y_0 + \frac{h}{2} \cdot f(x_0, y_0) = 0 + 0.3 \cdot ((-1.5)^2 + 0.1 \cdot 0)\\
&= 0.3 \cdot 2.25 = 0.675\\
y_1 &= y_0 + h \cdot f(x_{h/2}, y_{h/2})\\
&= 0 + 0.6 \cdot ((-1.2)^2 + 0.1 \cdot 0.675)\\
&= 0.6 \cdot (1.44 + 0.0675)\\
&= 0.6 \cdot 1.5075 = 0.9045
\end{align*}

Similar calculations are performed for each subsequent step.
\end{example2}

\subsubsection{Heun's Method (Modified Euler Method)}

\begin{KR}{Heun's Method}\\
Heun's method, also known as the improved Euler method, uses the average of the slopes at the beginning and end of each interval.

\paragraph{Problem Statement}
Given an IVP $y' = f(x,y)$ with $y(a) = y_0$ on interval $[a,b]$.

\paragraph{Algorithm}
\begin{enumerate}
    \item Choose a step size $h = \frac{b-a}{n}$ for some integer $n > 0$
    \item Set $x_0 = a$ and calculate $x_i = a + ih$ for $i = 1, 2, \ldots, n$
    \item Set $y_0 = y(a)$
    \item For $i = 0, 1, \ldots, n-1$:
    \begin{itemize}
        \item Calculate predictor (Euler step):
        \begin{align*}
        k_1 &= f(x_i, y_i)\\
        y_{i+1}^{Euler} &= y_i + h \cdot k_1
        \end{align*}
        \item Calculate corrector (average slope):
        \begin{align*}
        k_2 &= f(x_{i+1}, y_{i+1}^{Euler})\\
        y_{i+1} &= y_i + h \cdot \frac{k_1 + k_2}{2}
        \end{align*}
    \end{itemize}
\end{enumerate}

\paragraph{Error Analysis}
Like the midpoint method, Heun's method has a global error of $O(h^2)$, making it significantly more accurate than Euler's method.
\end{KR}

\begin{example2}{Heun's Method Application}\\
Solve the IVP $y' = t^2 + 0.1y$ with $y(-1.5) = 0$ on $[-1.5, 1.5]$ using Heun's method with $n = 5$ steps.

Step size: $h = \frac{1.5-(-1.5)}{5} = 0.6$

First step:
\begin{align*}
k_1 &= f(x_0, y_0) = (-1.5)^2 + 0.1 \cdot 0 = 2.25\\
y_1^{Euler} &= y_0 + h \cdot k_1 = 0 + 0.6 \cdot 2.25 = 1.35\\
k_2 &= f(x_1, y_1^{Euler}) = (-0.9)^2 + 0.1 \cdot 1.35 = 0.81 + 0.135 = 0.945\\
y_1 &= y_0 + h \cdot \frac{k_1 + k_2}{2}\\
&= 0 + 0.6 \cdot \frac{2.25 + 0.945}{2}\\
&= 0.6 \cdot 1.5975 = 0.9585
\end{align*}

Similar calculations are performed for each subsequent step.
\end{example2}

\subsection{Runge-Kutta Methods}

\begin{definition}{Runge-Kutta Methods}\\
Runge-Kutta methods are a family of iterative methods for approximating solutions to ODEs, with varying orders of accuracy. They evaluate the function $f(x,y)$ at several points within each step to build a more accurate approximation.
\end{definition}

\subsubsection{Fourth-Order Runge-Kutta Method}

\begin{KR}{Classical Fourth-Order Runge-Kutta Method}\\
The most commonly used Runge-Kutta method is the fourth-order method (RK4), which provides an excellent balance of accuracy and computational efficiency.

\paragraph{Problem Statement}
Given an IVP $y' = f(x,y)$ with $y(a) = y_0$ on interval $[a,b]$.

\paragraph{Algorithm}
\begin{enumerate}
    \item Choose a step size $h = \frac{b-a}{n}$ for some integer $n > 0$
    \item Set $x_0 = a$ and calculate $x_i = a + ih$ for $i = 1, 2, \ldots, n$
    \item Set $y_0 = y(a)$
    \item For $i = 0, 1, \ldots, n-1$:
    \begin{align*}
    k_1 &= f(x_i, y_i)\\
    k_2 &= f\left(x_i + \frac{h}{2}, y_i + \frac{h}{2}k_1\right)\\
    k_3 &= f\left(x_i + \frac{h}{2}, y_i + \frac{h}{2}k_2\right)\\
    k_4 &= f(x_i + h, y_i + hk_3)\\
    y_{i+1} &= y_i + h \cdot \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)
    \end{align*}
\end{enumerate}

\paragraph{Error Analysis}
The local truncation error is $O(h^5)$, and the global truncation error is $O(h^4)$, making RK4 significantly more accurate than lower-order methods for the same step size.

\paragraph{Interpretation}
RK4 combines four evaluations of the function $f$ at different points to create a weighted average slope. This approach effectively samples the behavior of the solution over the interval to achieve higher accuracy.
\end{KR}

\begin{example2}{Fourth-Order Runge-Kutta Method}\\
Solve the IVP $y' = t^2 + 0.1y$ with $y(-1.5) = 0$ on $[-1.5, 1.5]$ using the RK4 method with $n = 5$ steps.

Step size: $h = \frac{1.5-(-1.5)}{5} = 0.6$

First step:
\begin{align*}
k_1 &= f(x_0, y_0) = (-1.5)^2 + 0.1 \cdot 0 = 2.25\\
k_2 &= f\left(x_0 + \frac{h}{2}, y_0 + \frac{h}{2}k_1\right)\\
&= f(-1.5 + 0.3, 0 + 0.3 \cdot 2.25)\\
&= f(-1.2, 0.675)\\
&= (-1.2)^2 + 0.1 \cdot 0.675 = 1.44 + 0.0675 = 1.5075\\
k_3 &= f\left(x_0 + \frac{h}{2}, y_0 + \frac{h}{2}k_2\right)\\
&= f(-1.2, 0 + 0.3 \cdot 1.5075)\\
&= f(-1.2, 0.45225)\\
&= 1.44 + 0.1 \cdot 0.45225 = 1.44 + 0.045225 = 1.485\\
k_4 &= f(x_0 + h, y_0 + hk_3)\\
&= f(-1.5 + 0.6, 0 + 0.6 \cdot 1.485)\\
&= f(-0.9, 0.891)\\
&= (-0.9)^2 + 0.1 \cdot 0.891 = 0.81 + 0.0891 = 0.8991\\
y_1 &= y_0 + h \cdot \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\\
&= 0 + 0.6 \cdot \frac{1}{6}(2.25 + 2 \cdot 1.5075 + 2 \cdot 1.485 + 0.8991)\\
&= 0.6 \cdot \frac{1}{6}(2.25 + 3.015 + 2.97 + 0.8991)\\
&= 0.6 \cdot \frac{9.1341}{6} = 0.6 \cdot 1.5224 = 0.9134
\end{align*}

Similar calculations would be performed for each subsequent step.
\end{example2}

\subsubsection{General Runge-Kutta Methods}

\begin{definition}{General Runge-Kutta Method}\\
A general $s$-stage Runge-Kutta method for solving an ODE $y'=f(x,y)$ is defined by:
\begin{align*}
k_n &= f\left(x_i + c_n h, y_i + h \sum_{m=1}^{n-1} a_{nm} k_m \right), \text{ for } n = 1, 2, \ldots, s\\
y_{i+1} &= y_i + h \sum_{n=1}^{s} b_n k_n
\end{align*}

where $s \in \mathbb{N}$ is the number of stages, and $a_{nm}$, $b_n$, and $c_n$ are constants. The choice of these constants determines the specific method and its order of accuracy.
\end{definition}

\begin{concept}{Butcher Tableau}\\
The coefficients of a Runge-Kutta method are typically presented in a Butcher tableau:
\begin{center}
$\begin{array}{c|cccc}
c_1 & & & & \\
c_2 & a_{21} & & & \\
c_3 & a_{31} & a_{32} & & \\
\vdots & \vdots & \vdots & \ddots & \\
c_s & a_{s1} & a_{s2} & \ldots & a_{s,s-1} \\
\hline
& b_1 & b_2 & \ldots & b_s
\end{array}$
\end{center}

For example, the classical fourth-order Runge-Kutta method (RK4) has the Butcher tableau:
\begin{center}
$\begin{array}{c|cccc}
0 & & & & \\
1/2 & 1/2 & & & \\
1/2 & 0 & 1/2 & & \\
1 & 0 & 0 & 1 & \\
\hline
& 1/6 & 1/3 & 1/3 & 1/6
\end{array}$
\end{center}
\end{concept}

\subsection{Systems of Differential Equations}

\subsubsection{Reduction of Higher-Order ODEs to First-Order Systems}

\begin{KR}{Converting an $n^{th}$-order ODE to a System of First-Order ODEs}\\
Any $n^{th}$-order ODE can be converted into a system of $n$ first-order ODEs, which can then be solved using numerical methods for first-order systems.

\paragraph{Steps}
\begin{enumerate}
    \item Given an $n^{th}$-order ODE $y^{(n)} = f(x, y, y', y'', \ldots, y^{(n-1)})$
    \item Solve for the highest-order derivative: $y^{(n)} = f(x, y, y', y'', \ldots, y^{(n-1)})$
    \item Introduce new variables: 
    \begin{align*}
    z_1(x) &= y(x)\\
    z_2(x) &= y'(x)\\
    z_3(x) &= y''(x)\\
    &\vdots\\
    z_n(x) &= y^{(n-1)}(x)
    \end{align*}
    \item Derive a system of first-order ODEs:
    \begin{align*}
    z_1' &= z_2\\
    z_2' &= z_3\\
    &\vdots\\
    z_{n-1}' &= z_n\\
    z_n' &= f(x, z_1, z_2, \ldots, z_n)
    \end{align*}
    \item Express in vector form:
    \begin{align*}
    \mathbf{z}' = \mathbf{F}(x, \mathbf{z})
    \end{align*}
    where $\mathbf{z} = (z_1, z_2, \ldots, z_n)^T$
    \item Apply numerical methods for first-order systems to solve this system
\end{enumerate}
\end{KR}

\begin{example2}{Converting a Third-Order ODE to a System}\\
Consider the third-order ODE:
\begin{align*}
y''' + 5y'' + 8y' + 6y = 10e^{-x}
\end{align*}
with initial conditions $y(0) = 2$, $y'(0) = y''(0) = 0$.

Step 1: Solve for the highest-order derivative:
\begin{align*}
y''' = 10e^{-x} - 5y'' - 8y' - 6y
\end{align*}

Step 2: Introduce new variables:
\begin{align*}
z_1(x) &= y(x)\\
z_2(x) &= y'(x)\\
z_3(x) &= y''(x)
\end{align*}

Step 3: Derive the system of first-order ODEs:
\begin{align*}
z_1' &= z_2\\
z_2' &= z_3\\
z_3' &= 10e^{-x} - 5z_3 - 8z_2 - 6z_1
\end{align*}

Step 4: Initial conditions for the system:
\begin{align*}
\mathbf{z}(0) = \begin{pmatrix} 2 \\ 0 \\ 0 \end{pmatrix}
\end{align*}

This system can now be solved using numerical methods for first-order systems.
\end{example2}

\subsubsection{Solving Systems of First-Order ODEs}

\begin{KR}{Numerical Methods for Systems of ODEs}\\
The numerical methods previously discussed for scalar first-order ODEs can be extended to systems of first-order ODEs.

\paragraph{Problem Statement}
Consider a system of $n$ first-order ODEs:
\begin{align*}
\mathbf{y}'(x) = \mathbf{f}(x, \mathbf{y}(x))
\end{align*}
with initial condition $\mathbf{y}(x_0) = \mathbf{y}_0$, where $\mathbf{y}(x) \in \mathbb{R}^n$ and $\mathbf{f}: \mathbb{R} \times \mathbb{R}^n \rightarrow \mathbb{R}^n$.

\paragraph{Applying Numerical Methods}
For any numerical method defined for scalar ODEs:
\begin{align*}
y_{i+1} = y_i + h \cdot \text{Steigung}
\end{align*}
the extension to systems is:
\begin{align*}
\mathbf{y}_{i+1} = \mathbf{y}_i + h \cdot \mathbf{Steigung}
\end{align*}
where:
\begin{align*}
\mathbf{y}(x) &= \begin{pmatrix} y_1(x) \\ y_2(x) \\ \vdots \\ y_n(x) \end{pmatrix}, \quad
\mathbf{y}' = \begin{pmatrix} y_1'(x) \\ y_2'(x) \\ \vdots \\ y_n'(x) \end{pmatrix}, \quad
\mathbf{f}(x, \mathbf{y}(x)) = \begin{pmatrix} f_1(x, \mathbf{y}(x)) \\ f_2(x, \mathbf{y}(x)) \\ \vdots \\ f_n(x, \mathbf{y}(x)) \end{pmatrix}
\end{align*}

For example, Euler's method becomes:
\begin{align*}
\mathbf{y}_{i+1} = \mathbf{y}_i + h \cdot \mathbf{f}(x_i, \mathbf{y}_i)
\end{align*}

The fourth-order Runge-Kutta method becomes:
\begin{align*}
\mathbf{k}_1 &= \mathbf{f}(x_i, \mathbf{y}_i)\\
\mathbf{k}_2 &= \mathbf{f}\left(x_i + \frac{h}{2}, \mathbf{y}_i + \frac{h}{2}\mathbf{k}_1\right)\\
\mathbf{k}_3 &= \mathbf{f}\left(x_i + \frac{h}{2}, \mathbf{y}_i + \frac{h}{2}\mathbf{k}_2\right)\\
\mathbf{k}_4 &= \mathbf{f}(x_i + h, \mathbf{y}_i + h\mathbf{k}_3)\\
\mathbf{y}_{i+1} &= \mathbf{y}_i + h \cdot \frac{1}{6}(\mathbf{k}_1 + 2\mathbf{k}_2 + 2\mathbf{k}_3 + \mathbf{k}_4)
\end{align*}
\end{KR}

\subsection{Stability of Numerical Methods}

\begin{definition}{Stability}\\
Stability refers to the behavior of a numerical method when applied to an ODE. A method is stable if small errors in the computation do not lead to unbounded growth in the numerical solution.

For explicit methods, stability often depends on the step size $h$. A method is said to be conditionally stable if it is stable only for certain ranges of $h$.
\end{definition}

\begin{example2}{Stability Analysis}\\
Consider the test equation $y' = -\alpha y$ with $\alpha > 0$ and initial condition $y(0) = 1$. The exact solution is $y(x) = e^{-\alpha x}$, which decays to zero as $x$ increases.

Applying Euler's method:
\begin{align*}
y_{i+1} &= y_i + h \cdot f(x_i, y_i)\\
&= y_i - h\alpha y_i\\
&= (1 - h\alpha)y_i
\end{align*}

Iterating recursively:
\begin{align*}
y_{i+1} = (1 - h\alpha)^{i+1}y_0 = (1 - h\alpha)^{i+1}
\end{align*}

For the numerical solution to decay (as the exact solution does), we need $|1 - h\alpha| < 1$, which leads to the condition $0 < h\alpha < 2$.

Thus, for stability with Euler's method, the step size must satisfy $h < \frac{2}{\alpha}$.
\end{example2}

\begin{definition}{Stability Function and Stability Interval}\\
When applying a numerical method to the test equation $y' = -\alpha y$, if the numerical solution can be written in the form:
\begin{align*}
y_{i+1} = g(h\alpha) \cdot y_i
\end{align*}
then $g(z)$ is called the stability function of the method (with $z = h\alpha$).

The open interval $z \in (0, \alpha)$ for which $|g(z)| < 1$ is called the stability interval of the method.
\end{definition}

\subsection{Advanced Topics}

\subsubsection{Single-Step vs. Multi-Step Methods}

\begin{concept}{Single-Step vs. Multi-Step Methods}\\
Single-step methods (like Euler and Runge-Kutta) calculate $y_{i+1}$ using only information from the previous point $(x_i, y_i)$.

Multi-step methods use information from several previous points $(x_{i-k}, y_{i-k}), \ldots, (x_i, y_i)$ to calculate $y_{i+1}$. Examples include Adams-Bashforth methods, like:
\begin{align*}
y_{i+1} = y_i + \frac{h}{12}(23f(x_i, y_i) - 16f(x_{i-1}, y_{i-1}) + 5f(x_{i-2}, y_{i-2}))
\end{align*}

Multi-step methods can be more efficient but require special starting procedures since multiple previous points are needed.
\end{concept}

\subsubsection{Implicit vs. Explicit Methods}

\begin{concept}{Implicit vs. Explicit Methods}\\
Explicit methods express $y_{i+1}$ directly in terms of previously computed values. All methods discussed so far have been explicit.

Implicit methods involve $y_{i+1}$ on both sides of the equation, requiring the solution of an (often nonlinear) equation at each step. The implicit Euler method has the form:
\begin{align*}
y_{i+1} = y_i + h \cdot f(x_{i+1}, y_{i+1})
\end{align*}

While more computationally intensive, implicit methods often have better stability properties and can handle "stiff" ODEs more effectively.
\end{concept}

\subsubsection{Stiff ODEs and Adaptive Step Size}

\begin{concept}{Stiff ODEs}\\
A stiff ODE exhibits behavior at widely varying time scales, making numerical solution challenging. For stiff equations, explicit methods require extremely small step sizes to maintain stability, making them impractical.

Implicit methods are generally preferred for stiff problems because of their superior stability properties.
\end{concept}

\begin{concept}{Adaptive Step Size Control}\\
Instead of using a fixed step size $h$, adaptive methods adjust the step size based on local error estimates:
\begin{itemize}
    \item Smaller steps are used in regions where the solution changes rapidly
    \item Larger steps are used in regions where the solution changes slowly
\end{itemize}

This approach improves efficiency while maintaining accuracy.
\end{concept}

\subsection{Python Implementation}

\begin{concept}{SciPy's ODE Solvers}\\
Python's SciPy library provides several functions for solving ODEs, including:
\begin{itemize}
    \item \texttt{scipy.integrate.solve\_ivp()}: A comprehensive function that supports various methods including RK45, Radau, BDF, and LSODA
    \item Methods are specified as parameters, along with options for error control and step size adaptation
\end{itemize}

SciPy can handle both single equations and systems of equations, with support for events and dense output options.
\end{concept}