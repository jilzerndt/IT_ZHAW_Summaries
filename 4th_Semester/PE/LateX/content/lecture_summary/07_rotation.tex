\section{Rotation}

\subsection{Kinematik der Rotation}
\begin{definition}{Rotationsbewegung}\\
    Eine Rotationsbewegung ist die Drehung eines Körpers um eine bestimmte Achse. Die Beschreibung erfolgt analog zur Translation, jedoch werden andere Größen verwendet:
    \begin{itemize}
        \item Drehwinkel $\varphi$ statt Ort $\vec{r}$
        \item Winkelgeschwindigkeit $\omega$ statt Geschwindigkeit $\vec{v}$
        \item Winkelbeschleunigung $\alpha$ statt Beschleunigung $\vec{a}$
    \end{itemize}
\end{definition}

\begin{concept}{Freiheitsgrade}\\
    Ein starrer Körper im dreidimensionalen Raum hat sechs Freiheitsgrade:
    \begin{itemize}
        \item Drei translatorische Freiheitsgrade (Bewegung in x-, y- und z-Richtung)
        \item Drei rotatorische Freiheitsgrade (Drehung um die x-, y- und z-Achse)
    \end{itemize}
    Diese Bewegungen sind für einen freien Körper unabhängig voneinander.
\end{concept}

\begin{formula}{Zusammenhänge der rotatorischen Größen}\\
    Analog zur Translation gelten folgende Beziehungen:
    \begin{align}
        \omega &= \frac{d\varphi}{dt} \\
        \alpha &= \frac{d\omega}{dt} \\
        \varphi &= \int \omega \, dt \\
        \omega &= \int \alpha \, dt
    \end{align}
    
    Die Maßeinheiten sind:
    \begin{itemize}
        \item Winkel $\varphi$: Radian (rad), dimensionslos
        \item Winkelgeschwindigkeit $\omega$: rad/s
        \item Winkelbeschleunigung $\alpha$: rad/s²
    \end{itemize}
\end{formula}

\begin{concept}{Winkel in Radian}\\
    Der Winkel in Radian ist definiert als das Verhältnis von Kreisbogen $s$ zu Radius $r$:
    \begin{equation}
        \varphi = \frac{s}{r}
    \end{equation}
    
    Umrechnung zwischen Grad und Radian:
    \begin{equation}
        \varphi_{rad} = \varphi_{deg} \cdot \frac{\pi}{180}
    \end{equation}
    
    Wichtige Werte:
    \begin{itemize}
        \item Vollwinkel: $360° = 2\pi$ rad
        \item Rechter Winkel: $90° = \frac{\pi}{2}$ rad
    \end{itemize}
\end{concept}

\begin{formula}{Zusammenhang zwischen Bahngeschwindigkeit und Winkelgeschwindigkeit}\\
    Bei einer Kreisbewegung mit Radius $r$ gilt für die Bahngeschwindigkeit $v$:
    \begin{equation}
        v = \omega \cdot r
    \end{equation}
    
    Dabei ist $v$ die Geschwindigkeit eines Punktes auf dem Umfang des Kreises (tangential zur Kreisbahn) und $\omega$ die Winkelgeschwindigkeit der Rotation.
\end{formula}

\subsection{Schwerpunkt und Trägheitsmoment}
\begin{definition}{Schwerpunkt}\\
    Der Schwerpunkt (auch Massenmittelpunkt genannt) eines Körpers ist der gewichtete Mittelwert der Positionen aller Massenelemente:
    \begin{equation}
        \vec{r}_S = \frac{1}{\sum_{i=1}^{n} m_i} \cdot \sum_{i=1}^{n} m_i \cdot \vec{r}_i
    \end{equation}
    
    Für kontinuierliche Massenverteilungen:
    \begin{equation}
        \vec{r}_S = \frac{1}{M} \iiint_K \vec{r} \, \rho(\vec{r}) \, dV
    \end{equation}
    wobei $\rho(\vec{r})$ die Dichteverteilung und $M$ die Gesamtmasse ist.
\end{definition}

\begin{concept}{Schwerpunktsatz}\\
    Der Schwerpunktsatz besagt, dass eine an einem beliebigen Punkt eines starren Körpers angreifende Kraft
    \begin{itemize}
        \item eine Translation des Schwerpunktes bewirkt, so als ob die Kraft direkt am Schwerpunkt angreifen würde, und
        \item ein Drehmoment um den Schwerpunkt erzeugt, wenn die Kraftwirkungslinie nicht durch den Schwerpunkt verläuft.
    \end{itemize}
    
    Dies erlaubt die Zerlegung der Bewegung in eine Translation des Schwerpunktes und eine Rotation um den Schwerpunkt.
\end{concept}

\begin{definition}{Trägheitsmoment}\\
    Das Trägheitsmoment $J$ ist ein Maß für den Widerstand eines Körpers gegenüber Rotationsbeschleunigungen. Es ist definiert als:
    \begin{equation}
        J = \sum_{i=1}^{n} m_i \cdot r_i^2
    \end{equation}
    
    Für kontinuierliche Massenverteilungen:
    \begin{equation}
        J = \iiint_K r^2 \, \rho(\vec{r}) \, dV
    \end{equation}
    
    Dabei ist $r$ der senkrechte Abstand des Massenelements von der Drehachse.
\end{definition}

\begin{formula}{Trägheitsmomente einfacher Körper}\\
    Einige wichtige Trägheitsmomente:
    \begin{itemize}
        \item Punktmasse $m$ im Abstand $r$ von der Drehachse: $J = m \cdot r^2$
        \item Dünner Stab der Länge $L$ und Masse $m$ (Drehachse durch Mitte, senkrecht zum Stab): $J = \frac{1}{12} \cdot m \cdot L^2$
        \item Dünner Stab (Drehachse am Ende): $J = \frac{1}{3} \cdot m \cdot L^2$
        \item Vollzylinder der Masse $m$ und Radius $R$ (Drehachse = Symmetrieachse): $J = \frac{1}{2} \cdot m \cdot R^2$
        \item Hohlzylinder (Drehachse = Symmetrieachse): $J = m \cdot R^2$
        \item Kugel der Masse $m$ und Radius $R$ (Drehachse durch Mittelpunkt): $J = \frac{2}{5} \cdot m \cdot R^2$
    \end{itemize}
\end{formula}

\begin{concept}{Steiner'scher Satz}\\
    Der Steiner'sche Satz beschreibt, wie sich das Trägheitsmoment ändert, wenn die Drehachse parallel verschoben wird:
    \begin{equation}
        J = J_S + m \cdot d^2
    \end{equation}
    
    Dabei ist:
    \begin{itemize}
        \item $J_S$ das Trägheitsmoment bezüglich einer Achse durch den Schwerpunkt
        \item $m$ die Gesamtmasse des Körpers
        \item $d$ der Abstand zwischen den parallelen Achsen
    \end{itemize}
\end{concept}

\subsection{Dynamik der Rotation}
\begin{formula}{Drehmoment}\\
    Das Drehmoment $\vec{M}$ ist die Ursache einer Rotationsbeschleunigung. Es ist definiert als das Kreuzprodukt aus Hebelarm $\vec{r}$ und Kraft $\vec{F}$:
    \begin{equation}
        \vec{M} = \vec{r} \times \vec{F}
    \end{equation}
    
    Der Betrag des Drehmoments ist:
    \begin{equation}
        M = r \cdot F \cdot \sin(\alpha)
    \end{equation}
    wobei $\alpha$ der Winkel zwischen Hebelarm und Kraft ist.
    
    Alternativ:
    \begin{equation}
        M = F \cdot d
    \end{equation}
    wobei $d$ der senkrechte Abstand der Kraftwirkungslinie von der Drehachse ist.
\end{formula}

\begin{formula}{Zweites Newton'sches Gesetz für Rotationen}\\
    Analog zum zweiten Newton'schen Gesetz für translatorische Bewegungen gilt für Rotationen:
    \begin{equation}
        \vec{M} = J \cdot \vec{\alpha}
    \end{equation}
    
    Diese Gleichung verknüpft das Drehmoment mit der resultierenden Winkelbeschleunigung.
\end{formula}

\begin{definition}{Drehimpuls}\\
    Der Drehimpuls $\vec{L}$ ist das rotatorische Analogon zum linearen Impuls. Er ist definiert als:
    \begin{equation}
        \vec{L} = J \cdot \vec{\omega}
    \end{equation}
    
    Für einen Punktteilchen mit Impuls $\vec{p}$ im Abstand $\vec{r}$ von der Drehachse:
    \begin{equation}
        \vec{L} = \vec{r} \times \vec{p}
    \end{equation}
    
    Das Drehmoment ändert den Drehimpuls gemäß:
    \begin{equation}
        \vec{M} = \frac{d\vec{L}}{dt}
    \end{equation}
\end{definition}

\begin{concept}{Drehimpulserhaltung}\\
    In Abwesenheit äußerer Drehmomente bleibt der Drehimpuls eines Systems konstant:
    \begin{equation}
        \vec{L} = \text{const.}
    \end{equation}
    
    Die Drehimpulserhaltung ist neben der Impuls- und Energieerhaltung ein fundamentales Erhaltungsgesetz der Physik.
    
    Beispiele:
    \begin{itemize}
        \item Eiskunstläufer, der die Arme anzieht, um schneller zu rotieren
        \item Stabilität von Fahrrädern aufgrund der rotierenden Räder
        \item Präzession eines Kreisels
    \end{itemize}
\end{concept}

\begin{formula}{Rotationsenergie}\\
    Die kinetische Energie der Rotation (Rotationsenergie) ist gegeben durch:
    \begin{equation}
        E_{rot} = \frac{1}{2} \cdot J \cdot \omega^2
    \end{equation}
    
    Die Gesamtenergie eines Körpers, der sowohl translatorische als auch rotatorische Bewegung erfährt, ist:
    \begin{equation}
        E_{ges} = E_{trans} + E_{rot} = \frac{1}{2} \cdot m \cdot v^2 + \frac{1}{2} \cdot J \cdot \omega^2
    \end{equation}
\end{formula}

\begin{KR}{Berechnung rotatorischer Größen}\\
    \paragraph{Berechnung des Schwerpunkts zusammengesetzter Körper}
    \begin{enumerate}
        \item Teile den Körper in einfache Formen mit bekannten Schwerpunkten
        \item Berechne die Gesamtmasse: $M = \sum m_i$
        \item Berechne den Schwerpunkt: $\vec{r}_S = \frac{1}{M} \sum m_i \cdot \vec{r}_i$
    \end{enumerate}
    
    \paragraph{Berechnung des Drehmoments}
    \begin{enumerate}
        \item Identifiziere alle wirkenden Kräfte $\vec{F}_i$
        \item Bestimme ihre Hebelarme $\vec{r}_i$ bezüglich der Drehachse
        \item Berechne die einzelnen Drehmomente: $\vec{M}_i = \vec{r}_i \times \vec{F}_i$
        \item Summiere alle Drehmomente: $\vec{M}_{ges} = \sum \vec{M}_i$
    \end{enumerate}
    
    \paragraph{Winkelbeschleunigung aus Drehmoment}
    \begin{enumerate}
        \item Berechne das resultierende Drehmoment $\vec{M}_{ges}$
        \item Bestimme das Trägheitsmoment $J$ bezüglich der Drehachse
        \item Berechne die Winkelbeschleunigung: $\vec{\alpha} = \frac{\vec{M}_{ges}}{J}$
    \end{enumerate}
\end{KR}

\begin{examplecode}{Drehmoment in Unity}\\
    \begin{lstlisting}[language=csh, style=basesmol]
// Drehmoment auf einen Koerper aufbringen
void ApplyTorque() {
    // Angriffspunkt relativ zum Massenmittelpunkt des Koerpers
    Vector3 relativePos = transform.TransformPoint(localForcePoint) - 
                          rigidbody.worldCenterOfMass;
    
    // Kraft berechnen (z.B. in diesem Fall eine konstante Kraft)
    Vector3 force = new Vector3(0, 0, forceAmount);
    
    // Drehmoment als Kreuzprodukt aus Hebelarm und Kraft
    Vector3 torque = Vector3.Cross(relativePos, force);
    
    // Kraft und Drehmoment auf den Koerper anwenden
    rigidbody.AddForceAtPosition(force, transform.TransformPoint(localForcePoint));
    
    // Alternative: Drehmoment direkt anwenden
    // rigidbody.AddTorque(torque);
}
    \end{lstlisting}
\end{examplecode}

\begin{example2}{Rotation eines Würfels über eine Kante}\\
    Ein Würfel der Kantenlänge $a$ und Masse $m$ wird über seine Kante gestoßen.
    
    \begin{itemize}
        \item Trägheitsmoment bezüglich der Kante: $J = \frac{m}{6}(2a^2) = \frac{m \cdot a^2}{3}$
        
        \item Wenn der Schwerpunkt über die Kante hinausragt, wirkt ein Drehmoment aufgrund der Gewichtskraft:
        $M = m \cdot g \cdot \frac{a}{2} \cdot \sin\varphi$
        wobei $\varphi$ der Winkel zwischen der Vertikalen und der Linie vom Drehpunkt zum Schwerpunkt ist.
        
        \item Die resultierende Winkelbeschleunigung ist:
        $\alpha = \frac{M}{J} = \frac{3 \cdot g \cdot \sin\varphi}{2a}$
        
        \item Beim horizontalen Stoßen mit einer Kraft $F$ entlang einer Linie, die um $h$ vom Schwerpunkt versetzt ist, entsteht ein Drehmoment:
        $M = F \cdot h$
        
        \item Dies führt zu einer kombinierten Translation und Rotation des Würfels.
    \end{itemize}
\end{example2}

\subsection{Orientierung im Raum und Quaternionen}
\begin{concept}{Euler-Winkel}\\
    Euler-Winkel sind ein Satz von drei Winkeln, die eine Rotation im dreidimensionalen Raum vollständig beschreiben:
    \begin{itemize}
        \item Pitch ($\varphi$): Drehung um die x-Achse
        \item Yaw ($\theta$): Drehung um die y-Achse
        \item Roll ($\psi$): Drehung um die z-Achse
    \end{itemize}
    
    Bei der Anwendung von Euler-Winkeln ist die Reihenfolge der Drehungen entscheidend. Außerdem muss unterschieden werden zwischen:
    \begin{itemize}
        \item Intrinsischen Drehungen: Die Achsen drehen sich mit dem Objekt
        \item Extrinsischen Drehungen: Die Achsen bleiben fixiert
    \end{itemize}
\end{concept}

\begin{concept}{Quaternionen in Unity}\\
    Unity verwendet intern Quaternionen zur Darstellung von Rotationen, da diese mehrere Vorteile gegenüber Euler-Winkeln bieten:
    \begin{itemize}
        \item Keine "Gimbal-Lock"-Probleme (Verlust eines Freiheitsgrades bei bestimmten Orientierungen)
        \item Effizientere Interpolation zwischen Rotationen
        \item Numerisch stabiler
    \end{itemize}
    
    Quaternionen haben die Form $q = a + bi + cj + dk$, wobei $i^2 = j^2 = k^2 = ijk = -1$.
    
    Eine Rotation um eine Achse $\vec{n}$ mit dem Winkel $\alpha$ wird als Quaternion dargestellt:
    \begin{equation}
        q = \cos\left(\frac{\alpha}{2}\right) + \sin\left(\frac{\alpha}{2}\right)(n_xi + n_yj + n_zk)
    \end{equation}
\end{concept}

\begin{KR}{Arbeiten mit Quaternionen in Unity}\\
    \paragraph{Erzeugung einer Quaternion}
    \begin{lstlisting}[language=csh, style=basesmol]
// Eine Quaternion aus Euler-Winkeln erzeugen
Quaternion rotation = Quaternion.Euler(30f, 45f, 0f); // Drehung: 30 Grad um x, 45 Grad um y

// Eine Quaternion aus einer Achse und einem Winkel erzeugen
Vector3 axis = new Vector3(0, 1, 0); // y-Achse
float angle = 45f; // 45 Grad
Quaternion fromAxisAngle = Quaternion.AngleAxis(angle, axis);
    \end{lstlisting}
    
    \paragraph{Anwenden einer Rotation}
    \begin{lstlisting}[language=csh, style=basesmol]
// Rotationen kombinieren (zuerst rotA, dann rotB)
Quaternion combinedRotation = rotB * rotA;

// Quaternion auf einen Vektor anwenden, um ihn zu rotieren
Vector3 rotatedVector = myQuaternion * originalVector;

// Objekt rotieren
transform.rotation = myQuaternion;

// Inkrementelle Rotation
transform.rotation = myQuaternion * transform.rotation;
    \end{lstlisting}
    
    \paragraph{Interpolation zwischen Rotationen}
    \begin{lstlisting}[language=csh, style=basesmol]
// Sphaerische Interpolation zwischen zwei Rotationen
Quaternion interpolated = Quaternion.Slerp(startRotation, endRotation, t);
// t ist ein Wert zwischen 0 und 1
    \end{lstlisting}
\end{KR}

\subsection{Standfestigkeit und physikalisches Gleichgewicht}
\begin{concept}{Standfestigkeit}\\
    Ein Körper ist standfest, wenn die Wirkungslinie der Gewichtskraft durch die Unterstützungsfläche verläuft. Man unterscheidet drei Arten von Gleichgewicht:
    
    \begin{itemize}
        \item Stabiles Gleichgewicht: Nach einer kleinen Auslenkung kehrt der Körper in seine Ausgangslage zurück (potentielle Energie im Minimum)
        \item Labiles Gleichgewicht: Nach einer kleinen Auslenkung entfernt sich der Körper weiter von seiner Ausgangslage (potentielle Energie im Maximum)
        \item Indifferentes Gleichgewicht: Nach einer Auslenkung verharrt der Körper in der neuen Position (potentielle Energie konstant)
    \end{itemize}
\end{concept}

\begin{formula}{Kippkriterium}\\
    Ein Körper kippt, wenn die Wirkungslinie der Gewichtskraft außerhalb der Unterstützungsfläche verläuft.
    
    Für einen Quader mit Grundfläche $b \times l$ und Höhe $h$ auf einer um den Winkel $\alpha$ geneigten Ebene gilt als Kippkriterium:
    \begin{equation}
        \tan\alpha > \frac{b}{2h}
    \end{equation}
    
    Dabei ist $b$ die Breite des Quaders in Richtung der Neigung.
\end{formula}

\begin{example2}{Standfestigkeit eines Turms}\\
    Ein Turm aus mehreren Bausteinen ist standfest, wenn der Schwerpunkt jedes Teilstücks (bestehend aus allen Steinen oberhalb eines bestimmten Punktes) über der Unterstützungsfläche liegt.
    
    Bei einem Überhang von Bausteinen muss der Schwerpunkt der überhängenden Steine durch das Gegengewicht der nicht überhängenden Steine ausgeglichen werden, damit der gemeinsame Schwerpunkt noch über der Unterstützungsfläche bleibt.
    
    Der maximale Überhang für $n$ identische Bausteine, die jeweils um einen bestimmten Abstand verschoben sind, wird durch die harmonische Reihe beschrieben:
    \begin{equation}
        \text{Überhang}_{\text{max}} = \frac{L}{2} \cdot \sum_{i=1}^{n} \frac{1}{i}
    \end{equation}
    wobei $L$ die Länge eines Bausteins ist.
\end{example2}

\begin{remark}
    In Unity ist die korrekte Modellierung von Standfestigkeit und Gleichgewicht wichtig für:
    \begin{itemize}
        \item Realistische Darstellung von stehenden oder gestapelten Objekten
        \item Simulierte Reaktionen auf Stöße und Kräfte
        \item Korrekte Kippsimulationen und Fallbewegungen
    \end{itemize}
    
    Um zuverlässige Ergebnisse zu erhalten, müssen sowohl die Kollisionsgeometrie als auch die Massenverteilung (insbesondere die Position des Schwerpunkts) korrekt definiert werden.
\end{remark}

\section{Rotational Motion}

\subsection{Rotational Kinematics}

\begin{definition}{Angular Quantities}
    \begin{itemize}
        \item \textbf{Angular position:} $\theta$ (radians)
        \item \textbf{Angular velocity:} $\omega = \frac{d\theta}{dt}$ (rad/s)
        \item \textbf{Angular acceleration:} $\alpha = \frac{d\omega}{dt} = \frac{d^2\theta}{dt^2}$ (rad/s²)
    \end{itemize}
\end{definition}

\begin{concept}{Relationship to Linear Motion}\\
    For circular motion with radius $r$:
    \begin{itemize}
        \item Arc length: $s = r\theta$
        \item Linear velocity: $v = r\omega$
        \item Tangential acceleration: $a_t = r\alpha$
        \item Centripetal acceleration: $a_c = \frac{v^2}{r} = r\omega^2$
    \end{itemize}
\end{concept}

\begin{formula}{Rotational Kinematic Equations}\\
    For constant angular acceleration $\alpha$:
    
    \paragraph{Angular velocity:} $\omega(t) = \omega_0 + \alpha t$
    
    \paragraph{Angular position:} $\theta(t) = \theta_0 + \omega_0 t + \frac{1}{2}\alpha t^2$
    
    \paragraph{Velocity-position relation:} $\omega^2 = \omega_0^2 + 2\alpha(\theta - \theta_0)$
\end{formula}

\begin{code}{Rotational Motion in Unity}\\
\begin{lstlisting}[language=C, style=basesmol]
public class RotationalMotion : MonoBehaviour 
{
    public float angularVelocity = 90f; // degrees per second
    public float angularAcceleration = 10f; // degrees per second squared
    
    private float currentAngularVel;
    
    void Start() 
    {
        currentAngularVel = angularVelocity;
    }
    
    void Update() 
    {
        // Update angular velocity
        currentAngularVel += angularAcceleration * Time.deltaTime;
        
        // Apply rotation
        transform.Rotate(Vector3.up, currentAngularVel * Time.deltaTime);
        
        // Alternative: Set angular velocity directly on Rigidbody
        // GetComponent<Rigidbody>().angularVelocity = 
        //     Vector3.up * currentAngularVel * Mathf.Deg2Rad;
    }
}
\end{lstlisting}
\end{code}

\subsection{Moment of Inertia}

\begin{definition}{Moment of Inertia}\\
    Measure of an object's resistance to rotational acceleration:
    $$I = \sum_i m_i r_i^2 = \int r^2 \, dm$$
    
    where $r_i$ is the perpendicular distance from the rotation axis.
\end{definition}

\begin{formula}{Common Moments of Inertia}\\
    \paragraph{Point mass:} $I = mr^2$
    
    \paragraph{Solid cylinder (about center axis):} $I = \frac{1}{2}mr^2$
    
    \paragraph{Solid sphere (about center):} $I = \frac{2}{5}mr^2$
    
    \paragraph{Thin rod (about center):} $I = \frac{1}{12}ml^2$
    
    \paragraph{Thin rod (about end):} $I = \frac{1}{3}ml^2$
\end{formula}

\begin{concept}{Parallel Axis Theorem}\\
    For axis parallel to center-of-mass axis:
    $$I = I_{cm} + md^2$$
    
    where $d$ is the distance between axes.
\end{concept}

\subsection{Rotational Dynamics}

\begin{concept}{Newton's Second Law for Rotation}\\
    $$\sum \tau = I\alpha$$
    
    where $\tau$ is torque, $I$ is moment of inertia, and $\alpha$ is angular acceleration.
\end{concept}

\begin{definition}{Torque}\\
    $$\vec{\tau} = \vec{r} \times \vec{F}$$
    
    Magnitude: $\tau = rF\sin\phi$
    
    where $\phi$ is angle between $\vec{r}$ and $\vec{F}$.
\end{definition}

\begin{code}{Calculating Torque in Unity}\\
\begin{lstlisting}[language=C, style=basesmol]
public class TorqueCalculation : MonoBehaviour 
{
    public Transform forceApplication; // Point where force is applied
    public Vector3 forceVector = Vector3.forward;
    
    void Update() 
    {
        // Calculate position vector from rotation center to force application
        Vector3 leverArm = forceApplication.position - transform.position;
        
        // Calculate torque using cross product
        Vector3 torque = Vector3.Cross(leverArm, forceVector);
        
        // Apply torque to rigidbody
        GetComponent<Rigidbody>().AddTorque(torque);
        
        // Debug visualization
        Debug.DrawRay(transform.position, leverArm, Color.red);
        Debug.DrawRay(forceApplication.position, forceVector, Color.blue);
        Debug.DrawRay(transform.position, torque, Color.green);
    }
}
\end{lstlisting}
\end{code}

\subsection{Rotational Energy}

\begin{definition}{Rotational Kinetic Energy}\\
    $$K_{rot} = \frac{1}{2}I\omega^2$$
    
    For rolling motion (combined translation and rotation):
    $$K_{total} = \frac{1}{2}mv_{cm}^2 + \frac{1}{2}I_{cm}\omega^2$$
\end{definition}

\begin{concept}{Rolling Without Slipping}\\
    Condition: $v_{cm} = R\omega$
    
    where $R$ is radius and $v_{cm}$ is center-of-mass velocity.
    
    Total kinetic energy: $K = \frac{1}{2}mv^2(1 + \frac{I}{mR^2})$
\end{concept}

\subsection{Work and Power in Rotation}

\begin{definition}{Rotational Work}\\
    $$W = \int \tau \, d\theta$$
    
    For constant torque: $W = \tau\Delta\theta$
\end{definition}

\begin{definition}{Rotational Power}\\
    $$P = \tau\omega$$
    
    Analogous to $P = Fv$ for linear motion.
\end{definition}

\begin{formula}{Work-Energy Theorem for Rotation}\\
    $$W_{net} = \Delta K_{rot} = \frac{1}{2}I\omega_f^2 - \frac{1}{2}I\omega_i^2$$
\end{formula}

\begin{code}{Energy Analysis for Rotating Object}\\
\begin{lstlisting}[language=C, style=basesmol]
public class RotationalEnergyMonitor : MonoBehaviour 
{
    private Rigidbody rb;
    
    void Start() 
    {
        rb = GetComponent<Rigidbody>();
    }
    
    void Update() 
    {
        // Calculate rotational kinetic energy
        // Unity stores angular velocity in rad/s
        float angularSpeed = rb.angularVelocity.magnitude;
        
        // Approximate moment of inertia (for sphere)
        float momentOfInertia = 0.4f * rb.mass * 
                               Mathf.Pow(GetComponent<SphereCollider>().radius, 2);
        
        float rotationalKE = 0.5f * momentOfInertia * angularSpeed * angularSpeed;
        
        // Translational kinetic energy
        float translationalKE = 0.5f * rb.mass * rb.velocity.sqrMagnitude;
        
        // Total kinetic energy
        float totalKE = rotationalKE + translationalKE;
        
        Debug.Log($"Rot KE: {rotationalKE:F2}, Trans KE: {translationalKE:F2}, " +
                  $"Total: {totalKE:F2}");
    }
}
\end{lstlisting}
\end{code}

\subsection{Angular Momentum}

\begin{definition}{Angular Momentum for Rigid Body}\\
    $$\vec{L} = I\vec{\omega}$$
    
    For point particle:
    $$\vec{L} = \vec{r} \times \vec{p} = m\vec{r} \times \vec{v}$$
\end{definition}

\begin{concept}{Conservation of Angular Momentum}\\
    When net external torque is zero:
    $$\frac{d\vec{L}}{dt} = \vec{\tau}_{ext} = 0 \Rightarrow \vec{L} = \text{constant}$$
    
    Applications: spinning ice skater, planetary motion, gyroscopes
\end{concept}

\begin{KR}{Rotational Problem Solving}\\
    \paragraph{Step 1: Identify rotation axis}
    \begin{itemize}
        \item Fixed axis (door hinge) or moving axis (rolling ball)
        \item Choose coordinate system with axis perpendicular to motion plane
    \end{itemize}
    
    \paragraph{Step 2: Calculate moment of inertia}
    \begin{itemize}
        \item Use standard formulas for common shapes
        \item Apply parallel axis theorem if needed
        \item For composite objects, sum individual moments
    \end{itemize}
    
    \paragraph{Step 3: Analyze forces and torques}
    \begin{itemize}
        \item Calculate torque: $\tau = rF\sin\phi$
        \item Apply $\sum \tau = I\alpha$ for dynamics
        \item Consider constraints (rolling, fixed axis, etc.)
    \end{itemize}
    
    \paragraph{Step 4: Apply conservation laws}
    \begin{itemize}
        \item Energy conservation for rolling down inclines
        \item Angular momentum conservation for isolated systems
        \item Combined linear and angular analysis for complex motion
    \end{itemize}
\end{KR}

\begin{example2}{Rolling Sphere Down Incline}\\
    A solid sphere (radius $R$, mass $m$) rolls without slipping down an incline of angle $\theta$. Find the acceleration of the center of mass.
    \tcblower
    \textbf{Given:} $I = \frac{2}{5}mR^2$ for solid sphere, rolling condition $a = R\alpha$
    
    \textbf{Force analysis:}
    \begin{itemize}
        \item Down incline: $mg\sin\theta - f = ma$
        \item Torque about center: $fR = I\alpha = \frac{2}{5}mR^2 \cdot \frac{a}{R}$
    \end{itemize}
    
    \textbf{From torque equation:} $f = \frac{2}{5}ma$
    
    \textbf{Substituting into force equation:}
    $mg\sin\theta - \frac{2}{5}ma = ma$
    
    $mg\sin\theta = ma(1 + \frac{2}{5}) = \frac{7}{5}ma$
    
    $a = \frac{5g\sin\theta}{7} = 0.714 \times g\sin\theta$
    
    \textbf{Note:} This is less than $g\sin\theta$ for sliding because some energy goes into rotation.
\end{example2}

\begin{example2}{Torque Application in Unity}\\
    Create a Unity script to simulate a door opening with applied torque, including realistic damping.
    \tcblower
\begin{lstlisting}[language=C, style=basesmol]
public class DoorController : MonoBehaviour 
{
    public float maxTorque = 50f;
    public float dampingCoefficient = 2f;
    public float maxAngle = 90f;
    
    private Rigidbody rb;
    private float initialAngle;
    
    void Start() 
    {
        rb = GetComponent<Rigidbody>();
        initialAngle = transform.eulerAngles.y;
    }
    
    void FixedUpdate() 
    {
        float currentAngle = transform.eulerAngles.y - initialAngle;
        if (currentAngle > 180f) currentAngle -= 360f;
        
        if (Input.GetKey(KeyCode.Space) && currentAngle < maxAngle) 
        {
            rb.AddTorque(Vector3.up * maxTorque);
        }
        
        // Apply damping torque
        Vector3 dampingTorque = -dampingCoefficient * rb.angularVelocity;
        rb.AddTorque(dampingTorque);
        
        // Limit rotation
        if (Mathf.Abs(currentAngle) > maxAngle) 
        {
            rb.angularVelocity = Vector3.zero;
            Vector3 angles = transform.eulerAngles;
            angles.y = initialAngle + Mathf.Sign(currentAngle) * maxAngle;
            transform.eulerAngles = angles;
        }
    }
}
\end{lstlisting}
\end{example2}