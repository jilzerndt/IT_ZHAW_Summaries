\section{Rotation}

\subsection{Kinematik der Rotation}

\begin{definition}{Rotationsbewegung}
    Eine Rotationsbewegung ist die Drehung eines Körpers um eine bestimmte Achse. Die Beschreibung erfolgt analog zur Translation mit rotatorischen Größen:
    \begin{itemize}
        \item Drehwinkel $\varphi$ statt Ort $\vec{r}$
        \item Winkelgeschwindigkeit $\omega$ statt Geschwindigkeit $\vec{v}$
        \item Winkelbeschleunigung $\alpha$ statt Beschleunigung $\vec{a}$
    \end{itemize}
\end{definition}

\begin{concept}{Freiheitsgrade}
    Ein starrer Körper im dreidimensionalen Raum hat sechs Freiheitsgrade:
    \begin{itemize}
        \item Drei translatorische Freiheitsgrade (Bewegung in x-, y- und z-Richtung)
        \item Drei rotatorische Freiheitsgrade (Drehung um die x-, y- und z-Achse)
    \end{itemize}
    Diese Bewegungen sind für einen freien Körper unabhängig voneinander.
\end{concept}

\begin{formula}{Rotatorische Kinematik}
    Analog zur Translation gelten folgende Beziehungen:
    \begin{align}
        \omega &= \frac{d\varphi}{dt} \\
        \alpha &= \frac{d\omega}{dt} = \frac{d^2\varphi}{dt^2} \\
        \varphi &= \int \omega \, dt \\
        \omega &= \int \alpha \, dt
    \end{align}
    
    \textbf{Für konstante Winkelbeschleunigung:}
    \begin{align}
        \omega(t) &= \omega_0 + \alpha t \\
        \varphi(t) &= \varphi_0 + \omega_0 t + \frac{1}{2}\alpha t^2 \\
        \omega^2 &= \omega_0^2 + 2\alpha(\varphi - \varphi_0)
    \end{align}
    
    Die Maßeinheiten sind:
    \begin{itemize}
        \item Winkel $\varphi$: Radian (rad), dimensionslos
        \item Winkelgeschwindigkeit $\omega$: rad/s
        \item Winkelbeschleunigung $\alpha$: rad/s²
    \end{itemize}
\end{formula}

\begin{concept}{Winkel in Radian}
    Der Winkel in Radian ist definiert als das Verhältnis von Kreisbogen $s$ zu Radius $r$:
    \begin{equation}
        \varphi = \frac{s}{r}
    \end{equation}
    
    Umrechnung zwischen Grad und Radian:
    \begin{equation}
        \varphi_{rad} = \varphi_{deg} \cdot \frac{\pi}{180}
    \end{equation}
    
    Wichtige Werte:
    \begin{itemize}
        \item Vollwinkel: $360° = 2\pi$ rad
        \item Rechter Winkel: $90° = \frac{\pi}{2}$ rad
    \end{itemize}
\end{concept}

\begin{formula}{Zusammenhang zwischen linearer und Rotationsbewegung}
    Bei einer Kreisbewegung mit Radius $r$ gelten folgende Beziehungen:
    \begin{align}
        s &= r\varphi \quad \text{(Bogenlänge)} \\
        v &= r\omega \quad \text{(Bahngeschwindigkeit)} \\
        a_t &= r\alpha \quad \text{(Tangentialbeschleunigung)} \\
        a_c &= \frac{v^2}{r} = r\omega^2 \quad \text{(Zentripetalbeschleunigung)}
    \end{align}
    
    Dabei ist $v$ die Geschwindigkeit eines Punktes auf dem Umfang (tangential zur Kreisbahn) und $\omega$ die Winkelgeschwindigkeit der Rotation.
\end{formula}

\subsection{Schwerpunkt und Trägheitsmoment}

\begin{definition}{Schwerpunkt}
    Der Schwerpunkt (Massenmittelpunkt) eines Körpers ist der gewichtete Mittelwert der Positionen aller Massenelemente:
    \begin{equation}
        \vec{r}_S = \frac{1}{\sum_{i=1}^{n} m_i} \cdot \sum_{i=1}^{n} m_i \cdot \vec{r}_i
    \end{equation}
    
    Für kontinuierliche Massenverteilungen:
    \begin{equation}
        \vec{r}_S = \frac{1}{M} \iiint_K \vec{r} \, \rho(\vec{r}) \, dV
    \end{equation}
    wobei $\rho(\vec{r})$ die Dichteverteilung und $M$ die Gesamtmasse ist.
\end{definition}

\begin{concept}{Schwerpunktsatz}
    Der Schwerpunktsatz besagt, dass eine an einem beliebigen Punkt eines starren Körpers angreifende Kraft
    \begin{itemize}
        \item eine Translation des Schwerpunktes bewirkt, so als ob die Kraft direkt am Schwerpunkt angreifen würde, und
        \item ein Drehmoment um den Schwerpunkt erzeugt, wenn die Kraftwirkungslinie nicht durch den Schwerpunkt verläuft.
    \end{itemize}
    
    Dies erlaubt die Zerlegung der Bewegung in eine Translation des Schwerpunktes und eine Rotation um den Schwerpunkt.
\end{concept}

\begin{definition}{Trägheitsmoment}
    Das Trägheitsmoment $I$ ist ein Maß für den Widerstand eines Körpers gegenüber Rotationsbeschleunigungen:
    \begin{equation}
        I = \sum_{i=1}^{n} m_i \cdot r_i^2
    \end{equation}
    
    Für kontinuierliche Massenverteilungen:
    \begin{equation}
        I = \iiint_K r^2 \, \rho(\vec{r}) \, dV = \int r^2 \, dm
    \end{equation}
    
    Dabei ist $r$ der senkrechte Abstand des Massenelements von der Drehachse.
\end{definition}

\begin{formula}{Trägheitsmomente wichtiger Körper}
    \paragraph{Punktmasse:} $I = mr^2$
    
    \paragraph{Dünner Stab (Länge $L$, Achse durch Mitte):} $I = \frac{1}{12}mL^2$
    
    \paragraph{Dünner Stab (Achse am Ende):} $I = \frac{1}{3}mL^2$
    
    \paragraph{Vollzylinder (Radius $R$, Symmetrieachse):} $I = \frac{1}{2}mR^2$
    
    \paragraph{Hohlzylinder (Symmetrieachse):} $I = mR^2$
    
    \paragraph{Vollkugel (Radius $R$, Achse durch Mittelpunkt):} $I = \frac{2}{5}mR^2$
\end{formula}

\begin{concept}{Steiner'scher Satz (Parallelachsentheorem)}
    Für eine Achse parallel zur Schwerpunktachse im Abstand $d$:
    \begin{equation}
        I = I_S + md^2
    \end{equation}
    
    Dabei ist:
    \begin{itemize}
        \item $I_S$ das Trägheitsmoment bezüglich einer Achse durch den Schwerpunkt
        \item $m$ die Gesamtmasse des Körpers
        \item $d$ der Abstand zwischen den parallelen Achsen
    \end{itemize}
\end{concept}

\subsection{Dynamik der Rotation}

\begin{definition}{Drehmoment}
    Das Drehmoment $\vec{\tau}$ ist die Ursache einer Rotationsbeschleunigung:
    \begin{equation}
        \vec{\tau} = \vec{r} \times \vec{F}
    \end{equation}
    
    Der Betrag des Drehmoments ist:
    \begin{equation}
        \tau = rF\sin\phi = Fd
    \end{equation}
    wobei $\phi$ der Winkel zwischen Hebelarm und Kraft ist und $d$ der senkrechte Abstand der Kraftwirkungslinie von der Drehachse.
\end{definition}

\begin{formula}{Newton'sches Gesetz für Rotationen}
    Analog zum zweiten Newton'schen Gesetz für Translation:
    \begin{equation}
        \sum \vec{\tau} = I\vec{\alpha}
    \end{equation}
    
    Diese Gleichung verknüpft das resultierende Drehmoment mit der Winkelbeschleunigung.
\end{formula}

\begin{definition}{Drehimpuls}
    Der Drehimpuls $\vec{L}$ ist das rotatorische Analogon zum linearen Impuls:
    \begin{equation}
        \vec{L} = I\vec{\omega}
    \end{equation}
    
    Für ein Punktteilchen mit Impuls $\vec{p}$ im Abstand $\vec{r}$ von der Drehachse:
    \begin{equation}
        \vec{L} = \vec{r} \times \vec{p} = m\vec{r} \times \vec{v}
    \end{equation}
    
    Das Drehmoment ändert den Drehimpuls gemäß:
    \begin{equation}
        \vec{\tau} = \frac{d\vec{L}}{dt}
    \end{equation}
\end{definition}

\begin{concept}{Drehimpulserhaltung}
    In Abwesenheit äußerer Drehmomente bleibt der Drehimpuls konstant:
    \begin{equation}
        \frac{d\vec{L}}{dt} = \vec{\tau}_{ext} = 0 \Rightarrow \vec{L} = \text{const.}
    \end{equation}
    
    \textbf{Anwendungen:}
    \begin{itemize}
        \item Eiskunstläufer, der die Arme anzieht, um schneller zu rotieren
        \item Stabilität von Fahrrädern aufgrund der rotierenden Räder
        \item Präzession eines Kreisels
        \item Planetenbewegung
    \end{itemize}
\end{concept}

\begin{formula}{Rotationsenergie}
    Die kinetische Energie der Rotation:
    \begin{equation}
        E_{rot} = \frac{1}{2}I\omega^2
    \end{equation}
    
    Für kombinierte Translation und Rotation:
    \begin{equation}
        E_{ges} = \frac{1}{2}mv_{cm}^2 + \frac{1}{2}I_{cm}\omega^2
    \end{equation}
    
    \textbf{Rollbedingung ohne Schlupf:} $v_{cm} = R\omega$
    
    Dann: $E_{ges} = \frac{1}{2}mv^2(1 + \frac{I}{mR^2})$
\end{formula}

\begin{formula}{Arbeit und Leistung bei Rotation}
    \textbf{Rotationsarbeit:}
    \begin{equation}
        W = \int \tau \, d\varphi
    \end{equation}
    
    Für konstantes Drehmoment: $W = \tau\Delta\varphi$
    
    \textbf{Rotationsleistung:}
    \begin{equation}
        P = \tau\omega
    \end{equation}
    
    \textbf{Arbeitssatz für Rotation:}
    \begin{equation}
        W_{net} = \Delta E_{rot} = \frac{1}{2}I\omega_f^2 - \frac{1}{2}I\omega_i^2
    \end{equation}
\end{formula}

\subsection{Orientierung im Raum und Quaternionen}

\begin{concept}{Euler-Winkel}
    Euler-Winkel beschreiben eine Rotation im dreidimensionalen Raum durch drei Winkel:
    \begin{itemize}
        \item Pitch ($\varphi$): Drehung um die x-Achse
        \item Yaw ($\theta$): Drehung um die y-Achse
        \item Roll ($\psi$): Drehung um die z-Achse
    \end{itemize}
    
    \textbf{Wichtig:} Die Reihenfolge der Drehungen ist entscheidend!
    \begin{itemize}
        \item Intrinsische Drehungen: Achsen drehen sich mit dem Objekt
        \item Extrinsische Drehungen: Achsen bleiben fixiert
    \end{itemize}
\end{concept}

\begin{concept}{Quaternionen in Unity}
    Unity verwendet Quaternionen zur Darstellung von Rotationen wegen ihrer Vorteile:
    \begin{itemize}
        \item Keine "Gimbal-Lock"-Probleme
        \item Effizientere Interpolation zwischen Rotationen
        \item Numerisch stabiler
    \end{itemize}
    
    Quaternionen haben die Form $q = w + xi + yj + zk$, wobei $i^2 = j^2 = k^2 = ijk = -1$.
    
    Rotation um Achse $\vec{n}$ mit Winkel $\alpha$:
    \begin{equation}
        q = \cos\left(\frac{\alpha}{2}\right) + \sin\left(\frac{\alpha}{2}\right)(n_xi + n_yj + n_zk)
    \end{equation}
\end{concept}

\subsection{Standfestigkeit und Gleichgewicht}

\begin{concept}{Standfestigkeit}
    Ein Körper ist standfest, wenn die Wirkungslinie der Gewichtskraft durch die Unterstützungsfläche verläuft.
    
    \textbf{Gleichgewichtsarten:}
    \begin{itemize}
        \item \textbf{Stabil}: Rückkehr zur Ausgangslage (Energie-Minimum)
        \item \textbf{Labil}: Entfernung von Ausgangslage (Energie-Maximum)
        \item \textbf{Indifferent}: Verharren in neuer Position (konstante Energie)
    \end{itemize}
\end{concept}

\begin{formula}{Kippkriterium}
    Ein Körper kippt, wenn die Wirkungslinie der Gewichtskraft außerhalb der Unterstützungsfläche verläuft.
    
    Für einen Quader (Breite $b$, Höhe $h$) auf geneigter Ebene (Winkel $\alpha$):
    \begin{equation}
        \tan\alpha > \frac{b}{2h}
    \end{equation}
\end{formula}

\subsection{Unity Implementation}

\begin{code}{Rotationsbewegung in Unity}
\begin{lstlisting}[language=C, style=basesmol]
public class RotationalMotion : MonoBehaviour 
{
    public float angularVelocity = 90f; // Grad pro Sekunde
    public float angularAcceleration = 10f; // Grad pro Sekunde^2
    
    private float currentAngularVel;
    
    void Start() 
    {
        currentAngularVel = angularVelocity;
    }
    
    void Update() 
    {
        // Winkelgeschwindigkeit aktualisieren
        currentAngularVel += angularAcceleration * Time.deltaTime;
        
        // Rotation anwenden
        transform.Rotate(Vector3.up, currentAngularVel * Time.deltaTime);
        
        // Alternative: Winkelgeschwindigkeit direkt am Rigidbody setzen
        // GetComponent<Rigidbody>().angularVelocity = 
        //     Vector3.up * currentAngularVel * Mathf.Deg2Rad;
    }
}
\end{lstlisting}
\end{code}

\begin{code}{Drehmoment berechnen und anwenden}
\begin{lstlisting}[language=C, style=basesmol]
public class TorqueCalculation : MonoBehaviour 
{
    public Transform forceApplication; // Kraftangriffspunkt
    public Vector3 forceVector = Vector3.forward;
    public float torqueStrength = 100f;
    
    private Rigidbody rb;
    
    void Start() 
    {
        rb = GetComponent<Rigidbody>();
    }
    
    void Update() 
    {
        // Hebelarm vom Rotationszentrum zum Kraftangriffspunkt
        Vector3 leverArm = forceApplication.position - transform.position;
        
        // Drehmoment als Kreuzprodukt berechnen
        Vector3 torque = Vector3.Cross(leverArm, forceVector);
        
        // Drehmoment anwenden
        rb.AddTorque(torque);
        
        // Direkte Drehmomentanwendung
        if (Input.GetKey(KeyCode.Q)) 
        {
            rb.AddTorque(Vector3.up * torqueStrength);
        }
        
        // Debug-Visualisierung
        Debug.DrawRay(transform.position, leverArm, Color.red);
        Debug.DrawRay(forceApplication.position, forceVector, Color.blue);
        Debug.DrawRay(transform.position, torque, Color.green);
    }
}
\end{lstlisting}
\end{code}

\begin{code}{Quaternionen in Unity verwenden}
\begin{lstlisting}[language=C, style=basesmol]
public class QuaternionExample : MonoBehaviour 
{
    void Start() 
    {
        // Quaternion aus Euler-Winkeln erzeugen
        Quaternion rotation = Quaternion.Euler(30f, 45f, 0f);
        
        // Quaternion aus Achse und Winkel erzeugen
        Vector3 axis = Vector3.up;
        float angle = 45f;
        Quaternion fromAxisAngle = Quaternion.AngleAxis(angle, axis);
        
        // Rotationen kombinieren (zuerst rotA, dann rotB)
        Quaternion combinedRotation = rotation * fromAxisAngle;
        
        // Quaternion auf Vektor anwenden
        Vector3 rotatedVector = rotation * Vector3.forward;
        
        // Objekt rotieren
        transform.rotation = rotation;
        
        // Sphaerische Interpolation zwischen Rotationen
        Quaternion interpolated = Quaternion.Slerp(
            Quaternion.identity, rotation, 0.5f);
    }
}
\end{lstlisting}
\end{code}

\begin{code}{Rotationsenergie-Monitor}
\begin{lstlisting}[language=C, style=basesmol]
public class RotationalEnergyMonitor : MonoBehaviour 
{
    private Rigidbody rb;
    
    void Start() 
    {
        rb = GetComponent<Rigidbody>();
    }
    
    void Update() 
    {
        // Rotationsenergie berechnen
        float angularSpeed = rb.angularVelocity.magnitude;
        
        // Traegheitsmoment approximieren (fuer Kugel)
        float radius = GetComponent<SphereCollider>().radius;
        float momentOfInertia = 0.4f * rb.mass * radius * radius;
        
        float rotationalKE = 0.5f * momentOfInertia * angularSpeed * angularSpeed;
        
        // Translationsenergie
        float translationalKE = 0.5f * rb.mass * rb.velocity.sqrMagnitude;
        
        // Gesamtenergie
        float totalKE = rotationalKE + translationalKE;
        
        Debug.Log($"Rot KE: {rotationalKE:F2}, Trans KE: {translationalKE:F2}, " +
                  $"Total: {totalKE:F2}");
    }
}
\end{lstlisting}
\end{code}

\begin{KR}{Rotationsprobleme lösen}
    \paragraph{Schritt 1: Rotationsachse identifizieren}
    \begin{itemize}
        \item Feste Achse (Türscharnier) oder bewegliche Achse (rollender Ball)
        \item Koordinatensystem mit Achse senkrecht zur Bewegungsebene wählen
    \end{itemize}
    
    \paragraph{Schritt 2: Trägheitsmoment berechnen}
    \begin{itemize}
        \item Standardformeln für einfache Formen verwenden
        \item Steiner'schen Satz anwenden wenn nötig
        \item Für zusammengesetzte Objekte einzelne Momente summieren
    \end{itemize}
    
    \paragraph{Schritt 3: Kräfte und Drehmomente analysieren}
    \begin{itemize}
        \item Drehmoment berechnen: $\tau = rF\sin\phi$
        \item $\sum \tau = I\alpha$ für Dynamik anwenden
        \item Randbedingungen berücksichtigen (Rollen, feste Achse, etc.)
    \end{itemize}
    
    \paragraph{Schritt 4: Erhaltungsgesetze anwenden}
    \begin{itemize}
        \item Energieerhaltung für Objekte auf schiefen Ebenen
        \item Drehimpulserhaltung für isolierte Systeme
        \item Kombinierte linear-rotatorische Analyse für komplexe Bewegungen
    \end{itemize}
\end{KR}

\begin{example2}{Kugel rollt schiefe Ebene hinunter}
    Eine Vollkugel (Radius $R$, Masse $m$) rollt ohne Schlupf eine schiefe Ebene mit Winkel $\theta$ hinunter. Berechne die Beschleunigung des Schwerpunkts.
    \tcblower
    \textbf{Gegeben:} $I = \frac{2}{5}mR^2$ für Vollkugel, Rollbedingung $a = R\alpha$
    
    \textbf{Kräfteanalyse:}
    \begin{itemize}
        \item Entlang der Ebene: $mg\sin\theta - f = ma$
        \item Drehmoment um Schwerpunkt: $fR = I\alpha = \frac{2}{5}mR^2 \cdot \frac{a}{R}$
    \end{itemize}
    
    \textbf{Aus Drehmomentgleichung:} $f = \frac{2}{5}ma$
    
    \textbf{Einsetzen in Kraftgleichung:}
    $mg\sin\theta - \frac{2}{5}ma = ma$
    
    $mg\sin\theta = ma(1 + \frac{2}{5}) = \frac{7}{5}ma$
    
    $a = \frac{5g\sin\theta}{7} = 0.714 \times g\sin\theta$
    
    \textbf{Ergebnis:} Die Beschleunigung ist kleiner als beim Rutschen ($g\sin\theta$), da Energie in Rotation fließt.
\end{example2}

\begin{example2}{Türsteuerung mit Drehmoment}
    Unity-Script für realistische Türsimulation mit Drehmoment und Dämpfung:
    \tcblower
\begin{lstlisting}[language=C, style=basesmol]
public class DoorController : MonoBehaviour 
{
    public float maxTorque = 50f;
    public float dampingCoefficient = 2f;
    public float maxAngle = 90f;
    
    private Rigidbody rb;
    private float initialAngle;
    
    void Start() 
    {
        rb = GetComponent<Rigidbody>();
        initialAngle = transform.eulerAngles.y;
    }
    
    void FixedUpdate() 
    {
        float currentAngle = transform.eulerAngles.y - initialAngle;
        if (currentAngle > 180f) currentAngle -= 360f;
        
        // Tuer oeffnen
        if (Input.GetKey(KeyCode.Space) && currentAngle < maxAngle) 
        {
            rb.AddTorque(Vector3.up * maxTorque);
        }
        
        // Daempfung anwenden
        Vector3 dampingTorque = -dampingCoefficient * rb.angularVelocity;
        rb.AddTorque(dampingTorque);
        
        // Rotationsbegrenzung
        if (Mathf.Abs(currentAngle) > maxAngle) 
        {
            rb.angularVelocity = Vector3.zero;
            Vector3 angles = transform.eulerAngles;
            angles.y = initialAngle + Mathf.Sign(currentAngle) * maxAngle;
            transform.eulerAngles = angles;
        }
    }
}
\end{lstlisting}
\end{example2}

\begin{example2}{Maximaler Überhang gestapelter Objekte}
    Ein Turm aus $n$ identischen Bausteinen der Länge $L$ kann maximal überhängen um:
    \begin{equation}
        \text{Überhang}_{\text{max}} = \frac{L}{2} \cdot \sum_{i=1}^{n} \frac{1}{i} = \frac{L}{2}(1 + \frac{1}{2} + \frac{1}{3} + ... + \frac{1}{n})
    \end{equation}
    
    Dies basiert auf der harmonischen Reihe und zeigt, dass theoretisch unbegrenzte Überhänge möglich sind (divergente Reihe).
\end{example2}