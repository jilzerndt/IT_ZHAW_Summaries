\section{Einführung und Grundlagen}

\begin{concept}{Physics Engines}
    Physics Engines sind Softwarekomponenten, die physikalische Effekte in Computerprogrammen simulieren. Unity verwendet PhysX als Standard-Physics-Engine.
    
    \textbf{Ziele des Moduls:}
    \begin{itemize}
        \item Physikalische Modellierung in Unity verstehen
        \item Grundprinzipien der Mechanik für realistische Simulationen anwenden
        \item Kopplung von Physiksimulatoren mit realistischen Parametern
    \end{itemize}
\end{concept}

\begin{remark}
    \textbf{Modellbildungsprozess:}
    Wirklichkeit $\rightarrow$ Physikalisches Modell $\rightarrow$ Mathematisches Modell $\rightarrow$ Numerisches Modell $\rightarrow$ Unity-Implementation
\end{remark}

\subsubsection{Bezugssysteme in der Mechanik}
\mult{2}

\begin{definition}{Bezugssystem}
    Ein Bezugssystem definiert:
    \begin{itemize}
        \item Einen Nullpunkt im Raum
        \item Die Richtungen der Koordinatenachsen (x, y, z)
        \item Eine Zeitmessung
    \end{itemize}
    Dadurch wird die Position eines Körpers eindeutig durch einen Ortsvektor $\vec{r}$ beschrieben.
\end{definition}

\begin{concept}{Vektoren}
    Ein Vektor ist eine physikalische Größe mit Betrag und Richtung.
    \begin{itemize}
        \item Darstellung: $\vec{r}$ (mit Pfeil über dem Symbol)
        \item Betrag: $|\vec{r}| = r$ (ohne Pfeil)
        \item In Koordinatendarstellung: $\vec{r} = \begin{pmatrix} r_x \\ r_y \\ r_z \end{pmatrix}$
        \item Einheitsvektor (Betrag = 1): $\vec{e}_r = \frac{\vec{r}}{|\vec{r}|}$
    \end{itemize}
\end{concept}

\begin{formula}{Rechenregeln für Vektoren}
    \begin{itemize}
        \item Addition: $$\vec{r}_1 + \vec{r}_2 = \begin{pmatrix} r_{x1} \\ r_{y1} \\ r_{z1} \end{pmatrix} + \begin{pmatrix} r_{x2} \\ r_{y2} \\ r_{z2} \end{pmatrix} = \begin{pmatrix} r_{x1} + r_{x2} \\ r_{y1} + r_{y2} \\ r_{z1} + r_{z2} \end{pmatrix}$$
        
        \item Skalarprodukt (ergibt einen Skalar): 
        $$s = \vec{r}_1 \cdot \vec{r}_2 = |\vec{r}_1| \cdot |\vec{r}_2| \cdot \cos \angle(\vec{r}_1, \vec{r}_2)$$ $$ = r_{x1}r_{x2} + r_{y1}r_{y2} + r_{z1}r_{z2}$$
        
        \item Kreuzprodukt (ergibt einen Vektor):
        $$\vec{r}_1 \times \vec{r}_2 = \begin{pmatrix} r_{y1}r_{z2} - r_{z1}r_{y2} \\ r_{z1}r_{x2} - r_{x1}r_{z2} \\ r_{x1}r_{y2} - r_{y1}r_{x2} \end{pmatrix}$$
    \end{itemize}
\end{formula}



\begin{definition}{SI-Einheiten}
    \begin{itemize}
        \item Länge in Meter (m)
        \item Masse in Kilogramm (kg)
        \item Zeit in Sekunden (s)
        \item Kraft in Newton (N = kg·m/s²)
    \end{itemize}
    Es ist wichtig, in Unity konsequent SI-Einheiten zu verwenden und bei allen Werten entsprechende Einheiten anzugeben.
\end{definition}

\begin{example}
    Für die Umrechnung der Geschwindigkeit von km/h in m/s teilt man durch 3,6:
    $v[m/s] = \frac{v[km/h]}{3,6}$
    
    Beispiel: 72 km/h = 72 / 3,6 = 20 m/s
\end{example}

\begin{concept}{Unity-Physik Grundlagen}
    \textbf{Wichtige Konzepte:}
    \begin{itemize}
        \item Physikalische Größen immer mit Einheiten kommentieren
        \item Rigidbody für Position/Geschwindigkeit verwenden
        \item AddForce() für Kraftanwendung
        \item FixedUpdate() für Physikberechnungen
    \end{itemize}
\end{concept}

\begin{definition}{Vector3 in Unity}
    \begin{itemize}
        \item \texttt{Vector3} für 3D-Positionen und -Richtungen
        \item Wichtige Eigenschaften: \texttt{Vector3.forward}, \texttt{Vector3.up}, \texttt{Vector3.right}
        \item Operationen: Skalarprodukt, Kreuzprodukt, Betrag, Normalisierung
    \end{itemize}
\end{definition}

\begin{example2}{Unity vs. Standard-Koordinatensystem}\\
    \textbf{Unterschiede:}
    \begin{itemize}
        \item Standard-Physik: Rechtssystem
        \item Unity: Linkssystem
        \item Unity: positive y-Achse zeigt nach oben
    \end{itemize}
    
    \textbf{Auswirkungen:} Unterschiedliche Kreuzprodukt-Ergebnisse und Rotationsrichtungen.
\end{example2}

\multend




